"use client";
import {
  en_US_default
} from "./chunk-PP5SIRTN.js";
import {
  call_exports,
  mini_exports
} from "./chunk-D5KRJCT3.js";
import "./chunk-OR67L7UC.js";
import "./chunk-ALUSTTMD.js";
import {
  mainnet
} from "./chunk-4IQ4SPGE.js";
import {
  Base64_exports,
  Log_exports,
  P256_exports,
  TransactionReceipt_exports,
  TypedData_exports,
  WebAuthnP256_exports,
  blake3,
  ens_normalize,
  p256
} from "./chunk-JVCYDNCV.js";
import {
  AbiError_exports,
  HDKey,
  generateMnemonic,
  mnemonicToSeedSync,
  pbkdf2,
  pbkdf2Async,
  validateMnemonic,
  wordlist,
  wordlist10,
  wordlist2,
  wordlist3,
  wordlist4,
  wordlist5,
  wordlist6,
  wordlist7,
  wordlist8,
  wordlist9
} from "./chunk-HLGWWEAL.js";
import {
  ChainNotConfiguredError,
  ProviderNotFoundError,
  createConfig,
  createConnector,
  extractRpcUrls,
  injected,
  useAccount,
  useAccountEffect,
  useBalance,
  useConfig,
  useConnect,
  useDisconnect,
  useEnsAvatar,
  useEnsName,
  usePublicClient,
  useSignMessage,
  useSwitchChain
} from "./chunk-OFCEAFRQ.js";
import "./chunk-EDDRWZDP.js";
import {
  import_index
} from "./chunk-7CTHU3HB.js";
import "./chunk-LWLUVSGB.js";
import {
  require_react_dom
} from "./chunk-Z2GUPSCO.js";
import {
  AbiConstructor_exports,
  AbiFunction_exports,
  AbiItem_exports,
  AbiParameters_exports,
  Address_exports,
  Authorization_exports,
  Caches_exports,
  DataSizeTooSmallError,
  Hash_exports,
  InvalidVError,
  NotFoundError,
  PositionOutOfBoundsError,
  PublicKey_exports,
  Rlp_exports,
  Secp256k1_exports,
  Signature_exports,
  Solidity_exports,
  assert,
  create,
  decode,
  encode,
  extract,
  format,
  formatAbi,
  formatAbiItem,
  from as from3,
  from2 as from4,
  from3 as from5,
  from4 as from6,
  fromAbi,
  fromBytes as fromBytes2,
  fromHex as fromHex2,
  fromRpcList,
  fromTuple,
  fromTupleList,
  getPublicKey,
  getSignatureHash,
  http,
  isEqual as isEqual2,
  keccak256,
  parseAbi,
  sha256 as sha2562,
  toBytes as toBytes2,
  toHex2,
  toRpc as toRpc2,
  toRpcList,
  toTuple,
  toTupleList,
  vToYParity,
  validate as validate3,
  withRetry,
  withTimeout,
  yParityToV
} from "./chunk-WOEHP33K.js";
import "./chunk-JQPVWIPQ.js";
import {
  BaseError,
  BlockOverrides_exports,
  Bytes_exports,
  Errors_exports,
  Hex_exports,
  Json_exports,
  Withdrawal_exports,
  concat,
  concat2,
  from,
  from2,
  fromArray,
  fromBytes,
  fromHex,
  fromNumber,
  fromNumber2,
  fromRpc,
  fromString,
  fromString2,
  getUrl,
  isEqual,
  padLeft,
  prettyPrint,
  random,
  size,
  size2,
  slice,
  slice2,
  toBigInt,
  toBytes,
  toHex,
  toNumber2 as toNumber,
  toRpc,
  toString2 as toString,
  trimLeft2 as trimLeft,
  validate,
  validate2
} from "./chunk-FSHUW2ON.js";
import {
  ResourceUnavailableRpcError,
  SwitchChainError,
  UserRejectedRequestError,
  getAddress,
  hexToNumber,
  isAddress,
  numberToHex
} from "./chunk-W6WRK2EY.js";
import {
  Field,
  FpInvertBatch,
  FpLegendre,
  FpPow,
  FpSqrtEven,
  createHasher,
  getMinHashLength,
  isNegativeLE,
  isogenyMap,
  mapHashToField,
  mapToCurveSimpleSWU,
  mod,
  pippenger,
  pow2,
  validateBasic,
  wNAF,
  weierstrassPoints
} from "./chunk-YA7O72ML.js";
import {
  sha256,
  sha512
} from "./chunk-7JET5NM2.js";
import {
  aInRange,
  abool,
  bitGet,
  bitLen,
  bitMask,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes as concatBytes2,
  ensureBytes,
  equalBytes,
  memoized,
  notImplemented,
  numberToBytesBE,
  numberToBytesLE,
  validateObject
} from "./chunk-NSDO7JQ5.js";
import {
  anumber,
  asyncLoop,
  checkOpts,
  clean,
  concatBytes,
  randomBytes,
  rotl,
  swap32IfBE,
  u32,
  utf8ToBytes
} from "./chunk-CDJCEDMD.js";
import {
  useQuery
} from "./chunk-4SL7TTO6.js";
import {
  require_jsx_runtime
} from "./chunk-TLG7CTPL.js";
import {
  require_react
} from "./chunk-VT65UQWK.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-ONY6HBPH.js";

// node_modules/ua-parser-js/src/ua-parser.js
var require_ua_parser = __commonJS({
  "node_modules/ua-parser-js/src/ua-parser.js"(exports, module) {
    (function(window2, undefined2) {
      "use strict";
      var LIBVERSION = "1.0.41", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
      var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HONOR = "Honor", HUAWEI = "Huawei", LENOVO = "Lenovo", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", NVIDIA = "Nvidia", ONEPLUS = "OnePlus", OPERA = "Opera", OPPO = "OPPO", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS", SUFFIX_BROWSER = " Browser";
      var extend = function(regexes2, extensions) {
        var mergedRegexes = {};
        for (var i in regexes2) {
          if (extensions[i] && extensions[i].length % 2 === 0) {
            mergedRegexes[i] = extensions[i].concat(regexes2[i]);
          } else {
            mergedRegexes[i] = regexes2[i];
          }
        }
        return mergedRegexes;
      }, enumerize = function(arr) {
        var enums = {};
        for (var i = 0; i < arr.length; i++) {
          enums[arr[i].toUpperCase()] = arr[i];
        }
        return enums;
      }, has = function(str1, str2) {
        return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
      }, lowerize = function(str) {
        return str.toLowerCase();
      }, majorize = function(version5) {
        return typeof version5 === STR_TYPE ? version5.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined2;
      }, trim2 = function(str, len) {
        if (typeof str === STR_TYPE) {
          str = str.replace(/^\s\s*/, EMPTY);
          return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
      };
      var rgxMapper = function(ua2, arrays) {
        var i = 0, j, k, p, q, matches, match;
        while (i < arrays.length && !matches) {
          var regex = arrays[i], props = arrays[i + 1];
          j = k = 0;
          while (j < regex.length && !matches) {
            if (!regex[j]) {
              break;
            }
            matches = regex[j++].exec(ua2);
            if (!!matches) {
              for (p = 0; p < props.length; p++) {
                match = matches[++k];
                q = props[p];
                if (typeof q === OBJ_TYPE && q.length > 0) {
                  if (q.length === 2) {
                    if (typeof q[1] == FUNC_TYPE) {
                      this[q[0]] = q[1].call(this, match);
                    } else {
                      this[q[0]] = q[1];
                    }
                  } else if (q.length === 3) {
                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                      this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined2;
                    } else {
                      this[q[0]] = match ? match.replace(q[1], q[2]) : undefined2;
                    }
                  } else if (q.length === 4) {
                    this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined2;
                  }
                } else {
                  this[q] = match ? match : undefined2;
                }
              }
            }
          }
          i += 2;
        }
      }, strMapper = function(str, map) {
        for (var i in map) {
          if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
            for (var j = 0; j < map[i].length; j++) {
              if (has(map[i][j], str)) {
                return i === UNKNOWN ? undefined2 : i;
              }
            }
          } else if (has(map[i], str)) {
            return i === UNKNOWN ? undefined2 : i;
          }
        }
        return map.hasOwnProperty("*") ? map["*"] : str;
      };
      var oldSafariMap = {
        "1.0": "/8",
        "1.2": "/1",
        "1.3": "/3",
        "2.0": "/412",
        "2.0.2": "/416",
        "2.0.3": "/417",
        "2.0.4": "/419",
        "?": "/"
      }, windowsVersionMap = {
        "ME": "4.90",
        "NT 3.11": "NT3.51",
        "NT 4.0": "NT4.0",
        "2000": "NT 5.0",
        "XP": ["NT 5.1", "NT 5.2"],
        "Vista": "NT 6.0",
        "7": "NT 6.1",
        "8": "NT 6.2",
        "8.1": "NT 6.3",
        "10": ["NT 6.4", "NT 10.0"],
        "RT": "ARM"
      };
      var regexes = {
        browser: [
          [
            /\b(?:crmo|crios)\/([\w\.]+)/i
            // Chrome for Android/iOS
          ],
          [VERSION, [NAME, "Chrome"]],
          [
            /edg(?:e|ios|a)?\/([\w\.]+)/i
            // Microsoft Edge
          ],
          [VERSION, [NAME, "Edge"]],
          [
            // Presto based
            /(opera mini)\/([-\w\.]+)/i,
            // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
            // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
            // Opera
          ],
          [NAME, VERSION],
          [
            /opios[\/ ]+([\w\.]+)/i
            // Opera mini on iphone >= 8.0
          ],
          [VERSION, [NAME, OPERA + " Mini"]],
          [
            /\bop(?:rg)?x\/([\w\.]+)/i
            // Opera GX
          ],
          [VERSION, [NAME, OPERA + " GX"]],
          [
            /\bopr\/([\w\.]+)/i
            // Opera Webkit
          ],
          [VERSION, [NAME, OPERA]],
          [
            // Mixed
            /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
            // Baidu
          ],
          [VERSION, [NAME, "Baidu"]],
          [
            /\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i
            // Maxthon
          ],
          [VERSION, [NAME, "Maxthon"]],
          [
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
            // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
            // Trident based
            /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,
            // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
            /(?:ms|\()(ie) ([\w\.]+)/i,
            // Internet Explorer
            // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i,
            // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
            /(heytap|ovi|115)browser\/([\d\.]+)/i,
            // HeyTap/Ovi/115
            /(weibo)__([\d\.]+)/i
            // Weibo
          ],
          [NAME, VERSION],
          [
            /quark(?:pc)?\/([-\w\.]+)/i
            // Quark
          ],
          [VERSION, [NAME, "Quark"]],
          [
            /\bddg\/([\w\.]+)/i
            // DuckDuckGo
          ],
          [VERSION, [NAME, "DuckDuckGo"]],
          [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
            // UCBrowser
          ],
          [VERSION, [NAME, "UC" + BROWSER]],
          [
            /microm.+\bqbcore\/([\w\.]+)/i,
            // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i,
            /micromessenger\/([\w\.]+)/i
            // WeChat
          ],
          [VERSION, [NAME, "WeChat"]],
          [
            /konqueror\/([\w\.]+)/i
            // Konqueror
          ],
          [VERSION, [NAME, "Konqueror"]],
          [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
            // IE11
          ],
          [VERSION, [NAME, "IE"]],
          [
            /ya(?:search)?browser\/([\w\.]+)/i
            // Yandex
          ],
          [VERSION, [NAME, "Yandex"]],
          [
            /slbrowser\/([\w\.]+)/i
            // Smart Lenovo Browser
          ],
          [VERSION, [NAME, "Smart Lenovo " + BROWSER]],
          [
            /(avast|avg)\/([\w\.]+)/i
            // Avast/AVG Secure Browser
          ],
          [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION],
          [
            /\bfocus\/([\w\.]+)/i
            // Firefox Focus
          ],
          [VERSION, [NAME, FIREFOX + " Focus"]],
          [
            /\bopt\/([\w\.]+)/i
            // Opera Touch
          ],
          [VERSION, [NAME, OPERA + " Touch"]],
          [
            /coc_coc\w+\/([\w\.]+)/i
            // Coc Coc Browser
          ],
          [VERSION, [NAME, "Coc Coc"]],
          [
            /dolfin\/([\w\.]+)/i
            // Dolphin
          ],
          [VERSION, [NAME, "Dolphin"]],
          [
            /coast\/([\w\.]+)/i
            // Opera Coast
          ],
          [VERSION, [NAME, OPERA + " Coast"]],
          [
            /miuibrowser\/([\w\.]+)/i
            // MIUI Browser
          ],
          [VERSION, [NAME, "MIUI" + SUFFIX_BROWSER]],
          [
            /fxios\/([\w\.-]+)/i
            // Firefox for iOS
          ],
          [VERSION, [NAME, FIREFOX]],
          [
            /\bqihoobrowser\/?([\w\.]*)/i
            // 360
          ],
          [VERSION, [NAME, "360"]],
          [
            /\b(qq)\/([\w\.]+)/i
            // QQ
          ],
          [[NAME, /(.+)/, "$1Browser"], VERSION],
          [
            /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
          ],
          [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION],
          [
            // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
            /samsungbrowser\/([\w\.]+)/i
            // Samsung Internet
          ],
          [VERSION, [NAME, SAMSUNG + " Internet"]],
          [
            /metasr[\/ ]?([\d\.]+)/i
            // Sogou Explorer
          ],
          [VERSION, [NAME, "Sogou Explorer"]],
          [
            /(sogou)mo\w+\/([\d\.]+)/i
            // Sogou Mobile
          ],
          [[NAME, "Sogou Mobile"], VERSION],
          [
            /(electron)\/([\w\.]+) safari/i,
            // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
            // Tesla
            /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i
            // QQ/2345
          ],
          [NAME, VERSION],
          [
            /(lbbrowser|rekonq)/i,
            // LieBao Browser/Rekonq
            /\[(linkedin)app\]/i
            // LinkedIn App for iOS & Android
          ],
          [NAME],
          [
            /ome\/([\w\.]+) \w* ?(iron) saf/i,
            // Iron
            /ome\/([\w\.]+).+qihu (360)[es]e/i
            // 360
          ],
          [VERSION, NAME],
          [
            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
            // Facebook App for iOS & Android
          ],
          [[NAME, FACEBOOK], VERSION],
          [
            /(Klarna)\/([\w\.]+)/i,
            // Klarna Shopping Browser for iOS & Android
            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
            // Kakao App
            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
            // Naver InApp
            /(daum)apps[\/ ]([\w\.]+)/i,
            // Daum App
            /safari (line)\/([\w\.]+)/i,
            // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,
            // Line App for Android
            /(alipay)client\/([\w\.]+)/i,
            // Alipay
            /(twitter)(?:and| f.+e\/([\w\.]+))/i,
            // Twitter
            /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
            // Chromium/Instagram/Snapchat
          ],
          [NAME, VERSION],
          [
            /\bgsa\/([\w\.]+) .*safari\//i
            // Google Search Appliance on iOS
          ],
          [VERSION, [NAME, "GSA"]],
          [
            /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
            // TikTok
          ],
          [VERSION, [NAME, "TikTok"]],
          [
            /headlesschrome(?:\/([\w\.]+)| )/i
            // Chrome Headless
          ],
          [VERSION, [NAME, CHROME + " Headless"]],
          [
            / wv\).+(chrome)\/([\w\.]+)/i
            // Chrome WebView
          ],
          [[NAME, CHROME + " WebView"], VERSION],
          [
            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
            // Android Browser
          ],
          [VERSION, [NAME, "Android " + BROWSER]],
          [
            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
            // Chrome/OmniWeb/Arora/Tizen/Nokia
          ],
          [NAME, VERSION],
          [
            /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
            // Mobile Safari
          ],
          [VERSION, [NAME, "Mobile Safari"]],
          [
            /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
            // Safari & Safari Mobile
          ],
          [VERSION, NAME],
          [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
            // Safari < 3.0
          ],
          [NAME, [VERSION, strMapper, oldSafariMap]],
          [
            /(webkit|khtml)\/([\w\.]+)/i
          ],
          [NAME, VERSION],
          [
            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i
            // Netscape
          ],
          [[NAME, "Netscape"], VERSION],
          [
            /(wolvic|librewolf)\/([\w\.]+)/i
            // Wolvic/LibreWolf
          ],
          [NAME, VERSION],
          [
            /mobile vr; rv:([\w\.]+)\).+firefox/i
            // Firefox Reality
          ],
          [VERSION, [NAME, FIREFOX + " Reality"]],
          [
            /ekiohf.+(flow)\/([\w\.]+)/i,
            // Flow
            /(swiftfox)/i,
            // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
            // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
            // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,
            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
            // Mozilla
            // Other
            /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
            // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser/Ladybird
            /\b(links) \(([\w\.]+)/i
            // Links
          ],
          [NAME, [VERSION, /_/g, "."]],
          [
            /(cobalt)\/([\w\.]+)/i
            // Cobalt
          ],
          [NAME, [VERSION, /master.|lts./, ""]]
        ],
        cpu: [
          [
            /\b((amd|x|x86[-_]?|wow|win)64)\b/i
            // AMD64 (x64)
          ],
          [[ARCHITECTURE, "amd64"]],
          [
            /(ia32(?=;))/i,
            // IA32 (quicktime)
            /\b((i[346]|x)86)(pc)?\b/i
            // IA32 (x86)
          ],
          [[ARCHITECTURE, "ia32"]],
          [
            /\b(aarch64|arm(v?[89]e?l?|_?64))\b/i
            // ARM64
          ],
          [[ARCHITECTURE, "arm64"]],
          [
            /\b(arm(v[67])?ht?n?[fl]p?)\b/i
            // ARMHF
          ],
          [[ARCHITECTURE, "armhf"]],
          [
            // PocketPC mistakenly identified as PowerPC
            /( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i
          ],
          [[ARCHITECTURE, "arm"]],
          [
            /((ppc|powerpc)(64)?)( mac|;|\))/i
            // PowerPC
          ],
          [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
          [
            / sun4\w[;\)]/i
            // SPARC
          ],
          [[ARCHITECTURE, "sparc"]],
          [
            /\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i
            // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
          ],
          [[ARCHITECTURE, lowerize]]
        ],
        device: [
          [
            //////////////////////////
            // MOBILES & TABLETS
            /////////////////////////
            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
          [
            /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
            /samsung[- ]((?!sm-[lr])[-\w]+)/i,
            /sec-(sgh\w+)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
          [
            // Apple
            /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
            // iPod/iPhone
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
          [
            /\((ipad);[-\w\),; ]+apple/i,
            // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
          [
            /(macintosh);/i
          ],
          [MODEL, [VENDOR, APPLE]],
          [
            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
          [
            // Honor
            /\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i
          ],
          [MODEL, [VENDOR, HONOR], [TYPE, TABLET]],
          [
            /honor([-\w ]+)[;\)]/i
          ],
          [MODEL, [VENDOR, HONOR], [TYPE, MOBILE]],
          [
            // Huawei
            /\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
          [
            /(?:huawei)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
          [
            // Xiaomi
            /oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i,
            /\b((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i
            // Mi Pad tablets
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
          [
            /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
            // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,
            // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
            // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
            // Xiaomi Redmi
            /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
            // Xiaomi Redmi 'numeric' models
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i,
            // Xiaomi Mi
            / ([\w ]+) miui\/v?\d/i
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
          [
            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
          ],
          [MODEL, [VENDOR, OPPO], [TYPE, MOBILE]],
          [
            /\b(opd2(\d{3}a?))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, strMapper, { "OnePlus": ["304", "403", "203"], "*": OPPO }], [TYPE, TABLET]],
          [
            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
          ],
          [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
          [
            // Realme
            /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
          ],
          [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
          [
            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto(?! 360)[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
          [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
          [
            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, TABLET]],
          [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv|watch)\w+)/i,
            /\blg-?([\d\w]+) bui/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
          [
            // Lenovo
            /(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i,
            /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i
          ],
          [MODEL, [VENDOR, LENOVO], [TYPE, TABLET]],
          [
            // Nokia
            /(nokia) (t[12][01])/i
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i,
            /nokia[-_ ]?(([-\w\. ]*))/i
          ],
          [[MODEL, /_/g, " "], [TYPE, MOBILE], [VENDOR, "Nokia"]],
          [
            // Google
            /(pixel (c|tablet))\b/i
            // Google Pixel C/Tablet
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
          [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
            // Google Pixel
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
          [
            // Sony
            /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
          ],
          [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
          [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
          ],
          [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
          [
            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
          ],
          [MODEL, [VENDOR, ONEPLUS], [TYPE, MOBILE]],
          [
            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
            // Kindle Fire without Silk / Echo Show
            /(kf[a-z]+)( bui|\)).+silk\//i
            // Kindle Fire HD
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
          [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
            // Fire Phone
          ],
          [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
          [
            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i
            // BlackBerry PlayBook
          ],
          [MODEL, VENDOR, [TYPE, TABLET]],
          [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i
            // BlackBerry 10
          ],
          [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
          [
            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
          [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
          [
            // HTC
            /(nexus 9)/i
            // HTC Nexus 9
          ],
          [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
          [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
            // HTC
            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
            // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
          ],
          [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
          [
            // TCL
            /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i
          ],
          [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]],
          [
            // itel
            /(itel) ((\w+))/i
          ],
          [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { "tablet": ["p10001l", "w7001"], "*": "mobile" }]],
          [
            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
          ],
          [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
          [
            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
          ],
          [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
          [
            // Ulefone
            /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
          [
            // Energizer
            /; (energy ?\w+)(?: bui|\))/i,
            /; energizer ([\w ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]],
          [
            // Cat
            /; cat (b35);/i,
            /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]],
          [
            // Smartfren
            /((?:new )?andromax[\w- ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]],
          [
            // Nothing
            /droid.+; (a(?:015|06[35]|142p?))/i
          ],
          [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]],
          [
            // Archos
            /; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i,
            /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i
          ],
          [MODEL, [VENDOR, "Archos"], [TYPE, TABLET]],
          [
            /archos ([\w ]+)( b|\))/i,
            /; (ac[3-6]\d\w{2,8})( b|\))/i
          ],
          [MODEL, [VENDOR, "Archos"], [TYPE, MOBILE]],
          [
            // MIXED
            /(imo) (tab \w+)/i,
            // IMO
            /(infinix) (x1101b?)/i
            // Infinix XPad
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
            // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Infinix/Tecno/Micromax/Advan
            /; (hmd|imo) ([\w ]+?)(?: bui|\))/i,
            // HMD/IMO
            /(hp) ([\w ]+\w)/i,
            // HP iPAQ
            /(microsoft); (lumia[\w ]+)/i,
            // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i,
            // Lenovo
            /(oppo) ?([\w ]+) bui/i
            // OPPO
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kobo)\s(ereader|touch)/i,
            // Kobo
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,
            // HP TouchPad
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(nook)[\w ]+build\/(\w+)/i,
            // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,
            // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
            // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,
            // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,
            // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i
            // Vodafone
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(surface duo)/i
            // Surface Duo
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
          [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i
            // Fairphone
          ],
          [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
          [
            /(u304aa)/i
            // AT&T
          ],
          [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
          [
            /\bsie-(\w*)/i
            // Siemens
          ],
          [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
          [
            /\b(rct\w+) b/i
            // RCA Tablets
          ],
          [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
          [
            /\b(venue[\d ]{2,7}) b/i
            // Dell Venue Tablets
          ],
          [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
          [
            /\b(q(?:mv|ta)\w+) b/i
            // Verizon Tablet
          ],
          [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
          [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
            // Barnes & Noble Tablet
          ],
          [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
          [
            /\b(tm\d{3}\w+) b/i
          ],
          [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
          [
            /\b(k88) b/i
            // ZTE K Series Tablet
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
          [
            /\b(nx\d{3}j) b/i
            // ZTE Nubia
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
          [
            /\b(gen\d{3}) b.+49h/i
            // Swiss GEN Mobile
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
          [
            /\b(zur\d{3}) b/i
            // Swiss ZUR Tablet
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
          [
            /\b((zeki)?tb.*\b) b/i
            // Zeki Tablets
          ],
          [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
          [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i
            // Dragon Touch Tablet
          ],
          [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
          [
            /\b(ns-?\w{0,9}) b/i
            // Insignia Tablets
          ],
          [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
          [
            /\b((nxa|next)-?\w{0,9}) b/i
            // NextBook Tablets
          ],
          [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
          [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
            // Voice Xtreme Phones
          ],
          [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
          [
            /\b(lvtel\-)?(v1[12]) b/i
            // LvTel Phones
          ],
          [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
          [
            /\b(ph-1) /i
            // Essential PH-1
          ],
          [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
          [
            /\b(v(100md|700na|7011|917g).*\b) b/i
            // Envizen Tablets
          ],
          [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
          [
            /\b(trio[-\w\. ]+) b/i
            // MachSpeed Tablets
          ],
          [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
          [
            /\btu_(1491) b/i
            // Rotor Tablets
          ],
          [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
          [
            /((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i
            // Nvidia Tablets
          ],
          [MODEL, [VENDOR, NVIDIA], [TYPE, TABLET]],
          [
            /(sprint) (\w+)/i
            // Sprint Phones
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kin\.[onetw]{3})/i
            // Microsoft Kin
          ],
          [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
          [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
            // Zebra
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
          [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
          [
            ///////////////////
            // SMARTTVS
            ///////////////////
            /smart-tv.+(samsung)/i
            // Samsung
          ],
          [VENDOR, [TYPE, SMARTTV]],
          [
            /hbbtv.+maple;(\d+)/i
          ],
          [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
          [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
            // LG SmartTV
          ],
          [[VENDOR, LG], [TYPE, SMARTTV]],
          [
            /(apple) ?tv/i
            // Apple TV
          ],
          [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
          [
            /crkey/i
            // Google Chromecast
          ],
          [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /droid.+aft(\w+)( bui|\))/i
            // Fire TV
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
          [
            /(shield \w+ tv)/i
            // Nvidia Shield TV
          ],
          [MODEL, [VENDOR, NVIDIA], [TYPE, SMARTTV]],
          [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i
            // Sharp
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
          [
            /(bravia[\w ]+)( bui|\))/i
            // Sony
          ],
          [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
          [
            /(mi(tv|box)-?\w+) bui/i
            // Xiaomi
          ],
          [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
          [
            /Hbbtv.*(technisat) (.*);/i
            // TechniSAT
          ],
          [VENDOR, MODEL, [TYPE, SMARTTV]],
          [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
            // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
            // HbbTV devices
          ],
          [[VENDOR, trim2], [MODEL, trim2], [TYPE, SMARTTV]],
          [
            // SmartTV from Unidentified Vendors
            /droid.+; ([\w- ]+) (?:android tv|smart[- ]?tv)/i
          ],
          [MODEL, [TYPE, SMARTTV]],
          [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
          ],
          [[TYPE, SMARTTV]],
          [
            ///////////////////
            // CONSOLES
            ///////////////////
            /(ouya)/i,
            // Ouya
            /(nintendo) ([wids3utch]+)/i
            // Nintendo
          ],
          [VENDOR, MODEL, [TYPE, CONSOLE]],
          [
            /droid.+; (shield)( bui|\))/i
            // Nvidia Portable
          ],
          [MODEL, [VENDOR, NVIDIA], [TYPE, CONSOLE]],
          [
            /(playstation \w+)/i
            // Playstation
          ],
          [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
          [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i
            // Microsoft Xbox
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
          [
            ///////////////////
            // WEARABLES
            ///////////////////
            /\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i
            // Samsung Galaxy Watch
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]],
          [
            /((pebble))app/i,
            // Pebble
            /(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i
            // Asus ZenWatch / LG Watch / Pixel Watch
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /(ow(?:19|20)?we?[1-3]{1,3})/i
            // Oppo Watch
          ],
          [MODEL, [VENDOR, OPPO], [TYPE, WEARABLE]],
          [
            /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
            // Apple Watch
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
          [
            /(opwwe\d{3})/i
            // OnePlus Watch
          ],
          [MODEL, [VENDOR, ONEPLUS], [TYPE, WEARABLE]],
          [
            /(moto 360)/i
            // Motorola 360
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, WEARABLE]],
          [
            /(smartwatch 3)/i
            // Sony SmartWatch
          ],
          [MODEL, [VENDOR, SONY], [TYPE, WEARABLE]],
          [
            /(g watch r)/i
            // LG G Watch R
          ],
          [MODEL, [VENDOR, LG], [TYPE, WEARABLE]],
          [
            /droid.+; (wt63?0{2,3})\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
          [
            ///////////////////
            // XR
            ///////////////////
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
          [
            /(pico) (4|neo3(?: link|pro)?)/i
            // Pico
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /; (quest( \d| pro)?)/i
            // Oculus Quest
          ],
          [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
          [
            ///////////////////
            // EMBEDDED
            ///////////////////
            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
            // Tesla
          ],
          [VENDOR, [TYPE, EMBEDDED]],
          [
            /(aeobc)\b/i
            // Echo Dot
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
          [
            /(homepod).+mac os/i
            // Apple HomePod
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, EMBEDDED]],
          [
            /windows iot/i
          ],
          [[TYPE, EMBEDDED]],
          [
            ////////////////////
            // MIXED (GENERIC)
            ///////////////////
            /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
            // Android Phones from Unidentified Vendors
          ],
          [MODEL, [TYPE, MOBILE]],
          [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
            // Android Tablets from Unidentified Vendors
          ],
          [MODEL, [TYPE, TABLET]],
          [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
            // Unidentifiable Tablet
          ],
          [[TYPE, TABLET]],
          [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
            // Unidentifiable Mobile
          ],
          [[TYPE, MOBILE]],
          [
            /droid .+?; ([\w\. -]+)( bui|\))/i
            // Generic Android Device
          ],
          [MODEL, [VENDOR, "Generic"]]
        ],
        engine: [
          [
            /windows.+ edge\/([\w\.]+)/i
            // EdgeHTML
          ],
          [VERSION, [NAME, EDGE + "HTML"]],
          [
            /(arkweb)\/([\w\.]+)/i
            // ArkWeb
          ],
          [NAME, VERSION],
          [
            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
            // Blink
          ],
          [VERSION, [NAME, "Blink"]],
          [
            /(presto)\/([\w\.]+)/i,
            // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,
            // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
            /ekioh(flow)\/([\w\.]+)/i,
            // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
            // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i,
            // iCab
            /\b(libweb)/i
            // LibWeb
          ],
          [NAME, VERSION],
          [
            /ladybird\//i
          ],
          [[NAME, "LibWeb"]],
          [
            /rv\:([\w\.]{1,9})\b.+(gecko)/i
            // Gecko
          ],
          [VERSION, NAME]
        ],
        os: [
          [
            // Windows
            /microsoft (windows) (vista|xp)/i
            // Windows (iTunes)
          ],
          [NAME, VERSION],
          [
            /(windows (?:phone(?: os)?|mobile|iot))[\/ ]?([\d\.\w ]*)/i
            // Windows Phone
          ],
          [NAME, [VERSION, strMapper, windowsVersionMap]],
          [
            /windows nt 6\.2; (arm)/i,
            // Windows RT
            /windows[\/ ]([ntce\d\. ]+\w)(?!.+xbox)/i,
            /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
          ],
          [[VERSION, strMapper, windowsVersionMap], [NAME, "Windows"]],
          [
            // iOS/macOS
            /[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i,
            // iOS
            /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
            /cfnetwork\/.+darwin/i
          ],
          [[VERSION, /_/g, "."], [NAME, "iOS"]],
          [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i
            // Mac OS
          ],
          [[NAME, MAC_OS], [VERSION, /_/g, "."]],
          [
            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
            // Android-x86/HarmonyOS
          ],
          [VERSION, NAME],
          [
            /(ubuntu) ([\w\.]+) like android/i
            // Ubuntu Touch
          ],
          [[NAME, /(.+)/, "$1 Touch"], VERSION],
          [
            // Android/Blackberry/WebOS/QNX/Bada/RIM/KaiOS/Maemo/MeeGo/S40/Sailfish OS/OpenHarmony/Tizen
            /(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen|webos)\w*[-\/; ]?([\d\.]*)/i
          ],
          [NAME, VERSION],
          [
            /\(bb(10);/i
            // BlackBerry 10
          ],
          [VERSION, [NAME, BLACKBERRY]],
          [
            /(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i
            // Symbian
          ],
          [VERSION, [NAME, "Symbian"]],
          [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
            // Firefox OS
          ],
          [VERSION, [NAME, FIREFOX + " OS"]],
          [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
            // WebOS
          ],
          [VERSION, [NAME, "webOS"]],
          [
            /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
            // watchOS
          ],
          [VERSION, [NAME, "watchOS"]],
          [
            // Google Chromecast
            /crkey\/([\d\.]+)/i
            // Google Chromecast
          ],
          [VERSION, [NAME, CHROME + "cast"]],
          [
            /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
            // Chromium OS
          ],
          [[NAME, CHROMIUM_OS], VERSION],
          [
            // Smart TVs
            /panasonic;(viera)/i,
            // Panasonic Viera
            /(netrange)mmh/i,
            // Netrange
            /(nettv)\/(\d+\.[\w\.]+)/i,
            // NetTV
            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,
            // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,
            // Microsoft Xbox (360, One, X, S, Series X, Series S)
            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,
            // Mint
            /(mageia|vectorlinux)[; ]/i,
            // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
            // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux)(?: arm\w*| x86\w*| ?)([\w\.]*)/i,
            // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,
            // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
            // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i
            // Haiku
          ],
          [NAME, VERSION],
          [
            /(sunos) ?([\w\.\d]*)/i
            // Solaris
          ],
          [[NAME, "Solaris"], VERSION],
          [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
            // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
            // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
            /(unix) ?([\w\.]*)/i
            // UNIX
          ],
          [NAME, VERSION]
        ]
      };
      var UAParser2 = function(ua2, extensions) {
        if (typeof ua2 === OBJ_TYPE) {
          extensions = ua2;
          ua2 = undefined2;
        }
        if (!(this instanceof UAParser2)) {
          return new UAParser2(ua2, extensions).getResult();
        }
        var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined2;
        var _ua = ua2 || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
        var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined2;
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        var _isSelfNav = _navigator && _navigator.userAgent == _ua;
        this.getBrowser = function() {
          var _browser = {};
          _browser[NAME] = undefined2;
          _browser[VERSION] = undefined2;
          rgxMapper.call(_browser, _ua, _rgxmap.browser);
          _browser[MAJOR] = majorize(_browser[VERSION]);
          if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
            _browser[NAME] = "Brave";
          }
          return _browser;
        };
        this.getCPU = function() {
          var _cpu = {};
          _cpu[ARCHITECTURE] = undefined2;
          rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
          return _cpu;
        };
        this.getDevice = function() {
          var _device = {};
          _device[VENDOR] = undefined2;
          _device[MODEL] = undefined2;
          _device[TYPE] = undefined2;
          rgxMapper.call(_device, _ua, _rgxmap.device);
          if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
            _device[TYPE] = MOBILE;
          }
          if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
            _device[MODEL] = "iPad";
            _device[TYPE] = TABLET;
          }
          return _device;
        };
        this.getEngine = function() {
          var _engine = {};
          _engine[NAME] = undefined2;
          _engine[VERSION] = undefined2;
          rgxMapper.call(_engine, _ua, _rgxmap.engine);
          return _engine;
        };
        this.getOS = function() {
          var _os = {};
          _os[NAME] = undefined2;
          _os[VERSION] = undefined2;
          rgxMapper.call(_os, _ua, _rgxmap.os);
          if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != "Unknown") {
            _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
          }
          return _os;
        };
        this.getResult = function() {
          return {
            ua: this.getUA(),
            browser: this.getBrowser(),
            engine: this.getEngine(),
            os: this.getOS(),
            device: this.getDevice(),
            cpu: this.getCPU()
          };
        };
        this.getUA = function() {
          return _ua;
        };
        this.setUA = function(ua3) {
          _ua = typeof ua3 === STR_TYPE && ua3.length > UA_MAX_LENGTH ? trim2(ua3, UA_MAX_LENGTH) : ua3;
          return this;
        };
        this.setUA(_ua);
        return this;
      };
      UAParser2.VERSION = LIBVERSION;
      UAParser2.BROWSER = enumerize([NAME, VERSION, MAJOR]);
      UAParser2.CPU = enumerize([ARCHITECTURE]);
      UAParser2.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
      UAParser2.ENGINE = UAParser2.OS = enumerize([NAME, VERSION]);
      if (typeof exports !== UNDEF_TYPE) {
        if (typeof module !== UNDEF_TYPE && module.exports) {
          exports = module.exports = UAParser2;
        }
        exports.UAParser = UAParser2;
      } else {
        if (typeof define === FUNC_TYPE && define.amd) {
          define(function() {
            return UAParser2;
          });
        } else if (typeof window2 !== UNDEF_TYPE) {
          window2.UAParser = UAParser2;
        }
      }
      var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
      if ($ && !$.ua) {
        var parser = new UAParser2();
        $.ua = parser.getResult();
        $.ua.get = function() {
          return parser.getUA();
        };
        $.ua.set = function(ua2) {
          parser.setUA(ua2);
          var result = parser.getResult();
          for (var prop in result) {
            $.ua[prop] = result[prop];
          }
        };
      }
    })(typeof window === "object" ? window : exports);
  }
});

// node_modules/@rainbow-me/rainbowkit/dist/chunk-DQLAW7KN.js
var systemFontStack = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"';
var fontStacks = {
  rounded: `SFRounded, ui-rounded, "SF Pro Rounded", ${systemFontStack}`,
  system: systemFontStack
};
var radiusScales = {
  large: {
    actionButton: "9999px",
    connectButton: "12px",
    modal: "24px",
    modalMobile: "28px"
  },
  medium: {
    actionButton: "10px",
    connectButton: "8px",
    modal: "16px",
    modalMobile: "18px"
  },
  none: {
    actionButton: "0px",
    connectButton: "0px",
    modal: "0px",
    modalMobile: "0px"
  },
  small: {
    actionButton: "4px",
    connectButton: "4px",
    modal: "8px",
    modalMobile: "8px"
  }
};
var blurs = {
  large: {
    modalOverlay: "blur(20px)"
  },
  none: {
    modalOverlay: "blur(0px)"
  },
  small: {
    modalOverlay: "blur(4px)"
  }
};
var baseTheme = ({
  borderRadius = "large",
  fontStack = "rounded",
  overlayBlur = "none"
}) => ({
  blurs: {
    modalOverlay: blurs[overlayBlur].modalOverlay
  },
  fonts: {
    body: fontStacks[fontStack]
  },
  radii: {
    actionButton: radiusScales[borderRadius].actionButton,
    connectButton: radiusScales[borderRadius].connectButton,
    menuButton: radiusScales[borderRadius].connectButton,
    modal: radiusScales[borderRadius].modal,
    modalMobile: radiusScales[borderRadius].modalMobile
  }
});

// node_modules/@rainbow-me/rainbowkit/dist/chunk-RZWDCITT.js
var darkGrey = "#1A1B1F";
var accentColors = {
  blue: { accentColor: "#3898FF", accentColorForeground: "#FFF" },
  green: { accentColor: "#4BD166", accentColorForeground: darkGrey },
  orange: { accentColor: "#FF983D", accentColorForeground: darkGrey },
  pink: { accentColor: "#FF7AB8", accentColorForeground: darkGrey },
  purple: { accentColor: "#7A70FF", accentColorForeground: "#FFF" },
  red: { accentColor: "#FF6257", accentColorForeground: "#FFF" }
};
var defaultAccentColor = accentColors.blue;
var darkTheme = ({
  accentColor = defaultAccentColor.accentColor,
  accentColorForeground = defaultAccentColor.accentColorForeground,
  ...baseThemeOptions
} = {}) => ({
  ...baseTheme(baseThemeOptions),
  colors: {
    accentColor,
    accentColorForeground,
    actionButtonBorder: "rgba(255, 255, 255, 0.04)",
    actionButtonBorderMobile: "rgba(255, 255, 255, 0.08)",
    actionButtonSecondaryBackground: "rgba(255, 255, 255, 0.08)",
    closeButton: "rgba(224, 232, 255, 0.6)",
    closeButtonBackground: "rgba(255, 255, 255, 0.08)",
    connectButtonBackground: darkGrey,
    connectButtonBackgroundError: "#FF494A",
    connectButtonInnerBackground: "linear-gradient(0deg, rgba(255, 255, 255, 0.075), rgba(255, 255, 255, 0.15))",
    connectButtonText: "#FFF",
    connectButtonTextError: "#FFF",
    connectionIndicator: "#30E000",
    downloadBottomCardBackground: "linear-gradient(126deg, rgba(0, 0, 0, 0) 9.49%, rgba(120, 120, 120, 0.2) 71.04%), #1A1B1F",
    downloadTopCardBackground: "linear-gradient(126deg, rgba(120, 120, 120, 0.2) 9.49%, rgba(0, 0, 0, 0) 71.04%), #1A1B1F",
    error: "#FF494A",
    generalBorder: "rgba(255, 255, 255, 0.08)",
    generalBorderDim: "rgba(255, 255, 255, 0.04)",
    menuItemBackground: "rgba(224, 232, 255, 0.1)",
    modalBackdrop: "rgba(0, 0, 0, 0.5)",
    modalBackground: "#1A1B1F",
    modalBorder: "rgba(255, 255, 255, 0.08)",
    modalText: "#FFF",
    modalTextDim: "rgba(224, 232, 255, 0.3)",
    modalTextSecondary: "rgba(255, 255, 255, 0.6)",
    profileAction: "rgba(224, 232, 255, 0.1)",
    profileActionHover: "rgba(224, 232, 255, 0.2)",
    profileForeground: "rgba(224, 232, 255, 0.05)",
    selectedOptionBorder: "rgba(224, 232, 255, 0.1)",
    standby: "#FFD641"
  },
  shadows: {
    connectButton: "0px 4px 12px rgba(0, 0, 0, 0.1)",
    dialog: "0px 8px 32px rgba(0, 0, 0, 0.32)",
    profileDetailsAction: "0px 2px 6px rgba(37, 41, 46, 0.04)",
    selectedOption: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    selectedWallet: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    walletLogo: "0px 2px 16px rgba(0, 0, 0, 0.16)"
  }
});
darkTheme.accentColors = accentColors;

// node_modules/@rainbow-me/rainbowkit/dist/chunk-7ZP3ENJ2.js
var accentColors2 = {
  blue: { accentColor: "#3898FF", accentColorForeground: "#FFF" },
  green: { accentColor: "#4BD166", accentColorForeground: "#000" },
  orange: { accentColor: "#FF983D", accentColorForeground: "#000" },
  pink: { accentColor: "#FF7AB8", accentColorForeground: "#000" },
  purple: { accentColor: "#7A70FF", accentColorForeground: "#FFF" },
  red: { accentColor: "#FF6257", accentColorForeground: "#FFF" }
};
var defaultAccentColor2 = accentColors2.blue;
var midnightTheme = ({
  accentColor = defaultAccentColor2.accentColor,
  accentColorForeground = defaultAccentColor2.accentColorForeground,
  ...baseThemeOptions
} = {}) => ({
  ...baseTheme(baseThemeOptions),
  colors: {
    accentColor,
    accentColorForeground,
    actionButtonBorder: "rgba(255, 255, 255, 0.04)",
    actionButtonBorderMobile: "rgba(255, 255, 255, 0.1)",
    actionButtonSecondaryBackground: "rgba(255, 255, 255, 0.08)",
    closeButton: "rgba(255, 255, 255, 0.7)",
    closeButtonBackground: "rgba(255, 255, 255, 0.08)",
    connectButtonBackground: "#000",
    connectButtonBackgroundError: "#FF494A",
    connectButtonInnerBackground: "linear-gradient(0deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.12))",
    connectButtonText: "#FFF",
    connectButtonTextError: "#FFF",
    connectionIndicator: "#30E000",
    downloadBottomCardBackground: "linear-gradient(126deg, rgba(0, 0, 0, 0) 9.49%, rgba(120, 120, 120, 0.1) 71.04%), #050505",
    downloadTopCardBackground: "linear-gradient(126deg, rgba(120, 120, 120, 0.1) 9.49%, rgba(0, 0, 0, 0) 71.04%), #050505",
    error: "#FF494A",
    generalBorder: "rgba(255, 255, 255, 0.08)",
    generalBorderDim: "rgba(255, 255, 255, 0.04)",
    menuItemBackground: "rgba(255, 255, 255, 0.08)",
    modalBackdrop: "rgba(0, 0, 0, 0.7)",
    modalBackground: "#000",
    modalBorder: "rgba(255, 255, 255, 0.08)",
    modalText: "#FFF",
    modalTextDim: "rgba(255, 255, 255, 0.2)",
    modalTextSecondary: "rgba(255, 255, 255, 0.6)",
    profileAction: "rgba(255, 255, 255, 0.1)",
    profileActionHover: "rgba(255, 255, 255, 0.2)",
    profileForeground: "rgba(255, 255, 255, 0.06)",
    selectedOptionBorder: "rgba(224, 232, 255, 0.1)",
    standby: "#FFD641"
  },
  shadows: {
    connectButton: "0px 4px 12px rgba(0, 0, 0, 0.1)",
    dialog: "0px 8px 32px rgba(0, 0, 0, 0.32)",
    profileDetailsAction: "0px 2px 6px rgba(37, 41, 46, 0.04)",
    selectedOption: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    selectedWallet: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    walletLogo: "0px 2px 16px rgba(0, 0, 0, 0.16)"
  }
});
midnightTheme.accentColors = accentColors2;

// node_modules/@rainbow-me/rainbowkit/dist/chunk-72HZGUJA.js
var accentColors3 = {
  blue: { accentColor: "#0E76FD", accentColorForeground: "#FFF" },
  green: { accentColor: "#1DB847", accentColorForeground: "#FFF" },
  orange: { accentColor: "#FF801F", accentColorForeground: "#FFF" },
  pink: { accentColor: "#FF5CA0", accentColorForeground: "#FFF" },
  purple: { accentColor: "#5F5AFA", accentColorForeground: "#FFF" },
  red: { accentColor: "#FA423C", accentColorForeground: "#FFF" }
};
var defaultAccentColor3 = accentColors3.blue;
var lightTheme = ({
  accentColor = defaultAccentColor3.accentColor,
  accentColorForeground = defaultAccentColor3.accentColorForeground,
  ...baseThemeOptions
} = {}) => ({
  ...baseTheme(baseThemeOptions),
  colors: {
    accentColor,
    accentColorForeground,
    actionButtonBorder: "rgba(0, 0, 0, 0.04)",
    actionButtonBorderMobile: "rgba(0, 0, 0, 0.06)",
    actionButtonSecondaryBackground: "rgba(0, 0, 0, 0.06)",
    closeButton: "rgba(60, 66, 66, 0.8)",
    closeButtonBackground: "rgba(0, 0, 0, 0.06)",
    connectButtonBackground: "#FFF",
    connectButtonBackgroundError: "#FF494A",
    connectButtonInnerBackground: "linear-gradient(0deg, rgba(0, 0, 0, 0.03), rgba(0, 0, 0, 0.06))",
    connectButtonText: "#25292E",
    connectButtonTextError: "#FFF",
    connectionIndicator: "#30E000",
    downloadBottomCardBackground: "linear-gradient(126deg, rgba(255, 255, 255, 0) 9.49%, rgba(171, 171, 171, 0.04) 71.04%), #FFFFFF",
    downloadTopCardBackground: "linear-gradient(126deg, rgba(171, 171, 171, 0.2) 9.49%, rgba(255, 255, 255, 0) 71.04%), #FFFFFF",
    error: "#FF494A",
    generalBorder: "rgba(0, 0, 0, 0.06)",
    generalBorderDim: "rgba(0, 0, 0, 0.03)",
    menuItemBackground: "rgba(60, 66, 66, 0.1)",
    modalBackdrop: "rgba(0, 0, 0, 0.3)",
    modalBackground: "#FFF",
    modalBorder: "transparent",
    modalText: "#25292E",
    modalTextDim: "rgba(60, 66, 66, 0.3)",
    modalTextSecondary: "rgba(60, 66, 66, 0.6)",
    profileAction: "#FFF",
    profileActionHover: "rgba(255, 255, 255, 0.5)",
    profileForeground: "rgba(60, 66, 66, 0.06)",
    selectedOptionBorder: "rgba(60, 66, 66, 0.1)",
    standby: "#FFD641"
  },
  shadows: {
    connectButton: "0px 4px 12px rgba(0, 0, 0, 0.1)",
    dialog: "0px 8px 32px rgba(0, 0, 0, 0.32)",
    profileDetailsAction: "0px 2px 6px rgba(37, 41, 46, 0.04)",
    selectedOption: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    selectedWallet: "0px 2px 6px rgba(0, 0, 0, 0.12)",
    walletLogo: "0px 2px 16px rgba(0, 0, 0, 0.16)"
  }
});
lightTheme.accentColors = accentColors3;

// node_modules/@rainbow-me/rainbowkit/dist/index.js
var import_react4 = __toESM(require_react());

// node_modules/@vanilla-extract/css/functionSerializer/dist/vanilla-extract-css-functionSerializer.browser.esm.js
function addFunctionSerializer(target, recipe) {
  Object.defineProperty(target, "__recipe__", {
    value: recipe,
    writable: false
  });
  return target;
}

// node_modules/@vanilla-extract/css/recipe/dist/vanilla-extract-css-recipe.browser.esm.js
var addRecipe = addFunctionSerializer;

// node_modules/@vanilla-extract/sprinkles/createUtils/dist/vanilla-extract-sprinkles-createUtils.esm.js
function createNormalizeValueFn(properties) {
  var {
    conditions
  } = properties;
  if (!conditions) {
    throw new Error("Styles have no conditions");
  }
  function normalizeValue(value) {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      if (!conditions.defaultCondition) {
        throw new Error("No default condition");
      }
      return {
        [conditions.defaultCondition]: value
      };
    }
    if (Array.isArray(value)) {
      if (!("responsiveArray" in conditions)) {
        throw new Error("Responsive arrays are not supported");
      }
      var returnValue = {};
      for (var index2 in conditions.responsiveArray) {
        if (value[index2] != null) {
          returnValue[conditions.responsiveArray[index2]] = value[index2];
        }
      }
      return returnValue;
    }
    return value;
  }
  return addRecipe(normalizeValue, {
    importPath: "@vanilla-extract/sprinkles/createUtils",
    importName: "createNormalizeValueFn",
    args: [{
      conditions: properties.conditions
    }]
  });
}
function createMapValueFn(properties) {
  var {
    conditions
  } = properties;
  if (!conditions) {
    throw new Error("Styles have no conditions");
  }
  var normalizeValue = createNormalizeValueFn(properties);
  function mapValue(value, mapFn) {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      if (!conditions.defaultCondition) {
        throw new Error("No default condition");
      }
      return mapFn(value, conditions.defaultCondition);
    }
    var normalizedObject = Array.isArray(value) ? normalizeValue(value) : value;
    var mappedObject = {};
    for (var _key in normalizedObject) {
      if (normalizedObject[_key] != null) {
        mappedObject[_key] = mapFn(normalizedObject[_key], _key);
      }
    }
    return mappedObject;
  }
  return addRecipe(mapValue, {
    importPath: "@vanilla-extract/sprinkles/createUtils",
    importName: "createMapValueFn",
    args: [{
      conditions: properties.conditions
    }]
  });
}

// node_modules/@vanilla-extract/sprinkles/dist/createSprinkles-74286718.esm.js
function toPrimitive(t, r2) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var createSprinkles = (composeStyles2) => function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var sprinklesStyles = Object.assign({}, ...args.map((a) => a.styles));
  var sprinklesKeys = Object.keys(sprinklesStyles);
  var shorthandNames = sprinklesKeys.filter((property) => "mappings" in sprinklesStyles[property]);
  var sprinklesFn = (props) => {
    var classNames = [];
    var shorthands = {};
    var nonShorthands = _objectSpread2({}, props);
    var hasShorthands = false;
    for (var shorthand of shorthandNames) {
      var value = props[shorthand];
      if (value != null) {
        var sprinkle = sprinklesStyles[shorthand];
        hasShorthands = true;
        for (var propMapping of sprinkle.mappings) {
          shorthands[propMapping] = value;
          if (nonShorthands[propMapping] == null) {
            delete nonShorthands[propMapping];
          }
        }
      }
    }
    var finalProps = hasShorthands ? _objectSpread2(_objectSpread2({}, shorthands), nonShorthands) : props;
    var _loop = function _loop2() {
      var propValue = finalProps[prop];
      var sprinkle2 = sprinklesStyles[prop];
      try {
        if (sprinkle2.mappings) {
          return 1;
        }
        if (typeof propValue === "string" || typeof propValue === "number") {
          if (true) {
            if (!sprinkle2.values[propValue].defaultClass) {
              throw new Error();
            }
          }
          classNames.push(sprinkle2.values[propValue].defaultClass);
        } else if (Array.isArray(propValue)) {
          for (var responsiveIndex = 0; responsiveIndex < propValue.length; responsiveIndex++) {
            var responsiveValue = propValue[responsiveIndex];
            if (responsiveValue != null) {
              var conditionName = sprinkle2.responsiveArray[responsiveIndex];
              if (true) {
                if (!sprinkle2.values[responsiveValue].conditions[conditionName]) {
                  throw new Error();
                }
              }
              classNames.push(sprinkle2.values[responsiveValue].conditions[conditionName]);
            }
          }
        } else {
          for (var _conditionName in propValue) {
            var _value = propValue[_conditionName];
            if (_value != null) {
              if (true) {
                if (!sprinkle2.values[_value].conditions[_conditionName]) {
                  throw new Error();
                }
              }
              classNames.push(sprinkle2.values[_value].conditions[_conditionName]);
            }
          }
        }
      } catch (e) {
        if (true) {
          class SprinklesError extends Error {
            constructor(message) {
              super(message);
              this.name = "SprinklesError";
            }
          }
          var format5 = (v) => typeof v === "string" ? '"'.concat(v, '"') : v;
          var invalidPropValue = (prop2, value2, possibleValues) => {
            throw new SprinklesError('"'.concat(prop2, '" has no value ').concat(format5(value2), ". Possible values are ").concat(Object.keys(possibleValues).map(format5).join(", ")));
          };
          if (!sprinkle2) {
            throw new SprinklesError('"'.concat(prop, '" is not a valid sprinkle'));
          }
          if (typeof propValue === "string" || typeof propValue === "number") {
            if (!(propValue in sprinkle2.values)) {
              invalidPropValue(prop, propValue, sprinkle2.values);
            }
            if (!sprinkle2.values[propValue].defaultClass) {
              throw new SprinklesError('"'.concat(prop, '" has no default condition. You must specify which conditions to target explicitly. Possible options are ').concat(Object.keys(sprinkle2.values[propValue].conditions).map(format5).join(", ")));
            }
          }
          if (typeof propValue === "object") {
            if (!("conditions" in sprinkle2.values[Object.keys(sprinkle2.values)[0]])) {
              throw new SprinklesError('"'.concat(prop, '" is not a conditional property'));
            }
            if (Array.isArray(propValue)) {
              if (!("responsiveArray" in sprinkle2)) {
                throw new SprinklesError('"'.concat(prop, '" does not support responsive arrays'));
              }
              var breakpointCount = sprinkle2.responsiveArray.length;
              if (breakpointCount < propValue.length) {
                throw new SprinklesError('"'.concat(prop, '" only supports up to ').concat(breakpointCount, " breakpoints. You passed ").concat(propValue.length));
              }
              for (var _responsiveValue of propValue) {
                if (!sprinkle2.values[_responsiveValue]) {
                  invalidPropValue(prop, _responsiveValue, sprinkle2.values);
                }
              }
            } else {
              for (var _conditionName2 in propValue) {
                var _value2 = propValue[_conditionName2];
                if (_value2 != null) {
                  if (!sprinkle2.values[_value2]) {
                    invalidPropValue(prop, _value2, sprinkle2.values);
                  }
                  if (!sprinkle2.values[_value2].conditions[_conditionName2]) {
                    throw new SprinklesError('"'.concat(prop, '" has no condition named ').concat(format5(_conditionName2), ". Possible values are ").concat(Object.keys(sprinkle2.values[_value2].conditions).map(format5).join(", ")));
                  }
                }
              }
            }
          }
        }
        throw e;
      }
    };
    for (var prop in finalProps) {
      if (_loop()) continue;
    }
    return composeStyles2(classNames.join(" "));
  };
  return Object.assign(sprinklesFn, {
    properties: new Set(sprinklesKeys)
  });
};

// node_modules/@vanilla-extract/sprinkles/createRuntimeSprinkles/dist/vanilla-extract-sprinkles-createRuntimeSprinkles.esm.js
var composeStyles = (classList) => classList;
var createSprinkles2 = function createSprinkles3() {
  return createSprinkles(composeStyles)(...arguments);
};

// node_modules/@rainbow-me/rainbowkit/dist/index.js
var import_react5 = __toESM(require_react());
var import_react6 = __toESM(require_react());

// node_modules/@rainbow-me/rainbowkit/node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// node_modules/@rainbow-me/rainbowkit/dist/index.js
var import_react7 = __toESM(require_react());
var import_react8 = __toESM(require_react());
var import_react9 = __toESM(require_react());
var import_react10 = __toESM(require_react());
var import_react11 = __toESM(require_react());
var import_react12 = __toESM(require_react());
var import_react13 = __toESM(require_react());
var import_react14 = __toESM(require_react());
var import_react15 = __toESM(require_react());
var import_react16 = __toESM(require_react());
var import_react17 = __toESM(require_react());
var import_react18 = __toESM(require_react());

// node_modules/viem/node_modules/ox/_esm/core/Ens.js
var Ens_exports = {};
__export(Ens_exports, {
  labelhash: () => labelhash,
  namehash: () => namehash,
  normalize: () => normalize
});

// node_modules/viem/node_modules/ox/_esm/core/Abi.js
var Abi_exports = {};
__export(Abi_exports, {
  format: () => format2,
  from: () => from7
});

// node_modules/viem/node_modules/ox/_esm/core/internal/abi.js
function isSignatures(value) {
  for (const item of value) {
    if (typeof item !== "string")
      return false;
  }
  return true;
}

// node_modules/viem/node_modules/ox/_esm/core/Abi.js
function format2(abi) {
  return formatAbi(abi);
}
function from7(abi) {
  if (isSignatures(abi))
    return parseAbi(abi);
  return abi;
}

// node_modules/viem/node_modules/ox/_esm/core/AbiEvent.js
var AbiEvent_exports = {};
__export(AbiEvent_exports, {
  ArgsMismatchError: () => ArgsMismatchError,
  DataMismatchError: () => DataMismatchError,
  FilterTypeNotSupportedError: () => FilterTypeNotSupportedError,
  InputNotFoundError: () => InputNotFoundError,
  SelectorTopicMismatchError: () => SelectorTopicMismatchError,
  TopicsMismatchError: () => TopicsMismatchError,
  assertArgs: () => assertArgs,
  decode: () => decode2,
  encode: () => encode2,
  format: () => format3,
  from: () => from8,
  fromAbi: () => fromAbi2,
  getSelector: () => getSelector
});
function assertArgs(abiEvent, args, matchArgs) {
  if (!args || !matchArgs)
    throw new ArgsMismatchError({
      abiEvent,
      expected: args,
      given: matchArgs
    });
  function isEqual3(input, value, arg) {
    if (input.type === "address")
      return isEqual2(value, arg);
    if (input.type === "string")
      return keccak256(fromString(value)) === arg;
    if (input.type === "bytes")
      return keccak256(value) === arg;
    return value === arg;
  }
  if (Array.isArray(args) && Array.isArray(matchArgs)) {
    for (const [index2, value] of matchArgs.entries()) {
      if (value === null || value === void 0)
        continue;
      const input = abiEvent.inputs[index2];
      if (!input)
        throw new InputNotFoundError({
          abiEvent,
          name: `${index2}`
        });
      const value_ = Array.isArray(value) ? value : [value];
      let equal = false;
      for (const value2 of value_) {
        if (isEqual3(input, value2, args[index2]))
          equal = true;
      }
      if (!equal)
        throw new ArgsMismatchError({
          abiEvent,
          expected: args,
          given: matchArgs
        });
    }
  }
  if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    for (const [key, value] of Object.entries(matchArgs)) {
      if (value === null || value === void 0)
        continue;
      const input = abiEvent.inputs.find((input2) => input2.name === key);
      if (!input)
        throw new InputNotFoundError({ abiEvent, name: key });
      const value_ = Array.isArray(value) ? value : [value];
      let equal = false;
      for (const value2 of value_) {
        if (isEqual3(input, value2, args[key]))
          equal = true;
      }
      if (!equal)
        throw new ArgsMismatchError({
          abiEvent,
          expected: args,
          given: matchArgs
        });
    }
}
function decode2(...parameters) {
  const [abiEvent, log] = (() => {
    if (Array.isArray(parameters[0])) {
      const [abi, name, log2] = parameters;
      return [fromAbi2(abi, name), log2];
    }
    return parameters;
  })();
  const { data, topics } = log;
  const [selector_, ...argTopics] = topics;
  const selector = getSelector(abiEvent);
  if (selector_ !== selector)
    throw new SelectorTopicMismatchError({
      abiEvent,
      actual: selector_,
      expected: selector
    });
  const { inputs } = abiEvent;
  const isUnnamed = inputs == null ? void 0 : inputs.every((x) => !("name" in x && x.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
  for (let i = 0; i < indexedInputs.length; i++) {
    const param = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new TopicsMismatchError({
        abiEvent,
        param
      });
    args[isUnnamed ? i : param.name || i] = (() => {
      if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        return topic;
      const decoded = decode([param], topic) || [];
      return decoded[0];
    })();
  }
  const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decode(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i = 0; i < nonIndexedInputs.length; i++) {
              const index2 = inputs.indexOf(nonIndexedInputs[i]);
              args[nonIndexedInputs[i].name || index2] = decodedData[i];
            }
          }
        }
      } catch (err) {
        if (err instanceof DataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
          throw new DataMismatchError({
            abiEvent,
            data,
            parameters: nonIndexedInputs,
            size: size2(data)
          });
        throw err;
      }
    } else {
      throw new DataMismatchError({
        abiEvent,
        data: "0x",
        parameters: nonIndexedInputs,
        size: 0
      });
    }
  }
  return Object.values(args).length > 0 ? args : void 0;
}
function encode2(...parameters) {
  const [abiEvent, args] = (() => {
    if (Array.isArray(parameters[0])) {
      const [abi, name, args3] = parameters;
      return [fromAbi2(abi, name), args3];
    }
    const [abiEvent2, args2] = parameters;
    return [abiEvent2, args2];
  })();
  let topics = [];
  if (args && abiEvent.inputs) {
    const indexedInputs = abiEvent.inputs.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? (indexedInputs == null ? void 0 : indexedInputs.map((x, i) => args[x.name ?? i])) ?? [] : [];
    if (args_.length > 0) {
      const encode6 = (param, value) => {
        if (param.type === "string")
          return keccak256(fromString2(value));
        if (param.type === "bytes")
          return keccak256(value);
        if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
          throw new FilterTypeNotSupportedError(param.type);
        return encode([param], [value]);
      };
      topics = (indexedInputs == null ? void 0 : indexedInputs.map((param, i) => {
        if (Array.isArray(args_[i]))
          return args_[i].map((_, j) => encode6(param, args_[i][j]));
        return typeof args_[i] !== "undefined" && args_[i] !== null ? encode6(param, args_[i]) : null;
      })) ?? [];
    }
  }
  const selector = (() => {
    if (abiEvent.hash)
      return abiEvent.hash;
    return getSelector(abiEvent);
  })();
  return { topics: [selector, ...topics] };
}
function format3(abiEvent) {
  return formatAbiItem(abiEvent);
}
function from8(abiEvent, options = {}) {
  return from6(abiEvent, options);
}
function fromAbi2(abi, name, options) {
  const item = fromAbi(abi, name, options);
  if (item.type !== "event")
    throw new NotFoundError({ name, type: "event" });
  return item;
}
function getSelector(abiItem) {
  return getSignatureHash(abiItem);
}
var ArgsMismatchError = class extends BaseError {
  constructor({ abiEvent, expected, given }) {
    super("Given arguments do not match the expected arguments.", {
      metaMessages: [
        `Event: ${format3(abiEvent)}`,
        `Expected Arguments: ${!expected ? "None" : ""}`,
        expected ? prettyPrint(expected) : void 0,
        `Given Arguments: ${!given ? "None" : ""}`,
        given ? prettyPrint(given) : void 0
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.ArgsMismatchError"
    });
  }
};
var InputNotFoundError = class extends BaseError {
  constructor({ abiEvent, name }) {
    super(`Parameter "${name}" not found on \`${format3(abiEvent)}\`.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.InputNotFoundError"
    });
  }
};
var DataMismatchError = class extends BaseError {
  constructor({ abiEvent, data, parameters, size: size5 }) {
    super([
      `Data size of ${size5} bytes is too small for non-indexed event parameters.`
    ].join("\n"), {
      metaMessages: [
        `Non-indexed Parameters: (${format(parameters)})`,
        `Data:   ${data} (${size5} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.DataMismatchError"
    });
    Object.defineProperty(this, "abiEvent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "parameters", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiEvent = abiEvent;
    this.data = data;
    this.parameters = parameters;
    this.size = size5;
  }
};
var TopicsMismatchError = class extends BaseError {
  constructor({ abiEvent, param }) {
    super([
      `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} for "${format3(abiEvent)}".`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.TopicsMismatchError"
    });
    Object.defineProperty(this, "abiEvent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiEvent = abiEvent;
  }
};
var SelectorTopicMismatchError = class extends BaseError {
  constructor({ abiEvent, actual, expected }) {
    super(`topics[0]="${actual}" does not match the expected topics[0]="${expected}".`, {
      metaMessages: [`Event: ${format3(abiEvent)}`, `Selector: ${expected}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.SelectorTopicMismatchError"
    });
  }
};
var FilterTypeNotSupportedError = class extends BaseError {
  constructor(type6) {
    super(`Filter type "${type6}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.FilterTypeNotSupportedError"
    });
  }
};

// node_modules/viem/node_modules/ox/_esm/core/AccessList.js
var AccessList_exports = {};
__export(AccessList_exports, {
  InvalidStorageKeySizeError: () => InvalidStorageKeySizeError,
  fromTupleList: () => fromTupleList2,
  toTupleList: () => toTupleList2
});
function fromTupleList2(accessList) {
  const list = [];
  for (let i = 0; i < accessList.length; i++) {
    const [address, storageKeys] = accessList[i];
    if (address)
      assert(address, { strict: false });
    list.push({
      address,
      storageKeys: storageKeys.map((key) => validate3(key) ? key : trimLeft(key))
    });
  }
  return list;
}
function toTupleList2(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const tuple = [];
  for (const { address, storageKeys } of accessList) {
    for (let j = 0; j < storageKeys.length; j++)
      if (size2(storageKeys[j]) !== 32)
        throw new InvalidStorageKeySizeError({
          storageKey: storageKeys[j]
        });
    if (address)
      assert(address, { strict: false });
    tuple.push([address, storageKeys]);
  }
  return tuple;
}
var InvalidStorageKeySizeError = class extends BaseError {
  constructor({ storageKey: storageKey6 }) {
    super(`Size for storage key "${storageKey6}" is invalid. Expected 32 bytes. Got ${size2(storageKey6)} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccessList.InvalidStorageKeySizeError"
    });
  }
};

// node_modules/viem/node_modules/ox/_esm/core/AccountProof.js
var AccountProof_exports = {};

// node_modules/viem/node_modules/ox/_esm/core/AesGcm.js
var AesGcm_exports = {};
__export(AesGcm_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt,
  getKey: () => getKey,
  ivLength: () => ivLength,
  randomSalt: () => randomSalt
});
var ivLength = 16;
async function decrypt(value, key, options = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const encrypted = from(value);
  const iv = encrypted.slice(0, ivLength);
  const data = encrypted.slice(ivLength);
  const decrypted = await globalThis.crypto.subtle.decrypt({
    name: "AES-GCM",
    iv
  }, key, from(data));
  const result = new Uint8Array(decrypted);
  if (as === "Bytes")
    return result;
  return from2(result);
}
async function encrypt(value, key, options = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const iv = random(ivLength);
  const encrypted = await globalThis.crypto.subtle.encrypt({
    name: "AES-GCM",
    iv
  }, key, from(value));
  const result = concat(iv, new Uint8Array(encrypted));
  if (as === "Bytes")
    return result;
  return from2(result);
}
async function getKey(options) {
  const { iterations = 9e5, password, salt = randomSalt(32) } = options;
  const baseKey = await globalThis.crypto.subtle.importKey("raw", fromString(password), { name: "PBKDF2" }, false, ["deriveBits", "deriveKey"]);
  const key = await globalThis.crypto.subtle.deriveKey({
    name: "PBKDF2",
    salt,
    iterations,
    hash: "SHA-256"
  }, baseKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
  return key;
}
function randomSalt(size5 = 32) {
  return random(size5);
}

// node_modules/viem/node_modules/ox/_esm/core/Base58.js
var Base58_exports = {};
__export(Base58_exports, {
  fromBytes: () => fromBytes3,
  fromHex: () => fromHex3,
  fromString: () => fromString3,
  toBytes: () => toBytes3,
  toHex: () => toHex3,
  toString: () => toString2
});

// node_modules/viem/node_modules/ox/_esm/core/internal/base58.js
var integerToAlphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var alphabetToInteger = (
  /* __PURE__ */
  Object.freeze({
    1: 0n,
    2: 1n,
    3: 2n,
    4: 3n,
    5: 4n,
    6: 5n,
    7: 6n,
    8: 7n,
    9: 8n,
    A: 9n,
    B: 10n,
    C: 11n,
    D: 12n,
    E: 13n,
    F: 14n,
    G: 15n,
    H: 16n,
    J: 17n,
    K: 18n,
    L: 19n,
    M: 20n,
    N: 21n,
    P: 22n,
    Q: 23n,
    R: 24n,
    S: 25n,
    T: 26n,
    U: 27n,
    V: 28n,
    W: 29n,
    X: 30n,
    Y: 31n,
    Z: 32n,
    a: 33n,
    b: 34n,
    c: 35n,
    d: 36n,
    e: 37n,
    f: 38n,
    g: 39n,
    h: 40n,
    i: 41n,
    j: 42n,
    k: 43n,
    m: 44n,
    n: 45n,
    o: 46n,
    p: 47n,
    q: 48n,
    r: 49n,
    s: 50n,
    t: 51n,
    u: 52n,
    v: 53n,
    w: 54n,
    x: 55n,
    y: 56n,
    z: 57n
  })
);
function from9(value) {
  let bytes = from(value);
  let integer2 = (() => {
    let hex = value;
    if (value instanceof Uint8Array)
      hex = fromBytes(bytes);
    return BigInt(hex);
  })();
  let result = "";
  while (integer2 > 0n) {
    const remainder = Number(integer2 % 58n);
    integer2 = integer2 / 58n;
    result = integerToAlphabet[remainder] + result;
  }
  while (bytes.length > 1 && bytes[0] === 0) {
    result = "1" + result;
    bytes = bytes.slice(1);
  }
  return result;
}

// node_modules/viem/node_modules/ox/_esm/core/Base58.js
function fromBytes3(value) {
  return from9(value);
}
function fromHex3(value) {
  return from9(value);
}
function fromString3(value) {
  return from9(fromString(value));
}
function toBytes3(value) {
  return fromHex(toHex3(value));
}
function toHex3(value) {
  let integer2 = BigInt(0);
  let pad2 = 0;
  let checkPad = true;
  for (let i = 0; i < value.length; i++) {
    const char = value[i];
    if (checkPad && char === "1")
      pad2++;
    else
      checkPad = false;
    if (typeof alphabetToInteger[char] !== "bigint")
      throw new Error("invalid base58 character: " + char);
    integer2 = integer2 * 58n;
    integer2 = integer2 + alphabetToInteger[char];
  }
  if (!pad2)
    return `0x${integer2.toString(16)}`;
  return `0x${"0".repeat(pad2 * 2)}${integer2.toString(16)}`;
}
function toString2(value) {
  return toString(toHex3(value));
}

// node_modules/viem/node_modules/ox/_esm/core/BinaryStateTree.js
var BinaryStateTree_exports = {};
__export(BinaryStateTree_exports, {
  create: () => create2,
  insert: () => insert,
  merkelize: () => merkelize
});
function create2() {
  return {
    root: emptyNode()
  };
}
function insert(tree, key, value) {
  const stem = slice(key, 0, 31);
  const subIndex = slice(key, 31)[0];
  if (tree.root.type === "empty") {
    tree.root = stemNode(stem);
    tree.root.values[subIndex] = value;
    return;
  }
  function inner(node_, stem2, subIndex2, value2, depth) {
    let node = node_;
    if (node.type === "empty") {
      node = stemNode(stem2);
      node.values[subIndex2] = value2;
      return node;
    }
    const stemBits = bytesToBits(stem2);
    if (node.type === "stem") {
      if (isEqual(node.stem, stem2)) {
        node.values[subIndex2] = value2;
        return node;
      }
      const existingStemBits = bytesToBits(node.stem);
      return splitLeaf(node, stemBits, existingStemBits, subIndex2, value2, depth);
    }
    if (node.type === "internal") {
      const bit = stemBits[depth];
      if (bit === 0) {
        node.left = inner(node.left, stem2, subIndex2, value2, depth + 1);
      } else {
        node.right = inner(node.right, stem2, subIndex2, value2, depth + 1);
      }
      return node;
    }
    return emptyNode();
  }
  tree.root = inner(tree.root, stem, subIndex, value, 0);
}
function merkelize(tree) {
  function inner(node) {
    if (node.type === "empty")
      return new Uint8Array(32).fill(0);
    if (node.type === "internal") {
      const hash_left = inner(node.left);
      const hash_right = inner(node.right);
      return hash(concat(hash_left, hash_right));
    }
    let level = node.values.map(hash);
    while (level.length > 1) {
      const level_ = [];
      for (let i = 0; i < level.length; i += 2)
        level_.push(hash(concat(level[i], level[i + 1])));
      level = level_;
    }
    return hash(concat(node.stem, new Uint8Array(1).fill(0), level[0]));
  }
  return inner(tree.root);
}
function splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth) {
  if (stemBits[depth] === existingStemBits[depth]) {
    const internal2 = internalNode();
    const bit2 = stemBits[depth];
    if (bit2 === 0) {
      internal2.left = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth + 1);
    } else {
      internal2.right = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth + 1);
    }
    return internal2;
  }
  const internal = internalNode();
  const bit = stemBits[depth];
  const stem = bitsToBytes(stemBits);
  if (bit === 0) {
    internal.left = stemNode(stem);
    internal.left.values[subIndex] = value;
    internal.right = leaf;
  } else {
    internal.right = stemNode(stem);
    internal.right.values[subIndex] = value;
    internal.left = leaf;
  }
  return internal;
}
function emptyNode() {
  return {
    type: "empty"
  };
}
function internalNode() {
  return {
    left: emptyNode(),
    right: emptyNode(),
    type: "internal"
  };
}
function stemNode(stem) {
  return {
    stem,
    values: Array.from({ length: 256 }, () => void 0),
    type: "stem"
  };
}
function bytesToBits(bytes) {
  const bits = [];
  for (const byte of bytes)
    for (let i = 0; i < 8; i++)
      bits.push(byte >> 7 - i & 1);
  return bits;
}
function bitsToBytes(bits) {
  const byte_data = new Uint8Array(bits.length / 8);
  for (let i = 0; i < bits.length; i += 8) {
    let byte = 0;
    for (let j = 0; j < 8; j++)
      byte |= bits[i + j] << 7 - j;
    byte_data[i / 8] = byte;
  }
  return byte_data;
}
function hash(bytes) {
  if (!bytes)
    return new Uint8Array(32).fill(0);
  if (!bytes.some((byte) => byte !== 0))
    return new Uint8Array(32).fill(0);
  return blake3(bytes);
}

// node_modules/viem/node_modules/ox/_esm/core/Blobs.js
var Blobs_exports = {};
__export(Blobs_exports, {
  BlobSizeTooLargeError: () => BlobSizeTooLargeError,
  EmptyBlobError: () => EmptyBlobError,
  EmptyBlobVersionedHashesError: () => EmptyBlobVersionedHashesError,
  InvalidVersionedHashSizeError: () => InvalidVersionedHashSizeError,
  InvalidVersionedHashVersionError: () => InvalidVersionedHashVersionError,
  bytesPerBlob: () => bytesPerBlob,
  bytesPerFieldElement: () => bytesPerFieldElement,
  commitmentToVersionedHash: () => commitmentToVersionedHash,
  commitmentsToVersionedHashes: () => commitmentsToVersionedHashes,
  fieldElementsPerBlob: () => fieldElementsPerBlob,
  from: () => from11,
  maxBytesPerTransaction: () => maxBytesPerTransaction,
  sidecarsToVersionedHashes: () => sidecarsToVersionedHashes,
  to: () => to,
  toBytes: () => toBytes4,
  toCommitments: () => toCommitments,
  toHex: () => toHex4,
  toProofs: () => toProofs,
  toSidecars: () => toSidecars,
  toVersionedHashes: () => toVersionedHashes
});

// node_modules/viem/node_modules/ox/_esm/core/Kzg.js
var Kzg_exports = {};
__export(Kzg_exports, {
  from: () => from10,
  versionedHashVersion: () => versionedHashVersion
});
var versionedHashVersion = 1;
function from10(value) {
  const { blobToKzgCommitment, computeBlobKzgProof } = value;
  return {
    blobToKzgCommitment,
    computeBlobKzgProof
  };
}

// node_modules/viem/node_modules/ox/_esm/core/Blobs.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;
function commitmentsToVersionedHashes(commitments, options = {}) {
  const { version: version5 } = options;
  const as = options.as ?? (typeof commitments[0] === "string" ? "Hex" : "Bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash(commitment, {
      as,
      version: version5
    }));
  }
  return hashes;
}
function commitmentToVersionedHash(commitment, options = {}) {
  const { version: version5 = 1 } = options;
  const as = options.as ?? (typeof commitment === "string" ? "Hex" : "Bytes");
  const versionedHash = sha2562(commitment, { as: "Bytes" });
  versionedHash.set([version5], 0);
  return as === "Bytes" ? versionedHash : fromBytes(versionedHash);
}
function from11(data, options = {}) {
  const as = options.as ?? (typeof data === "string" ? "Hex" : "Bytes");
  const data_ = typeof data === "string" ? fromHex(data) : data;
  const size_ = size(data_);
  if (!size_)
    throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active2 = true;
  let position = 0;
  while (active2) {
    const blob = create(new Uint8Array(bytesPerBlob));
    let size5 = 0;
    while (size5 < fieldElementsPerBlob) {
      const bytes = data_.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active2 = false;
        break;
      }
      size5++;
      position += 31;
    }
    blobs.push(blob);
  }
  return as === "Bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => fromBytes(x.bytes));
}
function sidecarsToVersionedHashes(sidecars, options = {}) {
  const { version: version5 } = options;
  const as = options.as ?? (typeof sidecars[0].blob === "string" ? "Hex" : "Bytes");
  const hashes = [];
  for (const { commitment } of sidecars) {
    hashes.push(commitmentToVersionedHash(commitment, {
      as,
      version: version5
    }));
  }
  return hashes;
}
function to(blobs, to2) {
  const to_ = to2 ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x) => fromHex(x)) : blobs;
  const length = blobs_.reduce((length2, blob) => length2 + blob.length, 0);
  const data = create(new Uint8Array(length));
  let active2 = true;
  for (const blob of blobs_) {
    const cursor = create(blob);
    while (active2 && cursor.position < blob.length) {
      cursor.incrementPosition(1);
      let consume = 31;
      if (blob.length - cursor.position < 31)
        consume = blob.length - cursor.position;
      for (const _ in Array.from({ length: consume })) {
        const byte = cursor.readByte();
        const isTerminator = byte === 128 && !cursor.inspectBytes(cursor.remaining).includes(128);
        if (isTerminator) {
          active2 = false;
          break;
        }
        data.pushByte(byte);
      }
    }
  }
  const trimmedData = data.bytes.slice(0, data.position);
  return to_ === "Hex" ? fromBytes(trimmedData) : trimmedData;
}
function toHex4(blobs) {
  return to(blobs, "Hex");
}
function toBytes4(blobs) {
  return to(blobs, "Bytes");
}
function toCommitments(blobs, options) {
  const { kzg } = options;
  const as = options.as ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x) => fromHex(x)) : blobs;
  const commitments = [];
  for (const blob of blobs_)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return as === "Bytes" ? commitments : commitments.map((x) => fromBytes(x));
}
function toProofs(blobs, options) {
  const { kzg } = options;
  const as = options.as ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x) => fromHex(x)) : blobs;
  const commitments = typeof options.commitments[0] === "string" ? options.commitments.map((x) => fromHex(x)) : options.commitments;
  const proofs = [];
  for (let i = 0; i < blobs_.length; i++) {
    const blob = blobs_[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return as === "Bytes" ? proofs : proofs.map((x) => fromBytes(x));
}
function toSidecars(blobs, options) {
  const { kzg } = options;
  const commitments = options.commitments ?? toCommitments(blobs, { kzg });
  const proofs = options.proofs ?? toProofs(blobs, { commitments, kzg });
  const sidecars = [];
  for (let i = 0; i < blobs.length; i++)
    sidecars.push({
      blob: blobs[i],
      commitment: commitments[i],
      proof: proofs[i]
    });
  return sidecars;
}
function toVersionedHashes(blobs, options) {
  const commitments = toCommitments(blobs, options);
  return commitmentsToVersionedHashes(commitments, options);
}
var BlobSizeTooLargeError = class extends BaseError {
  constructor({ maxSize, size: size5 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size5} bytes`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.BlobSizeTooLargeError"
    });
  }
};
var EmptyBlobError = class extends BaseError {
  constructor() {
    super("Blob data must not be empty.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.EmptyBlobError"
    });
  }
};
var EmptyBlobVersionedHashesError = class extends BaseError {
  constructor() {
    super("Blob versioned hashes must not be empty.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.EmptyBlobVersionedHashesError"
    });
  }
};
var InvalidVersionedHashSizeError = class extends BaseError {
  constructor({ hash: hash8, size: size5 }) {
    super(`Versioned hash "${hash8}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${size5}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.InvalidVersionedHashSizeError"
    });
  }
};
var InvalidVersionedHashVersionError = class extends BaseError {
  constructor({ hash: hash8, version: version5 }) {
    super(`Versioned hash "${hash8}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersion}`,
        `Received: ${version5}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.InvalidVersionedHashVersionError"
    });
  }
};

// node_modules/viem/node_modules/ox/_esm/core/Block.js
var Block_exports = {};
__export(Block_exports, {
  fromRpc: () => fromRpc3,
  toRpc: () => toRpc4
});

// node_modules/viem/node_modules/ox/_esm/core/Transaction.js
var Transaction_exports = {};
__export(Transaction_exports, {
  fromRpc: () => fromRpc2,
  fromRpcType: () => fromRpcType,
  toRpc: () => toRpc3,
  toRpcType: () => toRpcType
});
var toRpcType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
var fromRpcType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function fromRpc2(transaction, _options = {}) {
  if (!transaction)
    return null;
  const signature = extract(transaction);
  const transaction_ = {
    ...transaction,
    ...signature
  };
  transaction_.blockNumber = transaction.blockNumber ? BigInt(transaction.blockNumber) : null;
  transaction_.data = transaction.input;
  transaction_.gas = BigInt(transaction.gas ?? 0n);
  transaction_.nonce = BigInt(transaction.nonce ?? 0n);
  transaction_.transactionIndex = transaction.transactionIndex ? Number(transaction.transactionIndex) : null;
  transaction_.value = BigInt(transaction.value ?? 0n);
  if (transaction.authorizationList)
    transaction_.authorizationList = fromRpcList(transaction.authorizationList);
  if (transaction.chainId)
    transaction_.chainId = Number(transaction.chainId);
  if (transaction.gasPrice)
    transaction_.gasPrice = BigInt(transaction.gasPrice);
  if (transaction.maxFeePerBlobGas)
    transaction_.maxFeePerBlobGas = BigInt(transaction.maxFeePerBlobGas);
  if (transaction.maxFeePerGas)
    transaction_.maxFeePerGas = BigInt(transaction.maxFeePerGas);
  if (transaction.maxPriorityFeePerGas)
    transaction_.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas);
  if (transaction.type)
    transaction_.type = fromRpcType[transaction.type] ?? transaction.type;
  if (signature)
    transaction_.v = yParityToV(signature.yParity);
  return transaction_;
}
function toRpc3(transaction, _options) {
  const rpc = {};
  rpc.blockHash = transaction.blockHash;
  rpc.blockNumber = typeof transaction.blockNumber === "bigint" ? fromNumber2(transaction.blockNumber) : null;
  rpc.from = transaction.from;
  rpc.gas = fromNumber2(transaction.gas ?? 0n);
  rpc.hash = transaction.hash;
  rpc.input = transaction.input;
  rpc.nonce = fromNumber2(transaction.nonce ?? 0n);
  rpc.to = transaction.to;
  rpc.transactionIndex = transaction.transactionIndex ? fromNumber2(transaction.transactionIndex) : null;
  rpc.type = toRpcType[transaction.type] ?? transaction.type;
  rpc.value = fromNumber2(transaction.value ?? 0n);
  if (transaction.accessList)
    rpc.accessList = transaction.accessList;
  if (transaction.authorizationList)
    rpc.authorizationList = toRpcList(transaction.authorizationList);
  if (transaction.blobVersionedHashes)
    rpc.blobVersionedHashes = transaction.blobVersionedHashes;
  if (transaction.chainId)
    rpc.chainId = fromNumber2(transaction.chainId);
  if (typeof transaction.gasPrice === "bigint")
    rpc.gasPrice = fromNumber2(transaction.gasPrice);
  if (typeof transaction.maxFeePerBlobGas === "bigint")
    rpc.maxFeePerBlobGas = fromNumber2(transaction.maxFeePerBlobGas);
  if (typeof transaction.maxFeePerGas === "bigint")
    rpc.maxFeePerGas = fromNumber2(transaction.maxFeePerGas);
  if (typeof transaction.maxPriorityFeePerGas === "bigint")
    rpc.maxPriorityFeePerGas = fromNumber2(transaction.maxPriorityFeePerGas);
  if (typeof transaction.r === "bigint")
    rpc.r = fromNumber2(transaction.r, { size: 32 });
  if (typeof transaction.s === "bigint")
    rpc.s = fromNumber2(transaction.s, { size: 32 });
  if (typeof transaction.v === "number")
    rpc.v = fromNumber2(transaction.v, { size: 1 });
  if (typeof transaction.yParity === "number")
    rpc.yParity = transaction.yParity === 0 ? "0x0" : "0x1";
  return rpc;
}

// node_modules/viem/node_modules/ox/_esm/core/Block.js
function toRpc4(block, _options = {}) {
  var _a;
  const transactions = block.transactions.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return toRpc3(transaction);
  });
  return {
    baseFeePerGas: typeof block.baseFeePerGas === "bigint" ? fromNumber2(block.baseFeePerGas) : void 0,
    blobGasUsed: typeof block.blobGasUsed === "bigint" ? fromNumber2(block.blobGasUsed) : void 0,
    excessBlobGas: typeof block.excessBlobGas === "bigint" ? fromNumber2(block.excessBlobGas) : void 0,
    extraData: block.extraData,
    difficulty: typeof block.difficulty === "bigint" ? fromNumber2(block.difficulty) : void 0,
    gasLimit: fromNumber2(block.gasLimit),
    gasUsed: fromNumber2(block.gasUsed),
    hash: block.hash,
    logsBloom: block.logsBloom,
    miner: block.miner,
    mixHash: block.mixHash,
    nonce: block.nonce,
    number: typeof block.number === "bigint" ? fromNumber2(block.number) : null,
    parentBeaconBlockRoot: block.parentBeaconBlockRoot,
    parentHash: block.parentHash,
    receiptsRoot: block.receiptsRoot,
    sealFields: block.sealFields,
    sha3Uncles: block.sha3Uncles,
    size: fromNumber2(block.size),
    stateRoot: block.stateRoot,
    timestamp: fromNumber2(block.timestamp),
    totalDifficulty: typeof block.totalDifficulty === "bigint" ? fromNumber2(block.totalDifficulty) : void 0,
    transactions,
    transactionsRoot: block.transactionsRoot,
    uncles: block.uncles,
    withdrawals: (_a = block.withdrawals) == null ? void 0 : _a.map(toRpc),
    withdrawalsRoot: block.withdrawalsRoot
  };
}
function fromRpc3(block, _options = {}) {
  var _a;
  if (!block)
    return null;
  const transactions = block.transactions.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return fromRpc2(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : void 0,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: BigInt(block.gasLimit ?? 0n),
    gasUsed: BigInt(block.gasUsed ?? 0n),
    number: block.number ? BigInt(block.number) : null,
    size: BigInt(block.size ?? 0n),
    stateRoot: block.stateRoot,
    timestamp: BigInt(block.timestamp ?? 0n),
    totalDifficulty: BigInt(block.totalDifficulty ?? 0n),
    transactions,
    withdrawals: (_a = block.withdrawals) == null ? void 0 : _a.map(fromRpc)
  };
}

// node_modules/viem/node_modules/ox/_esm/core/Bloom.js
var Bloom_exports = {};
__export(Bloom_exports, {
  contains: () => contains,
  validate: () => validate4
});
function contains(bloom, input) {
  const filter = fromHex(bloom);
  const hash8 = keccak256(input, { as: "Bytes" });
  for (const i of [0, 2, 4]) {
    const bit = hash8[i + 1] + (hash8[i] << 8) & 2047;
    if ((filter[256 - 1 - Math.floor(bit / 8)] & 1 << bit % 8) === 0)
      return false;
  }
  return true;
}
function validate4(value) {
  return validate2(value) && size2(value) === 256;
}

// node_modules/viem/node_modules/ox/_esm/core/Bls.js
var Bls_exports = {};
__export(Bls_exports, {
  aggregate: () => aggregate,
  createKeyPair: () => createKeyPair,
  getPublicKey: () => getPublicKey2,
  noble: () => noble,
  randomPrivateKey: () => randomPrivateKey,
  sign: () => sign,
  verify: () => verify
});

// node_modules/viem/node_modules/@noble/curves/esm/abstract/bls.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
function NAfDecomposition(a) {
  const res = [];
  for (; a > _1n; a >>= _1n) {
    if ((a & _1n) === _0n)
      res.unshift(0);
    else if ((a & _3n) === _3n) {
      res.unshift(-1);
      a += _1n;
    } else
      res.unshift(1);
  }
  return res;
}
function bls(CURVE) {
  const { Fp: Fp4, Fr: Fr2, Fp2: Fp22, Fp6: Fp62, Fp12: Fp122 } = CURVE.fields;
  const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;
  const TWIST = CURVE.params.twistType;
  const G1_ = weierstrassPoints({ n: Fr2.ORDER, ...CURVE.G1 });
  const G1 = Object.assign(G1_, createHasher(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G1.htfDefaults
  }));
  const G2_ = weierstrassPoints({ n: Fr2.ORDER, ...CURVE.G2 });
  const G2 = Object.assign(G2_, createHasher(G2_.ProjectivePoint, CURVE.G2.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G2.htfDefaults
  }));
  let lineFunction;
  if (TWIST === "multiplicative") {
    lineFunction = (c0, c1, c2, f, Px, Py) => Fp122.mul014(f, c0, Fp22.mul(c1, Px), Fp22.mul(c2, Py));
  } else if (TWIST === "divisive") {
    lineFunction = (c0, c1, c2, f, Px, Py) => Fp122.mul034(f, Fp22.mul(c2, Py), Fp22.mul(c1, Px), c0);
  } else
    throw new Error("bls: unknown twist type");
  const Fp2div2 = Fp22.div(Fp22.ONE, Fp22.mul(Fp22.ONE, _2n));
  function pointDouble(ell, Rx, Ry, Rz) {
    const t0 = Fp22.sqr(Ry);
    const t1 = Fp22.sqr(Rz);
    const t2 = Fp22.mulByB(Fp22.mul(t1, _3n));
    const t3 = Fp22.mul(t2, _3n);
    const t4 = Fp22.sub(Fp22.sub(Fp22.sqr(Fp22.add(Ry, Rz)), t1), t0);
    const c0 = Fp22.sub(t2, t0);
    const c1 = Fp22.mul(Fp22.sqr(Rx), _3n);
    const c2 = Fp22.neg(t4);
    ell.push([c0, c1, c2]);
    Rx = Fp22.mul(Fp22.mul(Fp22.mul(Fp22.sub(t0, t3), Rx), Ry), Fp2div2);
    Ry = Fp22.sub(Fp22.sqr(Fp22.mul(Fp22.add(t0, t3), Fp2div2)), Fp22.mul(Fp22.sqr(t2), _3n));
    Rz = Fp22.mul(t0, t4);
    return { Rx, Ry, Rz };
  }
  function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {
    const t0 = Fp22.sub(Ry, Fp22.mul(Qy, Rz));
    const t1 = Fp22.sub(Rx, Fp22.mul(Qx, Rz));
    const c0 = Fp22.sub(Fp22.mul(t0, Qx), Fp22.mul(t1, Qy));
    const c1 = Fp22.neg(t0);
    const c2 = t1;
    ell.push([c0, c1, c2]);
    const t2 = Fp22.sqr(t1);
    const t3 = Fp22.mul(t2, t1);
    const t4 = Fp22.mul(t2, Rx);
    const t5 = Fp22.add(Fp22.sub(t3, Fp22.mul(t4, _2n)), Fp22.mul(Fp22.sqr(t0), Rz));
    Rx = Fp22.mul(t1, t5);
    Ry = Fp22.sub(Fp22.mul(Fp22.sub(t4, t5), t0), Fp22.mul(t3, Ry));
    Rz = Fp22.mul(Rz, t3);
    return { Rx, Ry, Rz };
  }
  const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);
  const calcPairingPrecomputes = memoized((point) => {
    const p = point;
    const { x, y } = p.toAffine();
    const Qx = x, Qy = y, negQy = Fp22.neg(y);
    let Rx = Qx, Ry = Qy, Rz = Fp22.ONE;
    const ell = [];
    for (const bit of ATE_NAF) {
      const cur = [];
      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));
      if (bit)
        ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));
      ell.push(cur);
    }
    if (CURVE.postPrecompute) {
      const last = ell[ell.length - 1];
      CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));
    }
    return ell;
  });
  function millerLoopBatch(pairs, withFinalExponent = false) {
    let f12 = Fp122.ONE;
    if (pairs.length) {
      const ellLen = pairs[0][0].length;
      for (let i = 0; i < ellLen; i++) {
        f12 = Fp122.sqr(f12);
        for (const [ell, Px, Py] of pairs) {
          for (const [c0, c1, c2] of ell[i])
            f12 = lineFunction(c0, c1, c2, f12, Px, Py);
        }
      }
    }
    if (BLS_X_IS_NEGATIVE)
      f12 = Fp122.conjugate(f12);
    return withFinalExponent ? Fp122.finalExponentiate(f12) : f12;
  }
  function pairingBatch(pairs, withFinalExponent = true) {
    const res = [];
    G1.ProjectivePoint.normalizeZ(pairs.map(({ g1 }) => g1));
    G2.ProjectivePoint.normalizeZ(pairs.map(({ g2 }) => g2));
    for (const { g1, g2 } of pairs) {
      if (g1.equals(G1.ProjectivePoint.ZERO) || g2.equals(G2.ProjectivePoint.ZERO))
        throw new Error("pairing is not available for ZERO point");
      g1.assertValidity();
      g2.assertValidity();
      const Qa = g1.toAffine();
      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);
    }
    return millerLoopBatch(res, withFinalExponent);
  }
  function pairing(Q, P, withFinalExponent = true) {
    return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);
  }
  const utils = {
    randomPrivateKey: () => {
      const length = getMinHashLength(Fr2.ORDER);
      return mapHashToField(CURVE.randomBytes(length), Fr2.ORDER);
    },
    calcPairingPrecomputes
  };
  const { ShortSignature } = CURVE.G1;
  const { Signature } = CURVE.G2;
  function normP1(point) {
    return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);
  }
  function normP1Hash(point, htfOpts) {
    return point instanceof G1.ProjectivePoint ? point : G1.hashToCurve(ensureBytes("point", point), htfOpts);
  }
  function normP2(point) {
    return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);
  }
  function normP2Hash(point, htfOpts) {
    return point instanceof G2.ProjectivePoint ? point : G2.hashToCurve(ensureBytes("point", point), htfOpts);
  }
  function getPublicKey5(privateKey) {
    return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);
  }
  function getPublicKeyForShortSignatures(privateKey) {
    return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);
  }
  function sign4(message, privateKey, htfOpts) {
    const msgPoint = normP2Hash(message, htfOpts);
    msgPoint.assertValidity();
    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));
    if (message instanceof G2.ProjectivePoint)
      return sigPoint;
    return Signature.toRawBytes(sigPoint);
  }
  function signShortSignature(message, privateKey, htfOpts) {
    const msgPoint = normP1Hash(message, htfOpts);
    msgPoint.assertValidity();
    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));
    if (message instanceof G1.ProjectivePoint)
      return sigPoint;
    return ShortSignature.toRawBytes(sigPoint);
  }
  function verify4(signature, message, publicKey, htfOpts) {
    const P = normP1(publicKey);
    const Hm = normP2Hash(message, htfOpts);
    const G = G1.ProjectivePoint.BASE;
    const S = normP2(signature);
    const exp = pairingBatch([
      { g1: P.negate(), g2: Hm },
      // ePHM = pairing(P.negate(), Hm, false);
      { g1: G, g2: S }
      // eGS = pairing(G, S, false);
    ]);
    return Fp122.eql(exp, Fp122.ONE);
  }
  function verifyShortSignature(signature, message, publicKey, htfOpts) {
    const P = normP2(publicKey);
    const Hm = normP1Hash(message, htfOpts);
    const G = G2.ProjectivePoint.BASE;
    const S = normP1(signature);
    const exp = pairingBatch([
      { g1: Hm, g2: P },
      // eHmP = pairing(Hm, P, false);
      { g1: S, g2: G.negate() }
      // eSG = pairing(S, G.negate(), false);
    ]);
    return Fp122.eql(exp, Fp122.ONE);
  }
  function aNonEmpty(arr) {
    if (!Array.isArray(arr) || arr.length === 0)
      throw new Error("expected non-empty array");
  }
  function aggregatePublicKeys(publicKeys) {
    aNonEmpty(publicKeys);
    const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);
    const aggAffine = agg;
    if (publicKeys[0] instanceof G1.ProjectivePoint) {
      aggAffine.assertValidity();
      return aggAffine;
    }
    return aggAffine.toRawBytes(true);
  }
  function aggregateSignatures(signatures) {
    aNonEmpty(signatures);
    const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);
    const aggAffine = agg;
    if (signatures[0] instanceof G2.ProjectivePoint) {
      aggAffine.assertValidity();
      return aggAffine;
    }
    return Signature.toRawBytes(aggAffine);
  }
  function aggregateShortSignatures(signatures) {
    aNonEmpty(signatures);
    const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);
    const aggAffine = agg;
    if (signatures[0] instanceof G1.ProjectivePoint) {
      aggAffine.assertValidity();
      return aggAffine;
    }
    return ShortSignature.toRawBytes(aggAffine);
  }
  function verifyBatch(signature, messages, publicKeys, htfOpts) {
    aNonEmpty(messages);
    if (publicKeys.length !== messages.length)
      throw new Error("amount of public keys and messages should be equal");
    const sig = normP2(signature);
    const nMessages = messages.map((i) => normP2Hash(i, htfOpts));
    const nPublicKeys = publicKeys.map(normP1);
    const messagePubKeyMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < nPublicKeys.length; i++) {
      const pub = nPublicKeys[i];
      const msg = nMessages[i];
      let keys = messagePubKeyMap.get(msg);
      if (keys === void 0) {
        keys = [];
        messagePubKeyMap.set(msg, keys);
      }
      keys.push(pub);
    }
    const paired = [];
    try {
      for (const [msg, keys] of messagePubKeyMap) {
        const groupPublicKey = keys.reduce((acc, msg2) => acc.add(msg2));
        paired.push({ g1: groupPublicKey, g2: msg });
      }
      paired.push({ g1: G1.ProjectivePoint.BASE.negate(), g2: sig });
      return Fp122.eql(pairingBatch(paired), Fp122.ONE);
    } catch {
      return false;
    }
  }
  G1.ProjectivePoint.BASE._setWindowSize(4);
  return {
    getPublicKey: getPublicKey5,
    getPublicKeyForShortSignatures,
    sign: sign4,
    signShortSignature,
    verify: verify4,
    verifyBatch,
    verifyShortSignature,
    aggregatePublicKeys,
    aggregateSignatures,
    aggregateShortSignatures,
    millerLoopBatch,
    pairing,
    pairingBatch,
    G1,
    G2,
    Signature,
    ShortSignature,
    fields: {
      Fr: Fr2,
      Fp: Fp4,
      Fp2: Fp22,
      Fp6: Fp62,
      Fp12: Fp122
    },
    params: {
      ateLoopSize: CURVE.params.ateLoopSize,
      r: CURVE.params.r,
      G1b: CURVE.G1.b,
      G2b: CURVE.G2.b
    },
    utils
  };
}

// node_modules/viem/node_modules/@noble/curves/esm/abstract/tower.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n2 = BigInt(3);
function calcFrobeniusCoefficients(Fp4, nonResidue, modulus, degree, num = 1, divisor) {
  const _divisor = BigInt(divisor === void 0 ? degree : divisor);
  const towerModulus = modulus ** BigInt(degree);
  const res = [];
  for (let i = 0; i < num; i++) {
    const a = BigInt(i + 1);
    const powers = [];
    for (let j = 0, qPower = _1n2; j < degree; j++) {
      const power = (a * qPower - a) / _divisor % towerModulus;
      powers.push(Fp4.pow(nonResidue, power));
      qPower *= modulus;
    }
    res.push(powers);
  }
  return res;
}
function psiFrobenius(Fp4, Fp22, base3) {
  const PSI_X = Fp22.pow(base3, (Fp4.ORDER - _1n2) / _3n2);
  const PSI_Y = Fp22.pow(base3, (Fp4.ORDER - _1n2) / _2n2);
  function psi(x, y) {
    const x2 = Fp22.mul(Fp22.frobeniusMap(x, 1), PSI_X);
    const y2 = Fp22.mul(Fp22.frobeniusMap(y, 1), PSI_Y);
    return [x2, y2];
  }
  const PSI2_X = Fp22.pow(base3, (Fp4.ORDER ** _2n2 - _1n2) / _3n2);
  const PSI2_Y = Fp22.pow(base3, (Fp4.ORDER ** _2n2 - _1n2) / _2n2);
  if (!Fp22.eql(PSI2_Y, Fp22.neg(Fp22.ONE)))
    throw new Error("psiFrobenius: PSI2_Y!==-1");
  function psi2(x, y) {
    return [Fp22.mul(x, PSI2_X), Fp22.neg(y)];
  }
  const mapAffine = (fn) => (c, P) => {
    const affine = P.toAffine();
    const p = fn(affine.x, affine.y);
    return c.fromAffine({ x: p[0], y: p[1] });
  };
  const G2psi3 = mapAffine(psi);
  const G2psi22 = mapAffine(psi2);
  return { psi, psi2, G2psi: G2psi3, G2psi2: G2psi22, PSI_X, PSI_Y, PSI2_X, PSI2_Y };
}
function tower12(opts) {
  const { ORDER } = opts;
  const Fp4 = Field(ORDER);
  const FpNONRESIDUE = Fp4.create(opts.NONRESIDUE || BigInt(-1));
  const Fpdiv2 = Fp4.div(Fp4.ONE, _2n2);
  const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp4, FpNONRESIDUE, Fp4.ORDER, 2)[0];
  const Fp2Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp4.add(c0, r0),
    c1: Fp4.add(c1, r1)
  });
  const Fp2Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp4.sub(c0, r0),
    c1: Fp4.sub(c1, r1)
  });
  const Fp2Multiply = ({ c0, c1 }, rhs) => {
    if (typeof rhs === "bigint")
      return { c0: Fp4.mul(c0, rhs), c1: Fp4.mul(c1, rhs) };
    const { c0: r0, c1: r1 } = rhs;
    let t1 = Fp4.mul(c0, r0);
    let t2 = Fp4.mul(c1, r1);
    const o0 = Fp4.sub(t1, t2);
    const o1 = Fp4.sub(Fp4.mul(Fp4.add(c0, c1), Fp4.add(r0, r1)), Fp4.add(t1, t2));
    return { c0: o0, c1: o1 };
  };
  const Fp2Square = ({ c0, c1 }) => {
    const a = Fp4.add(c0, c1);
    const b = Fp4.sub(c0, c1);
    const c = Fp4.add(c0, c0);
    return { c0: Fp4.mul(a, b), c1: Fp4.mul(c, c1) };
  };
  const Fp2fromBigTuple = (tuple) => {
    if (tuple.length !== 2)
      throw new Error("invalid tuple");
    const fps = tuple.map((n) => Fp4.create(n));
    return { c0: fps[0], c1: fps[1] };
  };
  const FP2_ORDER = ORDER * ORDER;
  const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);
  const Fp22 = {
    ORDER: FP2_ORDER,
    isLE: Fp4.isLE,
    NONRESIDUE: Fp2Nonresidue,
    BITS: bitLen(FP2_ORDER),
    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),
    MASK: bitMask(bitLen(FP2_ORDER)),
    ZERO: { c0: Fp4.ZERO, c1: Fp4.ZERO },
    ONE: { c0: Fp4.ONE, c1: Fp4.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1 }) => typeof c0 === "bigint" && typeof c1 === "bigint",
    is0: ({ c0, c1 }) => Fp4.is0(c0) && Fp4.is0(c1),
    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp4.eql(c0, r0) && Fp4.eql(c1, r1),
    neg: ({ c0, c1 }) => ({ c0: Fp4.neg(c0), c1: Fp4.neg(c1) }),
    pow: (num, power) => FpPow(Fp22, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp22, nums),
    // Normalized
    add: Fp2Add,
    sub: Fp2Subtract,
    mul: Fp2Multiply,
    sqr: Fp2Square,
    // NonNormalized stuff
    addN: Fp2Add,
    subN: Fp2Subtract,
    mulN: Fp2Multiply,
    sqrN: Fp2Square,
    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?
    div: (lhs, rhs) => Fp22.mul(lhs, typeof rhs === "bigint" ? Fp4.inv(Fp4.create(rhs)) : Fp22.inv(rhs)),
    inv: ({ c0: a, c1: b }) => {
      const factor = Fp4.inv(Fp4.create(a * a + b * b));
      return { c0: Fp4.mul(factor, Fp4.create(a)), c1: Fp4.mul(factor, Fp4.create(-b)) };
    },
    sqrt: (num) => {
      if (opts.Fp2sqrt)
        return opts.Fp2sqrt(num);
      const { c0, c1 } = num;
      if (Fp4.is0(c1)) {
        if (FpLegendre(Fp4, c0) === 1)
          return Fp22.create({ c0: Fp4.sqrt(c0), c1: Fp4.ZERO });
        else
          return Fp22.create({ c0: Fp4.ZERO, c1: Fp4.sqrt(Fp4.div(c0, FpNONRESIDUE)) });
      }
      const a = Fp4.sqrt(Fp4.sub(Fp4.sqr(c0), Fp4.mul(Fp4.sqr(c1), FpNONRESIDUE)));
      let d = Fp4.mul(Fp4.add(a, c0), Fpdiv2);
      const legendre = FpLegendre(Fp4, d);
      if (legendre === -1)
        d = Fp4.sub(d, a);
      const a0 = Fp4.sqrt(d);
      const candidateSqrt = Fp22.create({ c0: a0, c1: Fp4.div(Fp4.mul(c1, Fpdiv2), a0) });
      if (!Fp22.eql(Fp22.sqr(candidateSqrt), num))
        throw new Error("Cannot find square root");
      const x1 = candidateSqrt;
      const x2 = Fp22.neg(x1);
      const { re: re1, im: im1 } = Fp22.reim(x1);
      const { re: re2, im: im2 } = Fp22.reim(x2);
      if (im1 > im2 || im1 === im2 && re1 > re2)
        return x1;
      return x2;
    },
    // Same as sgn0_m_eq_2 in RFC 9380
    isOdd: (x) => {
      const { re: x0, im: x1 } = Fp22.reim(x);
      const sign_0 = x0 % _2n2;
      const zero_0 = x0 === _0n2;
      const sign_1 = x1 % _2n2;
      return BigInt(sign_0 || zero_0 && sign_1) == _1n2;
    },
    // Bytes util
    fromBytes(b) {
      if (b.length !== Fp22.BYTES)
        throw new Error("fromBytes invalid length=" + b.length);
      return { c0: Fp4.fromBytes(b.subarray(0, Fp4.BYTES)), c1: Fp4.fromBytes(b.subarray(Fp4.BYTES)) };
    },
    toBytes: ({ c0, c1 }) => concatBytes2(Fp4.toBytes(c0), Fp4.toBytes(c1)),
    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({
      c0: Fp4.cmov(c0, r0, c),
      c1: Fp4.cmov(c1, r1, c)
    }),
    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),
    // multiply by u + 1
    mulByNonresidue: ({ c0, c1 }) => Fp22.mul({ c0, c1 }, Fp2Nonresidue),
    mulByB: opts.Fp2mulByB,
    fromBigTuple: Fp2fromBigTuple,
    frobeniusMap: ({ c0, c1 }, power) => ({
      c0,
      c1: Fp4.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2])
    })
  };
  const Fp6Add = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({
    c0: Fp22.add(c0, r0),
    c1: Fp22.add(c1, r1),
    c2: Fp22.add(c2, r2)
  });
  const Fp6Subtract = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({
    c0: Fp22.sub(c0, r0),
    c1: Fp22.sub(c1, r1),
    c2: Fp22.sub(c2, r2)
  });
  const Fp6Multiply = ({ c0, c1, c2 }, rhs) => {
    if (typeof rhs === "bigint") {
      return {
        c0: Fp22.mul(c0, rhs),
        c1: Fp22.mul(c1, rhs),
        c2: Fp22.mul(c2, rhs)
      };
    }
    const { c0: r0, c1: r1, c2: r2 } = rhs;
    const t0 = Fp22.mul(c0, r0);
    const t1 = Fp22.mul(c1, r1);
    const t2 = Fp22.mul(c2, r2);
    return {
      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)
      c0: Fp22.add(t0, Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c2), Fp22.add(r1, r2)), Fp22.add(t1, t2)))),
      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)
      c1: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c1), Fp22.add(r0, r1)), Fp22.add(t0, t1)), Fp22.mulByNonresidue(t2)),
      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2
      c2: Fp22.sub(Fp22.add(t1, Fp22.mul(Fp22.add(c0, c2), Fp22.add(r0, r2))), Fp22.add(t0, t2))
    };
  };
  const Fp6Square = ({ c0, c1, c2 }) => {
    let t0 = Fp22.sqr(c0);
    let t1 = Fp22.mul(Fp22.mul(c0, c1), _2n2);
    let t3 = Fp22.mul(Fp22.mul(c1, c2), _2n2);
    let t4 = Fp22.sqr(c2);
    return {
      c0: Fp22.add(Fp22.mulByNonresidue(t3), t0),
      // T3 * (u + 1) + T0
      c1: Fp22.add(Fp22.mulByNonresidue(t4), t1),
      // T4 * (u + 1) + T1
      // T1 + (c0 - c1 + c2)² + T3 - T0 - T4
      c2: Fp22.sub(Fp22.sub(Fp22.add(Fp22.add(t1, Fp22.sqr(Fp22.add(Fp22.sub(c0, c1), c2))), t3), t0), t4)
    };
  };
  const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(Fp22, Fp2Nonresidue, Fp4.ORDER, 6, 2, 3);
  const Fp62 = {
    ORDER: Fp22.ORDER,
    // TODO: unused, but need to verify
    isLE: Fp22.isLE,
    BITS: 3 * Fp22.BITS,
    BYTES: 3 * Fp22.BYTES,
    MASK: bitMask(3 * Fp22.BITS),
    ZERO: { c0: Fp22.ZERO, c1: Fp22.ZERO, c2: Fp22.ZERO },
    ONE: { c0: Fp22.ONE, c1: Fp22.ZERO, c2: Fp22.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1, c2 }) => Fp22.isValid(c0) && Fp22.isValid(c1) && Fp22.isValid(c2),
    is0: ({ c0, c1, c2 }) => Fp22.is0(c0) && Fp22.is0(c1) && Fp22.is0(c2),
    neg: ({ c0, c1, c2 }) => ({ c0: Fp22.neg(c0), c1: Fp22.neg(c1), c2: Fp22.neg(c2) }),
    eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => Fp22.eql(c0, r0) && Fp22.eql(c1, r1) && Fp22.eql(c2, r2),
    sqrt: notImplemented,
    // Do we need division by bigint at all? Should be done via order:
    div: (lhs, rhs) => Fp62.mul(lhs, typeof rhs === "bigint" ? Fp4.inv(Fp4.create(rhs)) : Fp62.inv(rhs)),
    pow: (num, power) => FpPow(Fp62, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp62, nums),
    // Normalized
    add: Fp6Add,
    sub: Fp6Subtract,
    mul: Fp6Multiply,
    sqr: Fp6Square,
    // NonNormalized stuff
    addN: Fp6Add,
    subN: Fp6Subtract,
    mulN: Fp6Multiply,
    sqrN: Fp6Square,
    inv: ({ c0, c1, c2 }) => {
      let t0 = Fp22.sub(Fp22.sqr(c0), Fp22.mulByNonresidue(Fp22.mul(c2, c1)));
      let t1 = Fp22.sub(Fp22.mulByNonresidue(Fp22.sqr(c2)), Fp22.mul(c0, c1));
      let t2 = Fp22.sub(Fp22.sqr(c1), Fp22.mul(c0, c2));
      let t4 = Fp22.inv(Fp22.add(Fp22.mulByNonresidue(Fp22.add(Fp22.mul(c2, t1), Fp22.mul(c1, t2))), Fp22.mul(c0, t0)));
      return { c0: Fp22.mul(t4, t0), c1: Fp22.mul(t4, t1), c2: Fp22.mul(t4, t2) };
    },
    // Bytes utils
    fromBytes: (b) => {
      if (b.length !== Fp62.BYTES)
        throw new Error("fromBytes invalid length=" + b.length);
      return {
        c0: Fp22.fromBytes(b.subarray(0, Fp22.BYTES)),
        c1: Fp22.fromBytes(b.subarray(Fp22.BYTES, 2 * Fp22.BYTES)),
        c2: Fp22.fromBytes(b.subarray(2 * Fp22.BYTES))
      };
    },
    toBytes: ({ c0, c1, c2 }) => concatBytes2(Fp22.toBytes(c0), Fp22.toBytes(c1), Fp22.toBytes(c2)),
    cmov: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }, c) => ({
      c0: Fp22.cmov(c0, r0, c),
      c1: Fp22.cmov(c1, r1, c),
      c2: Fp22.cmov(c2, r2, c)
    }),
    fromBigSix: (t) => {
      if (!Array.isArray(t) || t.length !== 6)
        throw new Error("invalid Fp6 usage");
      return {
        c0: Fp22.fromBigTuple(t.slice(0, 2)),
        c1: Fp22.fromBigTuple(t.slice(2, 4)),
        c2: Fp22.fromBigTuple(t.slice(4, 6))
      };
    },
    frobeniusMap: ({ c0, c1, c2 }, power) => ({
      c0: Fp22.frobeniusMap(c0, power),
      c1: Fp22.mul(Fp22.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),
      c2: Fp22.mul(Fp22.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6])
    }),
    mulByFp2: ({ c0, c1, c2 }, rhs) => ({
      c0: Fp22.mul(c0, rhs),
      c1: Fp22.mul(c1, rhs),
      c2: Fp22.mul(c2, rhs)
    }),
    mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp22.mulByNonresidue(c2), c1: c0, c2: c1 }),
    // Sparse multiplication
    mul1: ({ c0, c1, c2 }, b1) => ({
      c0: Fp22.mulByNonresidue(Fp22.mul(c2, b1)),
      c1: Fp22.mul(c0, b1),
      c2: Fp22.mul(c1, b1)
    }),
    // Sparse multiplication
    mul01({ c0, c1, c2 }, b0, b1) {
      let t0 = Fp22.mul(c0, b0);
      let t1 = Fp22.mul(c1, b1);
      return {
        // ((c1 + c2) * b1 - T1) * (u + 1) + T0
        c0: Fp22.add(Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c2), b1), t1)), t0),
        // (b0 + b1) * (c0 + c1) - T0 - T1
        c1: Fp22.sub(Fp22.sub(Fp22.mul(Fp22.add(b0, b1), Fp22.add(c0, c1)), t0), t1),
        // (c0 + c2) * b0 - T0 + T1
        c2: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c2), b0), t0), t1)
      };
    }
  };
  const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp22, Fp2Nonresidue, Fp4.ORDER, 12, 1, 6)[0];
  const Fp12Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp62.add(c0, r0),
    c1: Fp62.add(c1, r1)
  });
  const Fp12Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp62.sub(c0, r0),
    c1: Fp62.sub(c1, r1)
  });
  const Fp12Multiply = ({ c0, c1 }, rhs) => {
    if (typeof rhs === "bigint")
      return { c0: Fp62.mul(c0, rhs), c1: Fp62.mul(c1, rhs) };
    let { c0: r0, c1: r1 } = rhs;
    let t1 = Fp62.mul(c0, r0);
    let t2 = Fp62.mul(c1, r1);
    return {
      c0: Fp62.add(t1, Fp62.mulByNonresidue(t2)),
      // T1 + T2 * v
      // (c0 + c1) * (r0 + r1) - (T1 + T2)
      c1: Fp62.sub(Fp62.mul(Fp62.add(c0, c1), Fp62.add(r0, r1)), Fp62.add(t1, t2))
    };
  };
  const Fp12Square = ({ c0, c1 }) => {
    let ab = Fp62.mul(c0, c1);
    return {
      // (c1 * v + c0) * (c0 + c1) - AB - AB * v
      c0: Fp62.sub(Fp62.sub(Fp62.mul(Fp62.add(Fp62.mulByNonresidue(c1), c0), Fp62.add(c0, c1)), ab), Fp62.mulByNonresidue(ab)),
      c1: Fp62.add(ab, ab)
    };
  };
  function Fp4Square2(a, b) {
    const a2 = Fp22.sqr(a);
    const b2 = Fp22.sqr(b);
    return {
      first: Fp22.add(Fp22.mulByNonresidue(b2), a2),
      // b² * Nonresidue + a²
      second: Fp22.sub(Fp22.sub(Fp22.sqr(Fp22.add(a, b)), a2), b2)
      // (a + b)² - a² - b²
    };
  }
  const Fp122 = {
    ORDER: Fp22.ORDER,
    // TODO: unused, but need to verify
    isLE: Fp62.isLE,
    BITS: 2 * Fp62.BITS,
    BYTES: 2 * Fp62.BYTES,
    MASK: bitMask(2 * Fp62.BITS),
    ZERO: { c0: Fp62.ZERO, c1: Fp62.ZERO },
    ONE: { c0: Fp62.ONE, c1: Fp62.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1 }) => Fp62.isValid(c0) && Fp62.isValid(c1),
    is0: ({ c0, c1 }) => Fp62.is0(c0) && Fp62.is0(c1),
    neg: ({ c0, c1 }) => ({ c0: Fp62.neg(c0), c1: Fp62.neg(c1) }),
    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp62.eql(c0, r0) && Fp62.eql(c1, r1),
    sqrt: notImplemented,
    inv: ({ c0, c1 }) => {
      let t = Fp62.inv(Fp62.sub(Fp62.sqr(c0), Fp62.mulByNonresidue(Fp62.sqr(c1))));
      return { c0: Fp62.mul(c0, t), c1: Fp62.neg(Fp62.mul(c1, t)) };
    },
    div: (lhs, rhs) => Fp122.mul(lhs, typeof rhs === "bigint" ? Fp4.inv(Fp4.create(rhs)) : Fp122.inv(rhs)),
    pow: (num, power) => FpPow(Fp122, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp122, nums),
    // Normalized
    add: Fp12Add,
    sub: Fp12Subtract,
    mul: Fp12Multiply,
    sqr: Fp12Square,
    // NonNormalized stuff
    addN: Fp12Add,
    subN: Fp12Subtract,
    mulN: Fp12Multiply,
    sqrN: Fp12Square,
    // Bytes utils
    fromBytes: (b) => {
      if (b.length !== Fp122.BYTES)
        throw new Error("fromBytes invalid length=" + b.length);
      return {
        c0: Fp62.fromBytes(b.subarray(0, Fp62.BYTES)),
        c1: Fp62.fromBytes(b.subarray(Fp62.BYTES))
      };
    },
    toBytes: ({ c0, c1 }) => concatBytes2(Fp62.toBytes(c0), Fp62.toBytes(c1)),
    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({
      c0: Fp62.cmov(c0, r0, c),
      c1: Fp62.cmov(c1, r1, c)
    }),
    // Utils
    // toString() {
    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');
    // },
    // fromTuple(c: [Fp6, Fp6]) {
    //   return new Fp12(...c);
    // }
    fromBigTwelve: (t) => ({
      c0: Fp62.fromBigSix(t.slice(0, 6)),
      c1: Fp62.fromBigSix(t.slice(6, 12))
    }),
    // Raises to q**i -th power
    frobeniusMap(lhs, power) {
      const { c0, c1, c2 } = Fp62.frobeniusMap(lhs.c1, power);
      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];
      return {
        c0: Fp62.frobeniusMap(lhs.c0, power),
        c1: Fp62.create({
          c0: Fp22.mul(c0, coeff),
          c1: Fp22.mul(c1, coeff),
          c2: Fp22.mul(c2, coeff)
        })
      };
    },
    mulByFp2: ({ c0, c1 }, rhs) => ({
      c0: Fp62.mulByFp2(c0, rhs),
      c1: Fp62.mulByFp2(c1, rhs)
    }),
    conjugate: ({ c0, c1 }) => ({ c0, c1: Fp62.neg(c1) }),
    // Sparse multiplication
    mul014: ({ c0, c1 }, o0, o1, o4) => {
      let t0 = Fp62.mul01(c0, o0, o1);
      let t1 = Fp62.mul1(c1, o4);
      return {
        c0: Fp62.add(Fp62.mulByNonresidue(t1), t0),
        // T1 * v + T0
        // (c1 + c0) * [o0, o1+o4] - T0 - T1
        c1: Fp62.sub(Fp62.sub(Fp62.mul01(Fp62.add(c1, c0), o0, Fp22.add(o1, o4)), t0), t1)
      };
    },
    mul034: ({ c0, c1 }, o0, o3, o4) => {
      const a = Fp62.create({
        c0: Fp22.mul(c0.c0, o0),
        c1: Fp22.mul(c0.c1, o0),
        c2: Fp22.mul(c0.c2, o0)
      });
      const b = Fp62.mul01(c1, o3, o4);
      const e = Fp62.mul01(Fp62.add(c0, c1), Fp22.add(o0, o3), o4);
      return {
        c0: Fp62.add(Fp62.mulByNonresidue(b), a),
        c1: Fp62.sub(e, Fp62.add(a, b))
      };
    },
    // A cyclotomic group is a subgroup of Fp^n defined by
    //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}
    // The result of any pairing is in a cyclotomic subgroup
    // https://eprint.iacr.org/2009/565.pdf
    _cyclotomicSquare: opts.Fp12cyclotomicSquare,
    _cyclotomicExp: opts.Fp12cyclotomicExp,
    // https://eprint.iacr.org/2010/354.pdf
    // https://eprint.iacr.org/2009/565.pdf
    finalExponentiate: opts.Fp12finalExponentiate
  };
  return { Fp: Fp4, Fp2: Fp22, Fp6: Fp62, Fp4Square: Fp4Square2, Fp12: Fp122 };
}

// node_modules/viem/node_modules/@noble/curves/esm/bls12-381.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n3 = BigInt(3);
var _4n = BigInt(4);
var BLS_X = BigInt("0xd201000000010000");
var BLS_X_LEN = bitLen(BLS_X);
var { Fp, Fp2, Fp6, Fp4Square, Fp12 } = tower12({
  // Order of Fp
  ORDER: BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"),
  // Finite extension field over irreducible polynominal.
  // Fp(u) / (u² - β) where β = -1
  FP2_NONRESIDUE: [_1n3, _1n3],
  Fp2mulByB: ({ c0, c1 }) => {
    const t0 = Fp.mul(c0, _4n);
    const t1 = Fp.mul(c1, _4n);
    return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };
  },
  // Fp12
  // A cyclotomic group is a subgroup of Fp^n defined by
  //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}
  // The result of any pairing is in a cyclotomic subgroup
  // https://eprint.iacr.org/2009/565.pdf
  Fp12cyclotomicSquare: ({ c0, c1 }) => {
    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;
    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;
    const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);
    const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);
    const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);
    const t9 = Fp2.mulByNonresidue(t8);
    return {
      c0: Fp6.create({
        c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n3), t3),
        // 2 * (T3 - c0c0)  + T3
        c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n3), t5),
        // 2 * (T5 - c0c1)  + T5
        c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n3), t7)
      }),
      // 2 * (T7 - c0c2)  + T7
      c1: Fp6.create({
        c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n3), t9),
        // 2 * (T9 + c1c0) + T9
        c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n3), t4),
        // 2 * (T4 + c1c1) + T4
        c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n3), t6)
      })
    };
  },
  Fp12cyclotomicExp(num, n) {
    let z = Fp12.ONE;
    for (let i = BLS_X_LEN - 1; i >= 0; i--) {
      z = Fp12._cyclotomicSquare(z);
      if (bitGet(n, i))
        z = Fp12.mul(z, num);
    }
    return z;
  },
  // https://eprint.iacr.org/2010/354.pdf
  // https://eprint.iacr.org/2009/565.pdf
  Fp12finalExponentiate: (num) => {
    const x = BLS_X;
    const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);
    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);
    const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));
    const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);
    const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));
    const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));
    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));
    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));
    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);
    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);
    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);
    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);
    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);
  }
});
var Fr = Field(BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001"));
var isogenyMapG2 = isogenyMap(Fp2, [
  // xNum
  [
    [
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6",
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"
    ],
    [
      "0x0",
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"
    ],
    [
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e",
      "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"
    ],
    [
      "0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1",
      "0x0"
    ]
  ],
  // xDen
  [
    [
      "0x0",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"
    ],
    [
      "0xc",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"
    ],
    ["0x1", "0x0"]
    // LAST 1
  ],
  // yNum
  [
    [
      "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706",
      "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"
    ],
    [
      "0x0",
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"
    ],
    [
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c",
      "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"
    ],
    [
      "0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10",
      "0x0"
    ]
  ],
  // yDen
  [
    [
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"
    ],
    [
      "0x0",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"
    ],
    [
      "0x12",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"
    ],
    ["0x1", "0x0"]
    // LAST 1
  ]
].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))));
var isogenyMapG1 = isogenyMap(Fp, [
  // xNum
  [
    "0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7",
    "0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb",
    "0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0",
    "0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861",
    "0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9",
    "0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983",
    "0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84",
    "0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e",
    "0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317",
    "0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e",
    "0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b",
    "0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"
  ],
  // xDen
  [
    "0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c",
    "0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff",
    "0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19",
    "0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8",
    "0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e",
    "0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5",
    "0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a",
    "0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e",
    "0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641",
    "0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a",
    "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33",
    "0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696",
    "0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6",
    "0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb",
    "0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb",
    "0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0",
    "0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2",
    "0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29",
    "0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587",
    "0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30",
    "0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132",
    "0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e",
    "0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8",
    "0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133",
    "0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b",
    "0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"
  ],
  // yDen
  [
    "0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1",
    "0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d",
    "0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2",
    "0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416",
    "0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d",
    "0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac",
    "0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c",
    "0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9",
    "0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a",
    "0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55",
    "0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8",
    "0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092",
    "0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc",
    "0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7",
    "0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f",
    "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j))));
var G2_SWU = mapToCurveSimpleSWU(Fp2, {
  A: Fp2.create({ c0: Fp.create(_0n3), c1: Fp.create(BigInt(240)) }),
  // A' = 240 * I
  B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }),
  // B' = 1012 * (1 + I)
  Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) })
  // Z: -(2 + I)
});
var G1_SWU = mapToCurveSimpleSWU(Fp, {
  A: Fp.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")),
  B: Fp.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")),
  Z: Fp.create(BigInt(11))
});
var { G2psi, G2psi2 } = psiFrobenius(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE));
var htfDefaults = Object.freeze({
  // DST: a domain separation tag
  // defined in section 2.2.5
  // Use utils.getDSTLabel(), utils.setDSTLabel(value)
  DST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
  encodeDST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
  // p: the characteristic of F
  //    where F is a finite field of characteristic p and order q = p^m
  p: Fp.ORDER,
  // m: the extension degree of F, m >= 1
  //     where F is a finite field of characteristic p and order q = p^m
  m: 2,
  // k: the target security level for the suite in bits
  // defined in section 5.1
  k: 128,
  // option to use a message that has already been processed by
  // expand_message_xmd
  expand: "xmd",
  // Hash functions for: expand_message_xmd is appropriate for use with a
  // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.
  // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247
  hash: sha256
});
var COMPRESSED_ZERO = setMask(Fp.toBytes(_0n3), { infinity: true, compressed: true });
function parseMask(bytes) {
  bytes = bytes.slice();
  const mask2 = bytes[0] & 224;
  const compressed = !!(mask2 >> 7 & 1);
  const infinity = !!(mask2 >> 6 & 1);
  const sort = !!(mask2 >> 5 & 1);
  bytes[0] &= 31;
  return { compressed, infinity, sort, value: bytes };
}
function setMask(bytes, mask2) {
  if (bytes[0] & 224)
    throw new Error("setMask: non-empty mask");
  if (mask2.compressed)
    bytes[0] |= 128;
  if (mask2.infinity)
    bytes[0] |= 64;
  if (mask2.sort)
    bytes[0] |= 32;
  return bytes;
}
function signatureG1ToRawBytes(point) {
  point.assertValidity();
  const isZero = point.equals(bls12_381.G1.ProjectivePoint.ZERO);
  const { x, y } = point.toAffine();
  if (isZero)
    return COMPRESSED_ZERO.slice();
  const P = Fp.ORDER;
  const sort = Boolean(y * _2n3 / P);
  return setMask(numberToBytesBE(x, Fp.BYTES), { compressed: true, sort });
}
function signatureG2ToRawBytes(point) {
  point.assertValidity();
  const len = Fp.BYTES;
  if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))
    return concatBytes2(COMPRESSED_ZERO, numberToBytesBE(_0n3, len));
  const { x, y } = point.toAffine();
  const { re: x0, im: x1 } = Fp2.reim(x);
  const { re: y0, im: y1 } = Fp2.reim(y);
  const tmp = y1 > _0n3 ? y1 * _2n3 : y0 * _2n3;
  const sort = Boolean(tmp / Fp.ORDER & _1n3);
  const z2 = x0;
  return concatBytes2(setMask(numberToBytesBE(x1, len), { sort, compressed: true }), numberToBytesBE(z2, len));
}
var bls12_381 = bls({
  // Fields
  fields: {
    Fp,
    Fp2,
    Fp6,
    Fp12,
    Fr
  },
  // G1 is the order-q subgroup of E1(Fp) : y² = x³ + 4, #E1(Fp) = h1q, where
  // characteristic; z + (z⁴ - z² + 1)(z - 1)²/3
  G1: {
    Fp,
    // cofactor; (z - 1)²/3
    h: BigInt("0x396c8c005555e1568c00aaab0000aaab"),
    // generator's coordinates
    // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507
    // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569
    Gx: BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"),
    Gy: BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1"),
    a: Fp.ZERO,
    b: _4n,
    htfDefaults: { ...htfDefaults, m: 1, DST: "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_" },
    wrapPrivateKey: true,
    allowInfinityPoint: true,
    // Checks is the point resides in prime-order subgroup.
    // point.isTorsionFree() should return true for valid points
    // It returns false for shitty points.
    // https://eprint.iacr.org/2021/1130.pdf
    isTorsionFree: (c, point) => {
      const beta = BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe");
      const phi = new c(Fp.mul(point.px, beta), point.py, point.pz);
      const xP = point.multiplyUnsafe(BLS_X).negate();
      const u2P = xP.multiplyUnsafe(BLS_X);
      return u2P.equals(phi);
    },
    // Clear cofactor of G1
    // https://eprint.iacr.org/2019/403
    clearCofactor: (_c, point) => {
      return point.multiplyUnsafe(BLS_X).add(point);
    },
    mapToCurve: (scalars) => {
      const { x, y } = G1_SWU(Fp.create(scalars[0]));
      return isogenyMapG1(x, y);
    },
    fromBytes: (bytes) => {
      const { compressed, infinity, sort, value } = parseMask(bytes);
      if (value.length === 48 && compressed) {
        const P = Fp.ORDER;
        const compressedValue = bytesToNumberBE(value);
        const x = Fp.create(compressedValue & Fp.MASK);
        if (infinity) {
          if (x !== _0n3)
            throw new Error("G1: non-empty compressed point at infinity");
          return { x: _0n3, y: _0n3 };
        }
        const right = Fp.add(Fp.pow(x, _3n3), Fp.create(bls12_381.params.G1b));
        let y = Fp.sqrt(right);
        if (!y)
          throw new Error("invalid compressed G1 point");
        if (y * _2n3 / P !== BigInt(sort))
          y = Fp.neg(y);
        return { x: Fp.create(x), y: Fp.create(y) };
      } else if (value.length === 96 && !compressed) {
        const x = bytesToNumberBE(value.subarray(0, Fp.BYTES));
        const y = bytesToNumberBE(value.subarray(Fp.BYTES));
        if (infinity) {
          if (x !== _0n3 || y !== _0n3)
            throw new Error("G1: non-empty point at infinity");
          return bls12_381.G1.ProjectivePoint.ZERO.toAffine();
        }
        return { x: Fp.create(x), y: Fp.create(y) };
      } else {
        throw new Error("invalid point G1, expected 48/96 bytes");
      }
    },
    toBytes: (c, point, isCompressed) => {
      const isZero = point.equals(c.ZERO);
      const { x, y } = point.toAffine();
      if (isCompressed) {
        if (isZero)
          return COMPRESSED_ZERO.slice();
        const P = Fp.ORDER;
        const sort = Boolean(y * _2n3 / P);
        return setMask(numberToBytesBE(x, Fp.BYTES), { compressed: true, sort });
      } else {
        if (isZero) {
          const x2 = concatBytes2(new Uint8Array([64]), new Uint8Array(2 * Fp.BYTES - 1));
          return x2;
        } else {
          return concatBytes2(numberToBytesBE(x, Fp.BYTES), numberToBytesBE(y, Fp.BYTES));
        }
      }
    },
    ShortSignature: {
      fromHex(hex) {
        const { infinity, sort, value } = parseMask(ensureBytes("signatureHex", hex, 48));
        const P = Fp.ORDER;
        const compressedValue = bytesToNumberBE(value);
        if (infinity)
          return bls12_381.G1.ProjectivePoint.ZERO;
        const x = Fp.create(compressedValue & Fp.MASK);
        const right = Fp.add(Fp.pow(x, _3n3), Fp.create(bls12_381.params.G1b));
        let y = Fp.sqrt(right);
        if (!y)
          throw new Error("invalid compressed G1 point");
        const aflag = BigInt(sort);
        if (y * _2n3 / P !== aflag)
          y = Fp.neg(y);
        const point = bls12_381.G1.ProjectivePoint.fromAffine({ x, y });
        point.assertValidity();
        return point;
      },
      toRawBytes(point) {
        return signatureG1ToRawBytes(point);
      },
      toHex(point) {
        return bytesToHex(signatureG1ToRawBytes(point));
      }
    }
  },
  // G2 is the order-q subgroup of E2(Fp²) : y² = x³+4(1+√−1),
  // where Fp2 is Fp[√−1]/(x2+1). #E2(Fp2 ) = h2q, where
  // G² - 1
  // h2q
  G2: {
    Fp: Fp2,
    // cofactor
    h: BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"),
    Gx: Fp2.fromBigTuple([
      BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"),
      BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")
    ]),
    // y =
    // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,
    // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905
    Gy: Fp2.fromBigTuple([
      BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"),
      BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")
    ]),
    a: Fp2.ZERO,
    b: Fp2.fromBigTuple([_4n, _4n]),
    hEff: BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"),
    htfDefaults: { ...htfDefaults },
    wrapPrivateKey: true,
    allowInfinityPoint: true,
    mapToCurve: (scalars) => {
      const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars));
      return isogenyMapG2(x, y);
    },
    // Checks is the point resides in prime-order subgroup.
    // point.isTorsionFree() should return true for valid points
    // It returns false for shitty points.
    // https://eprint.iacr.org/2021/1130.pdf
    // Older version: https://eprint.iacr.org/2019/814.pdf
    isTorsionFree: (c, P) => {
      return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P));
    },
    // Maps the point into the prime-order subgroup G2.
    // clear_cofactor_bls12381_g2 from RFC 9380.
    // https://eprint.iacr.org/2017/419.pdf
    // prettier-ignore
    clearCofactor: (c, P) => {
      const x = BLS_X;
      let t1 = P.multiplyUnsafe(x).negate();
      let t2 = G2psi(c, P);
      let t3 = P.double();
      t3 = G2psi2(c, t3);
      t3 = t3.subtract(t2);
      t2 = t1.add(t2);
      t2 = t2.multiplyUnsafe(x).negate();
      t3 = t3.add(t2);
      t3 = t3.subtract(t1);
      const Q = t3.subtract(P);
      return Q;
    },
    fromBytes: (bytes) => {
      const { compressed, infinity, sort, value } = parseMask(bytes);
      if (!compressed && !infinity && sort || // 00100000
      !compressed && infinity && sort || // 01100000
      sort && infinity && compressed) {
        throw new Error("invalid encoding flag: " + (bytes[0] & 224));
      }
      const L = Fp.BYTES;
      const slc = (b, from23, to2) => bytesToNumberBE(b.slice(from23, to2));
      if (value.length === 96 && compressed) {
        const b = bls12_381.params.G2b;
        const P = Fp.ORDER;
        if (infinity) {
          if (value.reduce((p, c) => p !== 0 ? c + 1 : c, 0) > 0) {
            throw new Error("invalid compressed G2 point");
          }
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        }
        const x_1 = slc(value, 0, L);
        const x_0 = slc(value, L, 2 * L);
        const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });
        const right = Fp2.add(Fp2.pow(x, _3n3), b);
        let y = Fp2.sqrt(right);
        const Y_bit = y.c1 === _0n3 ? y.c0 * _2n3 / P : y.c1 * _2n3 / P ? _1n3 : _0n3;
        y = sort && Y_bit > 0 ? y : Fp2.neg(y);
        return { x, y };
      } else if (value.length === 192 && !compressed) {
        if (infinity) {
          if (value.reduce((p, c) => p !== 0 ? c + 1 : c, 0) > 0) {
            throw new Error("invalid uncompressed G2 point");
          }
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        }
        const x1 = slc(value, 0, L);
        const x0 = slc(value, L, 2 * L);
        const y1 = slc(value, 2 * L, 3 * L);
        const y0 = slc(value, 3 * L, 4 * L);
        return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };
      } else {
        throw new Error("invalid point G2, expected 96/192 bytes");
      }
    },
    toBytes: (c, point, isCompressed) => {
      const { BYTES: len, ORDER: P } = Fp;
      const isZero = point.equals(c.ZERO);
      const { x, y } = point.toAffine();
      if (isCompressed) {
        if (isZero)
          return concatBytes2(COMPRESSED_ZERO, numberToBytesBE(_0n3, len));
        const flag = Boolean(y.c1 === _0n3 ? y.c0 * _2n3 / P : y.c1 * _2n3 / P);
        return concatBytes2(setMask(numberToBytesBE(x.c1, len), { compressed: true, sort: flag }), numberToBytesBE(x.c0, len));
      } else {
        if (isZero)
          return concatBytes2(new Uint8Array([64]), new Uint8Array(4 * len - 1));
        const { re: x0, im: x1 } = Fp2.reim(x);
        const { re: y0, im: y1 } = Fp2.reim(y);
        return concatBytes2(numberToBytesBE(x1, len), numberToBytesBE(x0, len), numberToBytesBE(y1, len), numberToBytesBE(y0, len));
      }
    },
    Signature: {
      // TODO: Optimize, it's very slow because of sqrt.
      fromHex(hex) {
        const { infinity, sort, value } = parseMask(ensureBytes("signatureHex", hex));
        const P = Fp.ORDER;
        const half = value.length / 2;
        if (half !== 48 && half !== 96)
          throw new Error("invalid compressed signature length, must be 96 or 192");
        const z1 = bytesToNumberBE(value.slice(0, half));
        const z2 = bytesToNumberBE(value.slice(half));
        if (infinity)
          return bls12_381.G2.ProjectivePoint.ZERO;
        const x1 = Fp.create(z1 & Fp.MASK);
        const x2 = Fp.create(z2);
        const x = Fp2.create({ c0: x2, c1: x1 });
        const y2 = Fp2.add(Fp2.pow(x, _3n3), bls12_381.params.G2b);
        let y = Fp2.sqrt(y2);
        if (!y)
          throw new Error("Failed to find a square root");
        const { re: y0, im: y1 } = Fp2.reim(y);
        const aflag1 = BigInt(sort);
        const isGreater = y1 > _0n3 && y1 * _2n3 / P !== aflag1;
        const isZero = y1 === _0n3 && y0 * _2n3 / P !== aflag1;
        if (isGreater || isZero)
          y = Fp2.neg(y);
        const point = bls12_381.G2.ProjectivePoint.fromAffine({ x, y });
        point.assertValidity();
        return point;
      },
      toRawBytes(point) {
        return signatureG2ToRawBytes(point);
      },
      toHex(point) {
        return bytesToHex(signatureG2ToRawBytes(point));
      }
    }
  },
  params: {
    ateLoopSize: BLS_X,
    // The BLS parameter x for BLS12-381
    r: Fr.ORDER,
    // order; z⁴ − z² + 1; CURVE.n from other curves
    xNegative: true,
    twistType: "multiplicative"
  },
  htfDefaults,
  hash: sha256,
  randomBytes
});

// node_modules/viem/node_modules/ox/_esm/core/Bls.js
var noble = bls12_381;
function aggregate(points) {
  var _a;
  const group = typeof ((_a = points[0]) == null ? void 0 : _a.x) === "bigint" ? bls12_381.G1 : bls12_381.G2;
  const point = points.reduce((acc, point2) => acc.add(new group.ProjectivePoint(point2.x, point2.y, point2.z)), group.ProjectivePoint.ZERO);
  return {
    x: point.px,
    y: point.py,
    z: point.pz
  };
}
function createKeyPair(options = {}) {
  const { as = "Hex", size: size5 = "short-key:long-sig" } = options;
  const privateKey = randomPrivateKey({ as });
  const publicKey = getPublicKey2({ privateKey, size: size5 });
  return {
    privateKey,
    publicKey
  };
}
function getPublicKey2(options) {
  const { privateKey, size: size5 = "short-key:long-sig" } = options;
  const group = size5 === "short-key:long-sig" ? bls12_381.G1 : bls12_381.G2;
  const { px, py, pz } = group.ProjectivePoint.fromPrivateKey(from2(privateKey).slice(2));
  return { x: px, y: py, z: pz };
}
function randomPrivateKey(options = {}) {
  const { as = "Hex" } = options;
  const bytes = bls12_381.utils.randomPrivateKey();
  if (as === "Hex")
    return fromBytes(bytes);
  return bytes;
}
function sign(options) {
  const { payload, privateKey, suite, size: size5 = "short-key:long-sig" } = options;
  const payloadGroup = size5 === "short-key:long-sig" ? bls12_381.G2 : bls12_381.G1;
  const payloadPoint = payloadGroup.hashToCurve(from(payload), suite ? { DST: fromString(suite) } : void 0);
  const privateKeyGroup = size5 === "short-key:long-sig" ? bls12_381.G1 : bls12_381.G2;
  const signature = payloadPoint.multiply(privateKeyGroup.normPrivateKeyToScalar(privateKey.slice(2)));
  return {
    x: signature.px,
    y: signature.py,
    z: signature.pz
  };
}
function verify(options) {
  const { payload, suite } = options;
  const publicKey = options.publicKey;
  const signature = options.signature;
  const isShortSig = typeof signature.x === "bigint";
  const group = isShortSig ? bls12_381.G1 : bls12_381.G2;
  const payloadPoint = group.hashToCurve(from(payload), suite ? { DST: fromString(suite) } : void 0);
  const shortSigPairing = () => bls12_381.pairingBatch([
    {
      g1: payloadPoint,
      g2: new bls12_381.G2.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z)
    },
    {
      g1: new bls12_381.G1.ProjectivePoint(signature.x, signature.y, signature.z),
      g2: bls12_381.G2.ProjectivePoint.BASE.negate()
    }
  ]);
  const longSigPairing = () => bls12_381.pairingBatch([
    {
      g1: new bls12_381.G1.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z).negate(),
      g2: payloadPoint
    },
    {
      g1: bls12_381.G1.ProjectivePoint.BASE,
      g2: new bls12_381.G2.ProjectivePoint(signature.x, signature.y, signature.z)
    }
  ]);
  return bls12_381.fields.Fp12.eql(isShortSig ? shortSigPairing() : longSigPairing(), bls12_381.fields.Fp12.ONE);
}

// node_modules/viem/node_modules/ox/_esm/core/BlsPoint.js
var BlsPoint_exports = {};
__export(BlsPoint_exports, {
  fromBytes: () => fromBytes4,
  fromHex: () => fromHex4,
  toBytes: () => toBytes5,
  toHex: () => toHex5
});
function toBytes5(point) {
  const group = typeof point.z === "bigint" ? bls12_381.G1 : bls12_381.G2;
  return new group.ProjectivePoint(point.x, point.y, point.z).toRawBytes();
}
function toHex5(point) {
  return fromBytes(toBytes5(point));
}
function fromBytes4(bytes) {
  const group = bytes.length === 48 ? bls12_381.G1 : bls12_381.G2;
  const point = group.ProjectivePoint.fromHex(bytes);
  return {
    x: point.px,
    y: point.py,
    z: point.pz
  };
}
function fromHex4(hex, group) {
  return fromBytes4(toBytes(hex), group);
}

// node_modules/viem/node_modules/ox/_esm/core/ContractAddress.js
var ContractAddress_exports = {};
__export(ContractAddress_exports, {
  from: () => from12,
  fromCreate: () => fromCreate,
  fromCreate2: () => fromCreate2
});
function from12(options) {
  if (options.salt)
    return fromCreate2(options);
  return fromCreate(options);
}
function fromCreate(options) {
  const from23 = fromHex(from4(options.from));
  let nonce = fromNumber(options.nonce);
  if (nonce[0] === 0)
    nonce = new Uint8Array([]);
  return from4(`0x${keccak256(fromBytes2([from23, nonce], { as: "Hex" })).slice(26)}`);
}
function fromCreate2(options) {
  const from23 = fromHex(from4(options.from));
  const salt = padLeft(validate(options.salt) ? options.salt : fromHex(options.salt), 32);
  const bytecodeHash = (() => {
    if ("bytecodeHash" in options) {
      if (validate(options.bytecodeHash))
        return options.bytecodeHash;
      return fromHex(options.bytecodeHash);
    }
    return keccak256(options.bytecode, { as: "Bytes" });
  })();
  return from4(slice2(keccak256(concat(fromHex("0xff"), from23, salt, bytecodeHash), { as: "Hex" }), 12));
}

// node_modules/viem/node_modules/ox/_esm/core/Ed25519.js
var Ed25519_exports = {};
__export(Ed25519_exports, {
  createKeyPair: () => createKeyPair2,
  getPublicKey: () => getPublicKey3,
  noble: () => noble2,
  randomPrivateKey: () => randomPrivateKey2,
  sign: () => sign2,
  verify: () => verify2
});

// node_modules/viem/node_modules/@noble/curves/esm/abstract/edwards.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n4 = BigInt(2);
var _8n = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp4, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n4 << BigInt(nByteLength * 8) - _1n4;
  const modP = Fp4.create;
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  function isEdValidXY(x, y) {
    const x2 = Fp4.sqr(x);
    const y2 = Fp4.sqr(y);
    const left = Fp4.add(Fp4.mul(CURVE.a, x2), y2);
    const right = Fp4.add(Fp4.ONE, Fp4.mul(CURVE.d, Fp4.mul(x2, y2)));
    return Fp4.eql(left, right);
  }
  if (!isEdValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const uvRatio2 = CURVE.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp4.sqrt(u * Fp4.inv(v)) };
    } catch (e) {
      return { isValid: false, value: _0n4 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes) => bytes);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function aCoordinate(title, n, banZero = false) {
    const min = banZero ? _1n4 : _0n4;
    aInRange("coordinate " + title, n, min, MASK);
  }
  function aextpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { ex: x, ey: y, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n : Fp4.inv(z);
    const ax = modP(x * iz);
    const ay = modP(y * iz);
    const zz = modP(z * iz);
    if (is0)
      return { x: _0n4, y: _1n4 };
    if (zz !== _1n4)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z, et: T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point {
    constructor(ex, ey, ez, et) {
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez, true);
      aCoordinate("t", et);
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      aCoordinate("x", x);
      aCoordinate("y", y);
      return new Point(x, y, _1n4, modP(x * y));
    }
    static normalizeZ(points) {
      const toInv = FpInvertBatch(Fp4, points.map((p) => p.ez));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n4 * modP(Z1 * Z1));
      const D = modP(a * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G2 = D + B;
      const F = G2 - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a, d } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G2 = D + C;
      const H = modP(B - a * A);
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n = scalar;
      aInRange("scalar", n, _1n4, CURVE_ORDER);
      const { p, f } = this.wNAF(n);
      return Point.normalizeZ([p, f])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point.ZERO) {
      const n = scalar;
      aInRange("scalar", n, _0n4, CURVE_ORDER);
      if (n === _0n4)
        return I;
      if (this.is0() || n === _1n4)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n4)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d, a } = CURVE;
      const len = Fp4.BYTES;
      hex = ensureBytes("pointHex", hex, len);
      abool("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp4.ORDER;
      aInRange("pointHex.y", y, _0n4, max);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n4);
      const v = modP(d * y2 - a);
      let { isValid, value: x } = uvRatio2(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n4) === _1n4;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n4 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point.fromAffine({ x, y });
    }
    static fromPrivateKey(privKey) {
      const { scalar } = getPrivateScalar(privKey);
      return G.multiply(scalar);
    }
    toRawBytes() {
      const { x, y } = this.toAffine();
      const bytes = numberToBytesLE(y, Fp4.BYTES);
      bytes[bytes.length - 1] |= x & _1n4 ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n4, _1n4, _1n4, _0n4);
  const { BASE: G, ZERO: I } = Point;
  const wnaf = wNAF(Point, nByteLength * 8);
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function modN_LE(hash8) {
    return modN(bytesToNumberLE(hash8));
  }
  function getPrivateScalar(key) {
    const len = Fp4.BYTES;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(key) {
    const { head, prefix, scalar } = getPrivateScalar(key);
    const point = G.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey5(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign4(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r2 = hashDomainToScalar(options.context, prefix, msg);
    const R = G.multiply(r2).toRawBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN(r2 + k * scalar);
    aInRange("signature.s", s, _0n4, CURVE_ORDER);
    const res = concatBytes2(R, numberToBytesLE(s, Fp4.BYTES));
    return ensureBytes("result", res, Fp4.BYTES * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify4(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp4.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    publicKey = ensureBytes("publicKey", publicKey, len);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE(sig.slice(len, 2 * len));
    let A, R, SB;
    try {
      A = Point.fromHex(publicKey, zip215);
      R = Point.fromHex(sig.slice(0, len), zip215);
      SB = G.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
  }
  G._setWindowSize(8);
  const utils = {
    getExtendedPublicKey,
    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
    randomPrivateKey: () => randomBytes2(Fp4.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey: getPublicKey5,
    sign: sign4,
    verify: verify4,
    ExtendedPoint: Point,
    utils
  };
}

// node_modules/viem/node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n5 = BigInt(2);
function validateOpts2(curve) {
  validateObject(curve, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { P, type: type6, adjustScalarBytes: adjustScalarBytes2, powPminus2 } = CURVE;
  const is25519 = type6 === "x25519";
  if (!is25519 && type6 !== "x448")
    throw new Error("invalid type");
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n5 ** BigInt(254) : _2n5 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n5 ** BigInt(251) - _1n5 : BigInt(4) * _2n5 ** BigInt(445) - _1n5;
  const maxScalar = minScalar + maxAdded + _1n5;
  const modP = (n) => mod(n, P);
  const GuBytes = encodeU(Gu);
  function encodeU(u) {
    return numberToBytesLE(modP(u), fieldLen);
  }
  function decodeU(u) {
    const _u = ensureBytes("u coordinate", u, fieldLen);
    if (is25519)
      _u[31] &= 127;
    return modP(bytesToNumberLE(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE(adjustScalarBytes2(ensureBytes("scalar", scalar, fieldLen)));
  }
  function scalarMult(scalar, u) {
    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
    if (pu === _0n5)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n5, P);
    aInRange("scalar", scalar, minScalar, maxScalar);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n5;
    let z_2 = _0n5;
    let x_3 = u;
    let z_3 = _1n5;
    let swap = _0n5;
    for (let t = BigInt(montgomeryBits - 1); t >= _0n5; t--) {
      const k_t = k >> t & _1n5;
      swap ^= k_t;
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    ({ x_2, x_3 } = cswap(swap, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => CURVE.randomBytes(fieldLen) },
    GuBytes: GuBytes.slice()
  };
}

// node_modules/viem/node_modules/@noble/curves/esm/ed25519.js
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n6 = BigInt(2);
var _3n4 = BigInt(3);
var _5n = BigInt(5);
var _8n2 = BigInt(8);
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ED25519_P;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n6, P) * b2 % P;
  const b5 = pow2(b4, _1n6, P) * x % P;
  const b10 = pow2(b5, _5n, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n6, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
function uvRatio(u, v) {
  const P = ED25519_P;
  const v3 = mod(v * v * v, P);
  const v7 = mod(v3 * v3 * v, P);
  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow, P);
  const vx2 = mod(v * x * x, P);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp3 = (() => Field(ED25519_P, void 0, true))();
var ed25519Defaults = (() => ({
  // Removing Fp.create() will still work, and is 10% faster on sign
  a: Fp3.create(BigInt(-1)),
  // d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 2n**255n - 19n
  Fp: Fp3,
  // Subgroup order 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  h: _8n2,
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio
}))();
var ed25519 = (() => twistedEdwards(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx = (() => twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
}))();
var ed25519ph = (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
  domain: ed25519_domain,
  prehash: sha512
})))();
var x25519 = (() => montgomery({
  P: ED25519_P,
  type: "x25519",
  powPminus2: (x) => {
    const P = ED25519_P;
    const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
    return mod(pow2(pow_p_5_8, _3n4, P) * b2, P);
  },
  adjustScalarBytes,
  randomBytes
}))();
var ELL2_C1 = (() => (Fp3.ORDER + _3n4) / _8n2)();
var ELL2_C2 = (() => Fp3.pow(_2n6, ELL2_C1))();
var ELL2_C3 = (() => Fp3.sqrt(Fp3.neg(Fp3.ONE)))();
function map_to_curve_elligator2_curve25519(u) {
  const ELL2_C4 = (Fp3.ORDER - _5n) / _8n2;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp3.sqr(u);
  tv1 = Fp3.mul(tv1, _2n6);
  let xd = Fp3.add(tv1, Fp3.ONE);
  let x1n = Fp3.neg(ELL2_J);
  let tv2 = Fp3.sqr(xd);
  let gxd = Fp3.mul(tv2, xd);
  let gx1 = Fp3.mul(tv1, ELL2_J);
  gx1 = Fp3.mul(gx1, x1n);
  gx1 = Fp3.add(gx1, tv2);
  gx1 = Fp3.mul(gx1, x1n);
  let tv3 = Fp3.sqr(gxd);
  tv2 = Fp3.sqr(tv3);
  tv3 = Fp3.mul(tv3, gxd);
  tv3 = Fp3.mul(tv3, gx1);
  tv2 = Fp3.mul(tv2, tv3);
  let y11 = Fp3.pow(tv2, ELL2_C4);
  y11 = Fp3.mul(y11, tv3);
  let y12 = Fp3.mul(y11, ELL2_C3);
  tv2 = Fp3.sqr(y11);
  tv2 = Fp3.mul(tv2, gxd);
  let e1 = Fp3.eql(tv2, gx1);
  let y1 = Fp3.cmov(y12, y11, e1);
  let x2n = Fp3.mul(x1n, tv1);
  let y21 = Fp3.mul(y11, u);
  y21 = Fp3.mul(y21, ELL2_C2);
  let y22 = Fp3.mul(y21, ELL2_C3);
  let gx2 = Fp3.mul(gx1, tv1);
  tv2 = Fp3.sqr(y21);
  tv2 = Fp3.mul(tv2, gxd);
  let e2 = Fp3.eql(tv2, gx2);
  let y2 = Fp3.cmov(y22, y21, e2);
  tv2 = Fp3.sqr(y1);
  tv2 = Fp3.mul(tv2, gxd);
  let e3 = Fp3.eql(tv2, gx1);
  let xn = Fp3.cmov(x2n, x1n, e3);
  let y = Fp3.cmov(y2, y1, e3);
  let e4 = Fp3.isOdd(y);
  y = Fp3.cmov(y, Fp3.neg(y), e3 !== e4);
  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n6 };
}
var ELL2_C1_EDWARDS = (() => FpSqrtEven(Fp3, Fp3.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards25519(u) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
  let xn = Fp3.mul(xMn, yMd);
  xn = Fp3.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp3.mul(xMd, yMn);
  let yn = Fp3.sub(xMn, xMd);
  let yd = Fp3.add(xMn, xMd);
  let tv1 = Fp3.mul(xd, yd);
  let e = Fp3.eql(tv1, Fp3.ZERO);
  xn = Fp3.cmov(xn, Fp3.ZERO, e);
  xd = Fp3.cmov(xd, Fp3.ONE, e);
  yn = Fp3.cmov(yn, Fp3.ONE, e);
  yd = Fp3.cmov(yd, Fp3.ONE, e);
  const [xd_inv, yd_inv] = FpInvertBatch(Fp3, [xd, yd], true);
  return { x: Fp3.mul(xn, xd_inv), y: Fp3.mul(yn, yd_inv) };
}
var ed25519_hasher = (() => createHasher(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: Fp3.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha512
}))();
var hashToCurve = (() => ed25519_hasher.hashToCurve)();
var encodeToCurve = (() => ed25519_hasher.encodeToCurve)();
function aristp(other) {
  if (!(other instanceof RistPoint))
    throw new Error("RistrettoPoint expected");
}
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number2) => uvRatio(_1n6, number2);
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d } = ed25519.CURVE;
  const P = ed25519.CURVE.Fp.ORDER;
  const mod3 = ed25519.CURVE.Fp.create;
  const r2 = mod3(SQRT_M1 * r0 * r0);
  const Ns = mod3((r2 + _1n6) * ONE_MINUS_D_SQ);
  let c = BigInt(-1);
  const D = mod3((c - d * r2) * mod3(r2 + d));
  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
  let s_ = mod3(s * r0);
  if (!isNegativeLE(s_, P))
    s_ = mod3(-s_);
  if (!Ns_D_is_sq)
    s = s_;
  if (!Ns_D_is_sq)
    c = r2;
  const Nt = mod3(c * (r2 - _1n6) * D_MINUS_ONE_SQ - D);
  const s2 = s * s;
  const W0 = mod3((s + s) * D);
  const W1 = mod3(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod3(_1n6 - s2);
  const W3 = mod3(_1n6 + s2);
  return new ed25519.ExtendedPoint(mod3(W0 * W3), mod3(W2 * W1), mod3(W1 * W3), mod3(W0 * W2));
}
var RistPoint = class _RistPoint {
  // Private property to discourage combining ExtendedPoint + RistrettoPoint
  // Always use Ristretto encoding/decoding instead.
  constructor(ep) {
    this.ep = ep;
  }
  static fromAffine(ap) {
    return new _RistPoint(ed25519.ExtendedPoint.fromAffine(ap));
  }
  /**
   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
   * The hash-to-group operation applies Elligator twice and adds the results.
   * **Note:** this is one-way map, there is no conversion from point to hash.
   * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
   * the [website](https://ristretto.group/formulas/elligator.html).
   * @param hex 64-byte output of a hash function
   */
  static hashToCurve(hex) {
    hex = ensureBytes("ristrettoHash", hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R2 = calcElligatorRistrettoMap(r2);
    return new _RistPoint(R1.add(R2));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex) {
    hex = ensureBytes("ristrettoHex", hex, 32);
    const { a, d } = ed25519.CURVE;
    const P = ed25519.CURVE.Fp.ORDER;
    const mod3 = ed25519.CURVE.Fp.create;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s = bytes255ToNumberLE(hex);
    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P))
      throw new Error(emsg);
    const s2 = mod3(s * s);
    const u1 = mod3(_1n6 + a * s2);
    const u2 = mod3(_1n6 - a * s2);
    const u1_2 = mod3(u1 * u1);
    const u2_2 = mod3(u2 * u2);
    const v = mod3(a * d * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod3(v * u2_2));
    const Dx = mod3(I * u2);
    const Dy = mod3(I * Dx * v);
    let x = mod3((s + s) * Dx);
    if (isNegativeLE(x, P))
      x = mod3(-x);
    const y = mod3(u1 * Dy);
    const t = mod3(x * y);
    if (!isValid || isNegativeLE(t, P) || y === _0n6)
      throw new Error(emsg);
    return new _RistPoint(new ed25519.ExtendedPoint(x, y, _1n6, t));
  }
  static msm(points, scalars) {
    const Fn = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);
    return pippenger(_RistPoint, Fn, points, scalars);
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
   */
  toRawBytes() {
    let { ex: x, ey: y, ez: z, et: t } = this.ep;
    const P = ed25519.CURVE.Fp.ORDER;
    const mod3 = ed25519.CURVE.Fp.create;
    const u1 = mod3(mod3(z + y) * mod3(z - y));
    const u2 = mod3(x * y);
    const u2sq = mod3(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod3(u1 * u2sq));
    const D1 = mod3(invsqrt * u1);
    const D2 = mod3(invsqrt * u2);
    const zInv = mod3(D1 * D2 * t);
    let D;
    if (isNegativeLE(t * zInv, P)) {
      let _x = mod3(y * SQRT_M1);
      let _y = mod3(x * SQRT_M1);
      x = _x;
      y = _y;
      D = mod3(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (isNegativeLE(x * zInv, P))
      y = mod3(-y);
    let s = mod3((z - y) * D);
    if (isNegativeLE(s, P))
      s = mod3(-s);
    return numberToBytesLE(s, 32);
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  /**
   * Compares two Ristretto points.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
   */
  equals(other) {
    aristp(other);
    const { ex: X1, ey: Y1 } = this.ep;
    const { ex: X2, ey: Y2 } = other.ep;
    const mod3 = ed25519.CURVE.Fp.create;
    const one = mod3(X1 * Y2) === mod3(Y1 * X2);
    const two = mod3(Y1 * Y2) === mod3(X1 * X2);
    return one || two;
  }
  add(other) {
    aristp(other);
    return new _RistPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    aristp(other);
    return new _RistPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new _RistPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new _RistPoint(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return new _RistPoint(this.ep.double());
  }
  negate() {
    return new _RistPoint(this.ep.negate());
  }
};
var RistrettoPoint = (() => {
  if (!RistPoint.BASE)
    RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);
  if (!RistPoint.ZERO)
    RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);
  return RistPoint;
})();

// node_modules/viem/node_modules/ox/_esm/core/Ed25519.js
var noble2 = ed25519;
function createKeyPair2(options = {}) {
  const { as = "Hex" } = options;
  const privateKey = randomPrivateKey2({ as });
  const publicKey = getPublicKey3({ privateKey, as });
  return {
    privateKey,
    publicKey
  };
}
function getPublicKey3(options) {
  const { as = "Hex", privateKey } = options;
  const privateKeyBytes = from(privateKey);
  const publicKeyBytes = ed25519.getPublicKey(privateKeyBytes);
  if (as === "Hex")
    return fromBytes(publicKeyBytes);
  return publicKeyBytes;
}
function randomPrivateKey2(options = {}) {
  const { as = "Hex" } = options;
  const bytes = ed25519.utils.randomPrivateKey();
  if (as === "Hex")
    return fromBytes(bytes);
  return bytes;
}
function sign2(options) {
  const { as = "Hex", payload, privateKey } = options;
  const payloadBytes = from(payload);
  const privateKeyBytes = from(privateKey);
  const signatureBytes = ed25519.sign(payloadBytes, privateKeyBytes);
  if (as === "Hex")
    return fromBytes(signatureBytes);
  return signatureBytes;
}
function verify2(options) {
  const { payload, publicKey, signature } = options;
  const payloadBytes = from(payload);
  const publicKeyBytes = from(publicKey);
  const signatureBytes = from(signature);
  return ed25519.verify(signatureBytes, payloadBytes, publicKeyBytes);
}

// node_modules/viem/node_modules/ox/_esm/core/Fee.js
var Fee_exports = {};

// node_modules/viem/node_modules/ox/_esm/core/Filter.js
var Filter_exports = {};
__export(Filter_exports, {
  fromRpc: () => fromRpc4,
  toRpc: () => toRpc5
});
function fromRpc4(filter) {
  const { fromBlock, toBlock } = filter;
  return {
    ...filter,
    ...fromBlock && {
      fromBlock: validate2(fromBlock, { strict: false }) ? BigInt(fromBlock) : fromBlock
    },
    ...toBlock && {
      toBlock: validate2(toBlock, { strict: false }) ? BigInt(toBlock) : toBlock
    }
  };
}
function toRpc5(filter) {
  const { address, topics, fromBlock, toBlock } = filter;
  return {
    ...address && { address },
    ...topics && { topics },
    ...typeof fromBlock !== "undefined" ? {
      fromBlock: typeof fromBlock === "bigint" ? fromNumber2(fromBlock) : fromBlock
    } : {},
    ...typeof toBlock !== "undefined" ? {
      toBlock: typeof toBlock === "bigint" ? fromNumber2(toBlock) : toBlock
    } : {}
  };
}

// node_modules/viem/node_modules/ox/_esm/core/HdKey.js
var HdKey_exports = {};
__export(HdKey_exports, {
  fromExtendedKey: () => fromExtendedKey,
  fromJson: () => fromJson,
  fromSeed: () => fromSeed,
  path: () => path
});

// node_modules/viem/node_modules/ox/_esm/core/internal/hdKey.js
function fromScure(key) {
  return {
    derive: (path2) => fromScure(key.derive(path2)),
    depth: key.depth,
    identifier: fromBytes(key.identifier),
    index: key.index,
    privateKey: fromBytes(key.privateKey),
    privateExtendedKey: key.privateExtendedKey,
    publicKey: getPublicKey({ privateKey: key.privateKey }),
    publicExtendedKey: key.publicExtendedKey,
    versions: key.versions
  };
}

// node_modules/viem/node_modules/ox/_esm/core/HdKey.js
function fromExtendedKey(extendedKey) {
  const key = HDKey.fromExtendedKey(extendedKey);
  return fromScure(key);
}
function fromJson(json) {
  return fromScure(HDKey.fromJSON(json));
}
function fromSeed(seed, options = {}) {
  const { versions } = options;
  const key = HDKey.fromMasterSeed(from(seed), versions);
  return fromScure(key);
}
function path(options = {}) {
  const { account = 0, change = 0, index: index2 = 0 } = options;
  return `m/44'/60'/${account}'/${change}/${index2}`;
}

// node_modules/viem/node_modules/ox/_esm/core/Keystore.js
var Keystore_exports = {};
__export(Keystore_exports, {
  decrypt: () => decrypt3,
  encrypt: () => encrypt3,
  pbkdf2: () => pbkdf22,
  pbkdf2Async: () => pbkdf2Async2,
  scrypt: () => scrypt2,
  scryptAsync: () => scryptAsync2,
  toKey: () => toKey,
  toKeyAsync: () => toKeyAsync
});

// node_modules/@noble/ciphers/esm/utils.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abool2(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u8(arr) {
  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u322(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean2(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes6(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  else if (isBytes(data))
    data = copyBytes(data);
  else
    throw new Error("Uint8Array expected, got " + typeof data);
  return data;
}
function overlapBytes(a, b) {
  return a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
  a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
  b.byteOffset < a.byteOffset + a.byteLength;
}
function complexOverlapBytes(input, output) {
  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
    throw new Error("complex overlap of input and output is not supported");
}
function concatBytes3(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}
function equalBytes2(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
var wrapCipher = (params, constructor) => {
  function wrappedCipher(key, ...args) {
    abytes(key);
    if (!isLE)
      throw new Error("Non little-endian hardware is not yet supported");
    if (params.nonceLength !== void 0) {
      const nonce = args[0];
      if (!nonce)
        throw new Error("nonce / iv required");
      if (params.varSizeNonce)
        abytes(nonce);
      else
        abytes(nonce, params.nonceLength);
    }
    const tagl = params.tagLength;
    if (tagl && args[1] !== void 0) {
      abytes(args[1]);
    }
    const cipher = constructor(key, ...args);
    const checkOutput = (fnLength, output) => {
      if (output !== void 0) {
        if (fnLength !== 2)
          throw new Error("cipher output not supported");
        abytes(output);
      }
    };
    let called = false;
    const wrCipher = {
      encrypt(data, output) {
        if (called)
          throw new Error("cannot encrypt() twice with same key + nonce");
        called = true;
        abytes(data);
        checkOutput(cipher.encrypt.length, output);
        return cipher.encrypt(data, output);
      },
      decrypt(data, output) {
        abytes(data);
        if (tagl && data.length < tagl)
          throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
        checkOutput(cipher.decrypt.length, output);
        return cipher.decrypt(data, output);
      }
    };
    return wrCipher;
  }
  Object.assign(wrappedCipher, params);
  return wrappedCipher;
};
function getOutput(expectedLength, out, onlyAligned = true) {
  if (out === void 0)
    return new Uint8Array(expectedLength);
  if (out.length !== expectedLength)
    throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
  if (onlyAligned && !isAligned32(out))
    throw new Error("invalid output, must be aligned");
  return out;
}
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
function u64Lengths(dataLength, aadLength, isLE3) {
  abool2(isLE3);
  const num = new Uint8Array(16);
  const view = createView(num);
  setBigUint64(view, 0, BigInt(aadLength), isLE3);
  setBigUint64(view, 8, BigInt(dataLength), isLE3);
  return num;
}
function isAligned32(bytes) {
  return bytes.byteOffset % 4 === 0;
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}

// node_modules/@noble/ciphers/esm/_polyval.js
var BLOCK_SIZE = 16;
var ZEROS16 = new Uint8Array(16);
var ZEROS32 = u322(ZEROS16);
var POLY = 225;
var mul2 = (s0, s1, s2, s3) => {
  const hiBit = s3 & 1;
  return {
    s3: s2 << 31 | s3 >>> 1,
    s2: s1 << 31 | s2 >>> 1,
    s1: s0 << 31 | s1 >>> 1,
    s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1)
    // reduce % poly
  };
};
var swapLE = (n) => (n >>> 0 & 255) << 24 | (n >>> 8 & 255) << 16 | (n >>> 16 & 255) << 8 | n >>> 24 & 255 | 0;
function _toGHASHKey(k) {
  k.reverse();
  const hiBit = k[15] & 1;
  let carry = 0;
  for (let i = 0; i < k.length; i++) {
    const t = k[i];
    k[i] = t >>> 1 | carry;
    carry = (t & 1) << 7;
  }
  k[0] ^= -hiBit & 225;
  return k;
}
var estimateWindow = (bytes) => {
  if (bytes > 64 * 1024)
    return 8;
  if (bytes > 1024)
    return 4;
  return 2;
};
var GHASH = class {
  // We select bits per window adaptively based on expectedLength
  constructor(key, expectedLength) {
    this.blockLen = BLOCK_SIZE;
    this.outputLen = BLOCK_SIZE;
    this.s0 = 0;
    this.s1 = 0;
    this.s2 = 0;
    this.s3 = 0;
    this.finished = false;
    key = toBytes6(key);
    abytes(key, 16);
    const kView = createView(key);
    let k0 = kView.getUint32(0, false);
    let k1 = kView.getUint32(4, false);
    let k2 = kView.getUint32(8, false);
    let k3 = kView.getUint32(12, false);
    const doubles = [];
    for (let i = 0; i < 128; i++) {
      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });
      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));
    }
    const W = estimateWindow(expectedLength || 1024);
    if (![1, 2, 4, 8].includes(W))
      throw new Error("ghash: invalid window size, expected 2, 4 or 8");
    this.W = W;
    const bits = 128;
    const windows = bits / W;
    const windowSize = this.windowSize = 2 ** W;
    const items = [];
    for (let w = 0; w < windows; w++) {
      for (let byte = 0; byte < windowSize; byte++) {
        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;
        for (let j = 0; j < W; j++) {
          const bit = byte >>> W - j - 1 & 1;
          if (!bit)
            continue;
          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];
          s0 ^= d0, s1 ^= d1, s2 ^= d2, s3 ^= d3;
        }
        items.push({ s0, s1, s2, s3 });
      }
    }
    this.t = items;
  }
  _updateBlock(s0, s1, s2, s3) {
    s0 ^= this.s0, s1 ^= this.s1, s2 ^= this.s2, s3 ^= this.s3;
    const { W, t, windowSize } = this;
    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;
    const mask2 = (1 << W) - 1;
    let w = 0;
    for (const num of [s0, s1, s2, s3]) {
      for (let bytePos = 0; bytePos < 4; bytePos++) {
        const byte = num >>> 8 * bytePos & 255;
        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {
          const bit = byte >>> W * bitPos & mask2;
          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];
          o0 ^= e0, o1 ^= e1, o2 ^= e2, o3 ^= e3;
          w += 1;
        }
      }
    }
    this.s0 = o0;
    this.s1 = o1;
    this.s2 = o2;
    this.s3 = o3;
  }
  update(data) {
    aexists(this);
    data = toBytes6(data);
    abytes(data);
    const b32 = u322(data);
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    const left = data.length % BLOCK_SIZE;
    for (let i = 0; i < blocks; i++) {
      this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);
    }
    if (left) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);
      clean2(ZEROS32);
    }
    return this;
  }
  destroy() {
    const { t } = this;
    for (const elm of t) {
      elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;
    }
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u322(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out;
  }
  digest() {
    const res = new Uint8Array(BLOCK_SIZE);
    this.digestInto(res);
    this.destroy();
    return res;
  }
};
var Polyval = class extends GHASH {
  constructor(key, expectedLength) {
    key = toBytes6(key);
    abytes(key);
    const ghKey = _toGHASHKey(copyBytes(key));
    super(ghKey, expectedLength);
    clean2(ghKey);
  }
  update(data) {
    data = toBytes6(data);
    aexists(this);
    const b32 = u322(data);
    const left = data.length % BLOCK_SIZE;
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    for (let i = 0; i < blocks; i++) {
      this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));
    }
    if (left) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));
      clean2(ZEROS32);
    }
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u322(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out.reverse();
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes6(msg)).digest();
  const tmp = hashCons(new Uint8Array(16), 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key, expectedLength) => hashCons(key, expectedLength);
  return hashC;
}
var ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));
var polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));

// node_modules/@noble/ciphers/esm/aes.js
var BLOCK_SIZE2 = 16;
var BLOCK_SIZE32 = 4;
var EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE2);
var POLY2 = 283;
function mul22(n) {
  return n << 1 ^ POLY2 & -(n >> 7);
}
function mul(a, b) {
  let res = 0;
  for (; b > 0; b >>= 1) {
    res ^= a & -(b & 1);
    a = mul22(a);
  }
  return res;
}
var sbox = (() => {
  const t = new Uint8Array(256);
  for (let i = 0, x = 1; i < 256; i++, x ^= mul22(x))
    t[i] = x;
  const box = new Uint8Array(256);
  box[0] = 99;
  for (let i = 0; i < 255; i++) {
    let x = t[255 - i];
    x |= x << 8;
    box[t[i]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 99) & 255;
  }
  clean2(t);
  return box;
})();
var invSbox = sbox.map((_, j) => sbox.indexOf(j));
var rotr32_8 = (n) => n << 24 | n >>> 8;
var rotl32_8 = (n) => n << 8 | n >>> 24;
var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
function genTtable(sbox2, fn) {
  if (sbox2.length !== 256)
    throw new Error("Wrong sbox length");
  const T0 = new Uint32Array(256).map((_, j) => fn(sbox2[j]));
  const T1 = T0.map(rotl32_8);
  const T2 = T1.map(rotl32_8);
  const T3 = T2.map(rotl32_8);
  const T01 = new Uint32Array(256 * 256);
  const T23 = new Uint32Array(256 * 256);
  const sbox22 = new Uint16Array(256 * 256);
  for (let i = 0; i < 256; i++) {
    for (let j = 0; j < 256; j++) {
      const idx = i * 256 + j;
      T01[idx] = T0[i] ^ T1[j];
      T23[idx] = T2[i] ^ T3[j];
      sbox22[idx] = sbox2[i] << 8 | sbox2[j];
    }
  }
  return { sbox: sbox2, sbox2: sbox22, T0, T1, T2, T3, T01, T23 };
}
var tableEncoding = genTtable(sbox, (s) => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));
var tableDecoding = genTtable(invSbox, (s) => mul(s, 11) << 24 | mul(s, 13) << 16 | mul(s, 9) << 8 | mul(s, 14));
var xPowers = (() => {
  const p = new Uint8Array(16);
  for (let i = 0, x = 1; i < 16; i++, x = mul22(x))
    p[i] = x;
  return p;
})();
function expandKeyLE(key) {
  abytes(key);
  const len = key.length;
  if (![16, 24, 32].includes(len))
    throw new Error("aes: invalid key size, should be 16, 24 or 32, got " + len);
  const { sbox2 } = tableEncoding;
  const toClean = [];
  if (!isAligned32(key))
    toClean.push(key = copyBytes(key));
  const k32 = u322(key);
  const Nk = k32.length;
  const subByte = (n) => applySbox(sbox2, n, n, n, n);
  const xk = new Uint32Array(len + 28);
  xk.set(k32);
  for (let i = Nk; i < xk.length; i++) {
    let t = xk[i - 1];
    if (i % Nk === 0)
      t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];
    else if (Nk > 6 && i % Nk === 4)
      t = subByte(t);
    xk[i] = xk[i - Nk] ^ t;
  }
  clean2(...toClean);
  return xk;
}
function expandKeyDecLE(key) {
  const encKey = expandKeyLE(key);
  const xk = encKey.slice();
  const Nk = encKey.length;
  const { sbox2 } = tableEncoding;
  const { T0, T1, T2, T3 } = tableDecoding;
  for (let i = 0; i < Nk; i += 4) {
    for (let j = 0; j < 4; j++)
      xk[i + j] = encKey[Nk - i - 4 + j];
  }
  clean2(encKey);
  for (let i = 4; i < Nk - 4; i++) {
    const x = xk[i];
    const w = applySbox(sbox2, x, x, x, x);
    xk[i] = T0[w & 255] ^ T1[w >>> 8 & 255] ^ T2[w >>> 16 & 255] ^ T3[w >>> 24];
  }
  return xk;
}
function apply0123(T01, T23, s0, s1, s2, s3) {
  return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s2 >>> 8 & 65280 | s3 >>> 24 & 255];
}
function applySbox(sbox2, s0, s1, s2, s3) {
  return sbox2[s0 & 255 | s1 & 65280] | sbox2[s2 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
}
function encrypt2(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableEncoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i = 0; i < rounds; i++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function decrypt2(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableDecoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i = 0; i < rounds; i++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function ctrCounter(xk, nonce, src7, dst) {
  abytes(nonce, BLOCK_SIZE2);
  abytes(src7);
  const srcLen = src7.length;
  dst = getOutput(srcLen, dst);
  complexOverlapBytes(src7, dst);
  const ctr2 = nonce;
  const c32 = u322(ctr2);
  let { s0, s1, s2, s3 } = encrypt2(xk, c32[0], c32[1], c32[2], c32[3]);
  const src32 = u322(src7);
  const dst32 = u322(dst);
  for (let i = 0; i + 4 <= src32.length; i += 4) {
    dst32[i + 0] = src32[i + 0] ^ s0;
    dst32[i + 1] = src32[i + 1] ^ s1;
    dst32[i + 2] = src32[i + 2] ^ s2;
    dst32[i + 3] = src32[i + 3] ^ s3;
    let carry = 1;
    for (let i2 = ctr2.length - 1; i2 >= 0; i2--) {
      carry = carry + (ctr2[i2] & 255) | 0;
      ctr2[i2] = carry & 255;
      carry >>>= 8;
    }
    ({ s0, s1, s2, s3 } = encrypt2(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf = u8(b32);
    for (let i = start, pos = 0; i < srcLen; i++, pos++)
      dst[i] = src7[i] ^ buf[pos];
    clean2(b32);
  }
  return dst;
}
function ctr32(xk, isLE3, nonce, src7, dst) {
  abytes(nonce, BLOCK_SIZE2);
  abytes(src7);
  dst = getOutput(src7.length, dst);
  const ctr2 = nonce;
  const c32 = u322(ctr2);
  const view = createView(ctr2);
  const src32 = u322(src7);
  const dst32 = u322(dst);
  const ctrPos = isLE3 ? 0 : 12;
  const srcLen = src7.length;
  let ctrNum = view.getUint32(ctrPos, isLE3);
  let { s0, s1, s2, s3 } = encrypt2(xk, c32[0], c32[1], c32[2], c32[3]);
  for (let i = 0; i + 4 <= src32.length; i += 4) {
    dst32[i + 0] = src32[i + 0] ^ s0;
    dst32[i + 1] = src32[i + 1] ^ s1;
    dst32[i + 2] = src32[i + 2] ^ s2;
    dst32[i + 3] = src32[i + 3] ^ s3;
    ctrNum = ctrNum + 1 >>> 0;
    view.setUint32(ctrPos, ctrNum, isLE3);
    ({ s0, s1, s2, s3 } = encrypt2(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf = u8(b32);
    for (let i = start, pos = 0; i < srcLen; i++, pos++)
      dst[i] = src7[i] ^ buf[pos];
    clean2(b32);
  }
  return dst;
}
var ctr = wrapCipher({ blockSize: 16, nonceLength: 16 }, function aesctr(key, nonce) {
  function processCtr(buf, dst) {
    abytes(buf);
    if (dst !== void 0) {
      abytes(dst);
      if (!isAligned32(dst))
        throw new Error("unaligned destination");
    }
    const xk = expandKeyLE(key);
    const n = copyBytes(nonce);
    const toClean = [xk, n];
    if (!isAligned32(buf))
      toClean.push(buf = copyBytes(buf));
    const out = ctrCounter(xk, n, buf, dst);
    clean2(...toClean);
    return out;
  }
  return {
    encrypt: (plaintext, dst) => processCtr(plaintext, dst),
    decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)
  };
});
function validateBlockDecrypt(data) {
  abytes(data);
  if (data.length % BLOCK_SIZE2 !== 0) {
    throw new Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size " + BLOCK_SIZE2);
  }
}
function validateBlockEncrypt(plaintext, pcks5, dst) {
  abytes(plaintext);
  let outLen = plaintext.length;
  const remaining = outLen % BLOCK_SIZE2;
  if (!pcks5 && remaining !== 0)
    throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  if (!isAligned32(plaintext))
    plaintext = copyBytes(plaintext);
  const b = u322(plaintext);
  if (pcks5) {
    let left = BLOCK_SIZE2 - remaining;
    if (!left)
      left = BLOCK_SIZE2;
    outLen = outLen + left;
  }
  dst = getOutput(outLen, dst);
  complexOverlapBytes(plaintext, dst);
  const o = u322(dst);
  return { b, o, out: dst };
}
function validatePCKS(data, pcks5) {
  if (!pcks5)
    return data;
  const len = data.length;
  if (!len)
    throw new Error("aes/pcks5: empty ciphertext not allowed");
  const lastByte = data[len - 1];
  if (lastByte <= 0 || lastByte > 16)
    throw new Error("aes/pcks5: wrong padding");
  const out = data.subarray(0, -lastByte);
  for (let i = 0; i < lastByte; i++)
    if (data[len - i - 1] !== lastByte)
      throw new Error("aes/pcks5: wrong padding");
  return out;
}
function padPCKS(left) {
  const tmp = new Uint8Array(16);
  const tmp32 = u322(tmp);
  tmp.set(left);
  const paddingByte = BLOCK_SIZE2 - left.length;
  for (let i = BLOCK_SIZE2 - paddingByte; i < BLOCK_SIZE2; i++)
    tmp[i] = paddingByte;
  return tmp32;
}
var ecb = wrapCipher({ blockSize: 16 }, function aesecb(key, opts = {}) {
  const pcks5 = !opts.disablePadding;
  return {
    encrypt(plaintext, dst) {
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const xk = expandKeyLE(key);
      let i = 0;
      for (; i + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = encrypt2(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i * 4));
        const { s0, s1, s2, s3 } = encrypt2(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      clean2(xk);
      return _out;
    },
    decrypt(ciphertext, dst) {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      dst = getOutput(ciphertext.length, dst);
      const toClean = [xk];
      if (!isAligned32(ciphertext))
        toClean.push(ciphertext = copyBytes(ciphertext));
      complexOverlapBytes(ciphertext, dst);
      const b = u322(ciphertext);
      const o = u322(dst);
      for (let i = 0; i + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = decrypt2(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      clean2(...toClean);
      return validatePCKS(dst, pcks5);
    }
  };
});
var cbc = wrapCipher({ blockSize: 16, nonceLength: 16 }, function aescbc(key, iv, opts = {}) {
  const pcks5 = !opts.disablePadding;
  return {
    encrypt(plaintext, dst) {
      const xk = expandKeyLE(key);
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      let _iv = iv;
      const toClean = [xk];
      if (!isAligned32(_iv))
        toClean.push(_iv = copyBytes(_iv));
      const n32 = u322(_iv);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      let i = 0;
      for (; i + 4 <= b.length; ) {
        s0 ^= b[i + 0], s1 ^= b[i + 1], s2 ^= b[i + 2], s3 ^= b[i + 3];
        ({ s0, s1, s2, s3 } = encrypt2(xk, s0, s1, s2, s3));
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i * 4));
        s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];
        ({ s0, s1, s2, s3 } = encrypt2(xk, s0, s1, s2, s3));
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      clean2(...toClean);
      return _out;
    },
    decrypt(ciphertext, dst) {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      let _iv = iv;
      const toClean = [xk];
      if (!isAligned32(_iv))
        toClean.push(_iv = copyBytes(_iv));
      const n32 = u322(_iv);
      dst = getOutput(ciphertext.length, dst);
      if (!isAligned32(ciphertext))
        toClean.push(ciphertext = copyBytes(ciphertext));
      complexOverlapBytes(ciphertext, dst);
      const b = u322(ciphertext);
      const o = u322(dst);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      for (let i = 0; i + 4 <= b.length; ) {
        const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;
        s0 = b[i + 0], s1 = b[i + 1], s2 = b[i + 2], s3 = b[i + 3];
        const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt2(xk, s0, s1, s2, s3);
        o[i++] = o0 ^ ps0, o[i++] = o1 ^ ps1, o[i++] = o2 ^ ps2, o[i++] = o3 ^ ps3;
      }
      clean2(...toClean);
      return validatePCKS(dst, pcks5);
    }
  };
});
var cfb = wrapCipher({ blockSize: 16, nonceLength: 16 }, function aescfb(key, iv) {
  function processCfb(src7, isEncrypt, dst) {
    abytes(src7);
    const srcLen = src7.length;
    dst = getOutput(srcLen, dst);
    if (overlapBytes(src7, dst))
      throw new Error("overlapping src and dst not supported.");
    const xk = expandKeyLE(key);
    let _iv = iv;
    const toClean = [xk];
    if (!isAligned32(_iv))
      toClean.push(_iv = copyBytes(_iv));
    if (!isAligned32(src7))
      toClean.push(src7 = copyBytes(src7));
    const src32 = u322(src7);
    const dst32 = u322(dst);
    const next32 = isEncrypt ? dst32 : src32;
    const n32 = u322(_iv);
    let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
    for (let i = 0; i + 4 <= src32.length; ) {
      const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt2(xk, s0, s1, s2, s3);
      dst32[i + 0] = src32[i + 0] ^ e0;
      dst32[i + 1] = src32[i + 1] ^ e1;
      dst32[i + 2] = src32[i + 2] ^ e2;
      dst32[i + 3] = src32[i + 3] ^ e3;
      s0 = next32[i++], s1 = next32[i++], s2 = next32[i++], s3 = next32[i++];
    }
    const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
    if (start < srcLen) {
      ({ s0, s1, s2, s3 } = encrypt2(xk, s0, s1, s2, s3));
      const buf = u8(new Uint32Array([s0, s1, s2, s3]));
      for (let i = start, pos = 0; i < srcLen; i++, pos++)
        dst[i] = src7[i] ^ buf[pos];
      clean2(buf);
    }
    clean2(...toClean);
    return dst;
  }
  return {
    encrypt: (plaintext, dst) => processCfb(plaintext, true, dst),
    decrypt: (ciphertext, dst) => processCfb(ciphertext, false, dst)
  };
});
function computeTag(fn, isLE3, key, data, AAD) {
  const aadLength = AAD ? AAD.length : 0;
  const h = fn.create(key, data.length + aadLength);
  if (AAD)
    h.update(AAD);
  const num = u64Lengths(8 * data.length, 8 * aadLength, isLE3);
  h.update(data);
  h.update(num);
  const res = h.digest();
  clean2(num);
  return res;
}
var gcm = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function aesgcm(key, nonce, AAD) {
  if (nonce.length < 8)
    throw new Error("aes/gcm: invalid nonce length");
  const tagLength = 16;
  function _computeTag(authKey, tagMask, data) {
    const tag = computeTag(ghash, false, authKey, data, AAD);
    for (let i = 0; i < tagMask.length; i++)
      tag[i] ^= tagMask[i];
    return tag;
  }
  function deriveKeys() {
    const xk = expandKeyLE(key);
    const authKey = EMPTY_BLOCK.slice();
    const counter = EMPTY_BLOCK.slice();
    ctr32(xk, false, counter, counter, authKey);
    if (nonce.length === 12) {
      counter.set(nonce);
    } else {
      const nonceLen = EMPTY_BLOCK.slice();
      const view = createView(nonceLen);
      setBigUint64(view, 8, BigInt(nonce.length * 8), false);
      const g = ghash.create(authKey).update(nonce).update(nonceLen);
      g.digestInto(counter);
      g.destroy();
    }
    const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);
    return { xk, authKey, counter, tagMask };
  }
  return {
    encrypt(plaintext) {
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const out = new Uint8Array(plaintext.length + tagLength);
      const toClean = [xk, authKey, counter, tagMask];
      if (!isAligned32(plaintext))
        toClean.push(plaintext = copyBytes(plaintext));
      ctr32(xk, false, counter, plaintext, out.subarray(0, plaintext.length));
      const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));
      toClean.push(tag);
      out.set(tag, plaintext.length);
      clean2(...toClean);
      return out;
    },
    decrypt(ciphertext) {
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const toClean = [xk, authKey, tagMask, counter];
      if (!isAligned32(ciphertext))
        toClean.push(ciphertext = copyBytes(ciphertext));
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = _computeTag(authKey, tagMask, data);
      toClean.push(tag);
      if (!equalBytes2(tag, passedTag))
        throw new Error("aes/gcm: invalid ghash tag");
      const out = ctr32(xk, false, counter, data);
      clean2(...toClean);
      return out;
    }
  };
});
var limit = (name, min, max) => (value) => {
  if (!Number.isSafeInteger(value) || min > value || value > max) {
    const minmax = "[" + min + ".." + max + "]";
    throw new Error("" + name + ": expected value in range " + minmax + ", got " + value);
  }
};
var gcmsiv = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function aessiv(key, nonce, AAD) {
  const tagLength = 16;
  const AAD_LIMIT = limit("AAD", 0, 2 ** 36);
  const PLAIN_LIMIT = limit("plaintext", 0, 2 ** 36);
  const NONCE_LIMIT = limit("nonce", 12, 12);
  const CIPHER_LIMIT = limit("ciphertext", 16, 2 ** 36 + 16);
  abytes(key, 16, 24, 32);
  NONCE_LIMIT(nonce.length);
  if (AAD !== void 0)
    AAD_LIMIT(AAD.length);
  function deriveKeys() {
    const xk = expandKeyLE(key);
    const encKey = new Uint8Array(key.length);
    const authKey = new Uint8Array(16);
    const toClean = [xk, encKey];
    let _nonce = nonce;
    if (!isAligned32(_nonce))
      toClean.push(_nonce = copyBytes(_nonce));
    const n32 = u322(_nonce);
    let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];
    let counter = 0;
    for (const derivedKey of [authKey, encKey].map(u322)) {
      const d32 = u322(derivedKey);
      for (let i = 0; i < d32.length; i += 2) {
        const { s0: o0, s1: o1 } = encrypt2(xk, s0, s1, s2, s3);
        d32[i + 0] = o0;
        d32[i + 1] = o1;
        s0 = ++counter;
      }
    }
    const res = { authKey, encKey: expandKeyLE(encKey) };
    clean2(...toClean);
    return res;
  }
  function _computeTag(encKey, authKey, data) {
    const tag = computeTag(polyval, true, authKey, data, AAD);
    for (let i = 0; i < 12; i++)
      tag[i] ^= nonce[i];
    tag[15] &= 127;
    const t32 = u322(tag);
    let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];
    ({ s0, s1, s2, s3 } = encrypt2(encKey, s0, s1, s2, s3));
    t32[0] = s0, t32[1] = s1, t32[2] = s2, t32[3] = s3;
    return tag;
  }
  function processSiv(encKey, tag, input) {
    let block = copyBytes(tag);
    block[15] |= 128;
    const res = ctr32(encKey, true, block, input);
    clean2(block);
    return res;
  }
  return {
    encrypt(plaintext) {
      PLAIN_LIMIT(plaintext.length);
      const { encKey, authKey } = deriveKeys();
      const tag = _computeTag(encKey, authKey, plaintext);
      const toClean = [encKey, authKey, tag];
      if (!isAligned32(plaintext))
        toClean.push(plaintext = copyBytes(plaintext));
      const out = new Uint8Array(plaintext.length + tagLength);
      out.set(tag, plaintext.length);
      out.set(processSiv(encKey, tag, plaintext));
      clean2(...toClean);
      return out;
    },
    decrypt(ciphertext) {
      CIPHER_LIMIT(ciphertext.length);
      const tag = ciphertext.subarray(-tagLength);
      const { encKey, authKey } = deriveKeys();
      const toClean = [encKey, authKey];
      if (!isAligned32(ciphertext))
        toClean.push(ciphertext = copyBytes(ciphertext));
      const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));
      const expectedTag = _computeTag(encKey, authKey, plaintext);
      toClean.push(expectedTag);
      if (!equalBytes2(tag, expectedTag)) {
        clean2(...toClean);
        throw new Error("invalid polyval tag");
      }
      clean2(...toClean);
      return plaintext;
    }
  };
});
function isBytes32(a) {
  return a instanceof Uint32Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint32Array";
}
function encryptBlock(xk, block) {
  abytes(block, 16);
  if (!isBytes32(xk))
    throw new Error("_encryptBlock accepts result of expandKeyLE");
  const b32 = u322(block);
  let { s0, s1, s2, s3 } = encrypt2(xk, b32[0], b32[1], b32[2], b32[3]);
  b32[0] = s0, b32[1] = s1, b32[2] = s2, b32[3] = s3;
  return block;
}
function decryptBlock(xk, block) {
  abytes(block, 16);
  if (!isBytes32(xk))
    throw new Error("_decryptBlock accepts result of expandKeyLE");
  const b32 = u322(block);
  let { s0, s1, s2, s3 } = decrypt2(xk, b32[0], b32[1], b32[2], b32[3]);
  b32[0] = s0, b32[1] = s1, b32[2] = s2, b32[3] = s3;
  return block;
}
var AESW = {
  /*
  High-level pseudocode:
  ```
  A: u64 = IV
  out = []
  for (let i=0, ctr = 0; i<6; i++) {
    for (const chunk of chunks(plaintext, 8)) {
      A ^= swapEndianess(ctr++)
      [A, res] = chunks(encrypt(A || chunk), 8);
      out ||= res
    }
  }
  out = A || out
  ```
  Decrypt is the same, but reversed.
  */
  encrypt(kek, out) {
    if (out.length >= 2 ** 32)
      throw new Error("plaintext should be less than 4gb");
    const xk = expandKeyLE(kek);
    if (out.length === 16)
      encryptBlock(xk, out);
    else {
      const o32 = u322(out);
      let a0 = o32[0], a1 = o32[1];
      for (let j = 0, ctr2 = 1; j < 6; j++) {
        for (let pos = 2; pos < o32.length; pos += 2, ctr2++) {
          const { s0, s1, s2, s3 } = encrypt2(xk, a0, a1, o32[pos], o32[pos + 1]);
          a0 = s0, a1 = s1 ^ byteSwap(ctr2), o32[pos] = s2, o32[pos + 1] = s3;
        }
      }
      o32[0] = a0, o32[1] = a1;
    }
    xk.fill(0);
  },
  decrypt(kek, out) {
    if (out.length - 8 >= 2 ** 32)
      throw new Error("ciphertext should be less than 4gb");
    const xk = expandKeyDecLE(kek);
    const chunks = out.length / 8 - 1;
    if (chunks === 1)
      decryptBlock(xk, out);
    else {
      const o32 = u322(out);
      let a0 = o32[0], a1 = o32[1];
      for (let j = 0, ctr2 = chunks * 6; j < 6; j++) {
        for (let pos = chunks * 2; pos >= 1; pos -= 2, ctr2--) {
          a1 ^= byteSwap(ctr2);
          const { s0, s1, s2, s3 } = decrypt2(xk, a0, a1, o32[pos], o32[pos + 1]);
          a0 = s0, a1 = s1, o32[pos] = s2, o32[pos + 1] = s3;
        }
      }
      o32[0] = a0, o32[1] = a1;
    }
    xk.fill(0);
  }
};
var AESKW_IV = new Uint8Array(8).fill(166);
var aeskw = wrapCipher({ blockSize: 8 }, (kek) => ({
  encrypt(plaintext) {
    if (!plaintext.length || plaintext.length % 8 !== 0)
      throw new Error("invalid plaintext length");
    if (plaintext.length === 8)
      throw new Error("8-byte keys not allowed in AESKW, use AESKWP instead");
    const out = concatBytes3(AESKW_IV, plaintext);
    AESW.encrypt(kek, out);
    return out;
  },
  decrypt(ciphertext) {
    if (ciphertext.length % 8 !== 0 || ciphertext.length < 3 * 8)
      throw new Error("invalid ciphertext length");
    const out = copyBytes(ciphertext);
    AESW.decrypt(kek, out);
    if (!equalBytes2(out.subarray(0, 8), AESKW_IV))
      throw new Error("integrity check failed");
    out.subarray(0, 8).fill(0);
    return out.subarray(8);
  }
}));
var AESKWP_IV = 2790873510;
var aeskwp = wrapCipher({ blockSize: 8 }, (kek) => ({
  encrypt(plaintext) {
    if (!plaintext.length)
      throw new Error("invalid plaintext length");
    const padded = Math.ceil(plaintext.length / 8) * 8;
    const out = new Uint8Array(8 + padded);
    out.set(plaintext, 8);
    const out32 = u322(out);
    out32[0] = AESKWP_IV;
    out32[1] = byteSwap(plaintext.length);
    AESW.encrypt(kek, out);
    return out;
  },
  decrypt(ciphertext) {
    if (ciphertext.length < 16)
      throw new Error("invalid ciphertext length");
    const out = copyBytes(ciphertext);
    const o32 = u322(out);
    AESW.decrypt(kek, out);
    const len = byteSwap(o32[1]) >>> 0;
    const padded = Math.ceil(len / 8) * 8;
    if (o32[0] !== AESKWP_IV || out.length - 8 !== padded)
      throw new Error("integrity check failed");
    for (let i = len; i < padded; i++)
      if (out[8 + i] !== 0)
        throw new Error("integrity check failed");
    out.subarray(0, 8).fill(0);
    return out.subarray(8, 8 + len);
  }
}));

// node_modules/@noble/hashes/esm/scrypt.js
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r2) {
  let head = oi + 0;
  let tail = oi + 16 * r2;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r2 - 1) * 16 + i];
  for (let i = 0; i < r2; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r: r2, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  anumber(N);
  anumber(r2);
  anumber(p);
  anumber(dkLen);
  anumber(asyncTick);
  anumber(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r2;
  const blockSize32 = blockSize / 4;
  const pow32 = Math.pow(2, 32);
  if (N <= 1 || (N & N - 1) !== 0 || N > pow32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, and less than 2^32");
  }
  if (p < 0 || p > (pow32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (pow32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error("Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of " + maxmem);
  }
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r: r2, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  clean(B, V, tmp);
  return res;
}
function scrypt(password, salt, opts) {
  const { N, r: r2, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  swap32IfBE(B32);
  for (let pi = 0; pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi + i];
    for (let i = 0, pos = 0; i < N - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r2);
      blockMixCb();
    }
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r2);
    blockMixCb();
    for (let i = 0; i < N; i++) {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r2);
      blockMixCb();
    }
  }
  swap32IfBE(B32);
  return scryptOutput(password, dkLen, B, V, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N, r: r2, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  swap32IfBE(B32);
  for (let pi = 0; pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi + i];
    let pos = 0;
    await asyncLoop(N - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r2);
      blockMixCb();
    });
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r2);
    blockMixCb();
    await asyncLoop(N, asyncTick, () => {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r2);
      blockMixCb();
    });
  }
  swap32IfBE(B32);
  return scryptOutput(password, dkLen, B, V, tmp);
}

// node_modules/viem/node_modules/ox/_esm/core/Keystore.js
function decrypt3(keystore, key, options = {}) {
  const { as = "Hex" } = options;
  const key_ = from(typeof key === "function" ? key() : key);
  const encKey = slice(key_, 0, 16);
  const macKey = slice(key_, 16, 32);
  const ciphertext = from(`0x${keystore.crypto.ciphertext}`);
  const mac = keccak256(concat(macKey, ciphertext));
  if (!isEqual(mac, from(`0x${keystore.crypto.mac}`)))
    throw new Error("corrupt keystore");
  const data = ctr(encKey, from(`0x${keystore.crypto.cipherparams.iv}`)).decrypt(ciphertext);
  if (as === "Hex")
    return toHex(data);
  return data;
}
function encrypt3(privateKey, key, options) {
  const { id = crypto.randomUUID(), kdf, kdfparams, iv } = options;
  const key_ = from(typeof key === "function" ? key() : key);
  const value_ = from(privateKey);
  const encKey = slice(key_, 0, 16);
  const macKey = slice(key_, 16, 32);
  const ciphertext = ctr(encKey, iv).encrypt(value_);
  const mac = keccak256(concat(macKey, ciphertext));
  return {
    crypto: {
      cipher: "aes-128-ctr",
      ciphertext: toHex(ciphertext).slice(2),
      cipherparams: { iv: toHex(iv).slice(2) },
      kdf,
      kdfparams,
      mac: toHex(mac).slice(2)
    },
    id,
    version: 3
  };
}
function pbkdf22(options) {
  const { iv, iterations = 262144, password } = options;
  const salt = options.salt ? from(options.salt) : random(32);
  const key = toHex(pbkdf2(sha256, password, salt, { c: iterations, dkLen: 32 }));
  return defineKey(() => key, {
    iv,
    kdfparams: {
      c: iterations,
      dklen: 32,
      prf: "hmac-sha256",
      salt: toHex(salt).slice(2)
    },
    kdf: "pbkdf2"
  });
}
async function pbkdf2Async2(options) {
  const { iv, iterations = 262144, password } = options;
  const salt = options.salt ? from(options.salt) : random(32);
  const key = toHex(await pbkdf2Async(sha256, password, salt, {
    c: iterations,
    dkLen: 32
  }));
  return defineKey(() => key, {
    iv,
    kdfparams: {
      c: iterations,
      dklen: 32,
      prf: "hmac-sha256",
      salt: toHex(salt).slice(2)
    },
    kdf: "pbkdf2"
  });
}
function scrypt2(options) {
  const { iv, n = 262144, password, p = 8, r: r2 = 1 } = options;
  const salt = options.salt ? from(options.salt) : random(32);
  const key = toHex(scrypt(password, salt, { N: n, dkLen: 32, r: r2, p }));
  return defineKey(() => key, {
    iv,
    kdfparams: {
      dklen: 32,
      n,
      p,
      r: r2,
      salt: toHex(salt).slice(2)
    },
    kdf: "scrypt"
  });
}
async function scryptAsync2(options) {
  const { iv, n = 262144, password } = options;
  const p = 8;
  const r2 = 1;
  const salt = options.salt ? from(options.salt) : random(32);
  const key = toHex(await scryptAsync(password, salt, { N: n, dkLen: 32, r: r2, p }));
  return defineKey(() => key, {
    iv,
    kdfparams: {
      dklen: 32,
      n,
      p,
      r: r2,
      salt: toHex(salt).slice(2)
    },
    kdf: "scrypt"
  });
}
function toKey(keystore, options) {
  const { crypto: crypto2 } = keystore;
  const { password } = options;
  const { cipherparams, kdf, kdfparams } = crypto2;
  const { iv } = cipherparams;
  const { c, n, p, r: r2, salt } = kdfparams;
  const [key] = (() => {
    switch (kdf) {
      case "scrypt":
        return scrypt2({
          iv: from(`0x${iv}`),
          n,
          p,
          r: r2,
          salt: from(`0x${salt}`),
          password
        });
      case "pbkdf2":
        return pbkdf22({
          iv: from(`0x${iv}`),
          iterations: c,
          password,
          salt: from(`0x${salt}`)
        });
      default:
        throw new Error("unsupported kdf");
    }
  })();
  return key;
}
async function toKeyAsync(keystore, options) {
  const { crypto: crypto2 } = keystore;
  const { password } = options;
  const { cipherparams, kdf, kdfparams } = crypto2;
  const { iv } = cipherparams;
  const { c, n, p, r: r2, salt } = kdfparams;
  const [key] = await (async () => {
    switch (kdf) {
      case "scrypt":
        return await scryptAsync2({
          iv: from(`0x${iv}`),
          n,
          p,
          r: r2,
          salt: from(`0x${salt}`),
          password
        });
      case "pbkdf2":
        return await pbkdf22({
          iv: from(`0x${iv}`),
          iterations: c,
          password,
          salt: from(`0x${salt}`)
        });
      default:
        throw new Error("unsupported kdf");
    }
  })();
  return key;
}
function defineKey(key, options) {
  const iv = options.iv ? from(options.iv) : random(16);
  return [key, { ...options, iv }];
}

// node_modules/viem/node_modules/ox/_esm/core/Mnemonic.js
var Mnemonic_exports = {};
__export(Mnemonic_exports, {
  czech: () => wordlist,
  english: () => wordlist2,
  french: () => wordlist3,
  italian: () => wordlist4,
  japanese: () => wordlist5,
  korean: () => wordlist6,
  path: () => path,
  portuguese: () => wordlist7,
  random: () => random2,
  simplifiedChinese: () => wordlist8,
  spanish: () => wordlist9,
  toHdKey: () => toHdKey,
  toPrivateKey: () => toPrivateKey,
  toSeed: () => toSeed,
  traditionalChinese: () => wordlist10,
  validate: () => validate5
});
function random2(wordlist11, options = {}) {
  const { strength = 128 } = options;
  return generateMnemonic(wordlist11, strength);
}
function toHdKey(mnemonic, options = {}) {
  const { passphrase } = options;
  const seed = toSeed(mnemonic, { passphrase });
  return fromSeed(seed);
}
function toPrivateKey(mnemonic, options = {}) {
  const { path: path2 = path(), passphrase } = options;
  const hdKey = toHdKey(mnemonic, { passphrase }).derive(path2);
  if (options.as === "Bytes")
    return from(hdKey.privateKey);
  return hdKey.privateKey;
}
function toSeed(mnemonic, options = {}) {
  const { passphrase } = options;
  const seed = mnemonicToSeedSync(mnemonic, passphrase);
  if (options.as === "Hex")
    return toHex(seed);
  return seed;
}
function validate5(mnemonic, wordlist11) {
  return validateMnemonic(mnemonic, wordlist11);
}

// node_modules/viem/node_modules/ox/_esm/core/PersonalMessage.js
var PersonalMessage_exports = {};
__export(PersonalMessage_exports, {
  encode: () => encode3,
  getSignPayload: () => getSignPayload
});
function encode3(data) {
  const message = from2(data);
  return concat2(
    // Personal Sign Format: `0x19 ‖ "Ethereum Signed Message:\n" ‖ message.length ‖ message`
    "0x19",
    fromString2("Ethereum Signed Message:\n" + size2(message)),
    message
  );
}
function getSignPayload(data) {
  return keccak256(encode3(data));
}

// node_modules/viem/node_modules/ox/_esm/core/Provider.js
var Provider_exports = {};
__export(Provider_exports, {
  AtomicReadyWalletRejectedUpgradeError: () => AtomicReadyWalletRejectedUpgradeError,
  AtomicityNotSupportedError: () => AtomicityNotSupportedError,
  BundleTooLargeError: () => BundleTooLargeError,
  ChainDisconnectedError: () => ChainDisconnectedError,
  DisconnectedError: () => DisconnectedError,
  DuplicateIdError: () => DuplicateIdError,
  IsUndefinedError: () => IsUndefinedError,
  ProviderRpcError: () => ProviderRpcError,
  SwitchChainError: () => SwitchChainError2,
  UnauthorizedError: () => UnauthorizedError,
  UnknownBundleIdError: () => UnknownBundleIdError,
  UnsupportedChainIdError: () => UnsupportedChainIdError,
  UnsupportedMethodError: () => UnsupportedMethodError,
  UnsupportedNonOptionalCapabilityError: () => UnsupportedNonOptionalCapabilityError,
  UserRejectedRequestError: () => UserRejectedRequestError2,
  createEmitter: () => createEmitter,
  from: () => from14,
  parseError: () => parseError2
});

// node_modules/viem/node_modules/ox/_esm/core/RpcResponse.js
var RpcResponse_exports = {};
__export(RpcResponse_exports, {
  BaseError: () => BaseError2,
  InternalError: () => InternalError,
  InvalidInputError: () => InvalidInputError,
  InvalidParamsError: () => InvalidParamsError,
  InvalidRequestError: () => InvalidRequestError,
  LimitExceededError: () => LimitExceededError,
  MethodNotFoundError: () => MethodNotFoundError,
  MethodNotSupportedError: () => MethodNotSupportedError,
  ParseError: () => ParseError,
  ResourceNotFoundError: () => ResourceNotFoundError,
  ResourceUnavailableError: () => ResourceUnavailableError,
  TransactionRejectedError: () => TransactionRejectedError,
  VersionNotSupportedError: () => VersionNotSupportedError,
  from: () => from13,
  parse: () => parse,
  parseError: () => parseError
});
function from13(response, options = {}) {
  const { request } = options;
  return {
    ...response,
    id: response.id ?? (request == null ? void 0 : request.id),
    jsonrpc: response.jsonrpc ?? request.jsonrpc
  };
}
function parse(response, options = {}) {
  const { raw = false } = options;
  const response_ = response;
  if (raw)
    return response;
  if (response_.error)
    throw parseError(response_.error);
  return response_.result;
}
function parseError(error) {
  const error_ = error;
  if (error_ instanceof Error && !("code" in error_))
    return new InternalError({
      cause: error_,
      data: error_,
      message: error_.message,
      stack: error_.stack
    });
  const { code } = error_;
  if (code === InternalError.code)
    return new InternalError(error_);
  if (code === InvalidInputError.code)
    return new InvalidInputError(error_);
  if (code === InvalidParamsError.code)
    return new InvalidParamsError(error_);
  if (code === InvalidRequestError.code)
    return new InvalidRequestError(error_);
  if (code === LimitExceededError.code)
    return new LimitExceededError(error_);
  if (code === MethodNotFoundError.code)
    return new MethodNotFoundError(error_);
  if (code === MethodNotSupportedError.code)
    return new MethodNotSupportedError(error_);
  if (code === ParseError.code)
    return new ParseError(error_);
  if (code === ResourceNotFoundError.code)
    return new ResourceNotFoundError(error_);
  if (code === ResourceUnavailableError.code)
    return new ResourceUnavailableError(error_);
  if (code === TransactionRejectedError.code)
    return new TransactionRejectedError(error_);
  if (code === VersionNotSupportedError.code)
    return new VersionNotSupportedError(error_);
  return new InternalError({
    cause: error_ instanceof Error ? error_ : void 0,
    data: error_,
    message: error_.message,
    stack: error_ instanceof Error ? error_.stack : void 0
  });
}
var BaseError2 = class extends Error {
  constructor(errorObject) {
    const { cause, code, message, data, stack } = errorObject;
    super(message, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.BaseError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "stack", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
    this.code = code;
    this.data = data;
    this.stack = stack ?? "";
  }
};
var InvalidInputError = class _InvalidInputError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      code: _InvalidInputError.code,
      data: parameters.data,
      message: parameters.message ?? "Missing or invalid parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidInputError"
    });
  }
};
Object.defineProperty(InvalidInputError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
var ResourceNotFoundError = class _ResourceNotFoundError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      code: _ResourceNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not found."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceNotFoundError"
    });
  }
};
Object.defineProperty(ResourceNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
var ResourceUnavailableError = class _ResourceUnavailableError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      code: _ResourceUnavailableError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not available."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceUnavailableError"
    });
  }
};
Object.defineProperty(ResourceUnavailableError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
var TransactionRejectedError = class _TransactionRejectedError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      code: _TransactionRejectedError.code,
      data: parameters.data,
      message: parameters.message ?? "Transaction creation failed."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.TransactionRejectedError"
    });
  }
};
Object.defineProperty(TransactionRejectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
var MethodNotSupportedError = class _MethodNotSupportedError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      code: _MethodNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "Method is not implemented."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotSupportedError"
    });
  }
};
Object.defineProperty(MethodNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
var LimitExceededError = class _LimitExceededError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      code: _LimitExceededError.code,
      data: parameters.data,
      message: parameters.message ?? "Rate limit exceeded."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.LimitExceededError"
    });
  }
};
Object.defineProperty(LimitExceededError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
var VersionNotSupportedError = class _VersionNotSupportedError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      code: _VersionNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "JSON-RPC version not supported."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.VersionNotSupportedError"
    });
  }
};
Object.defineProperty(VersionNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
var InvalidRequestError = class _InvalidRequestError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      code: _InvalidRequestError.code,
      data: parameters.data,
      message: parameters.message ?? "Input is not a valid JSON-RPC request."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidRequestError"
    });
  }
};
Object.defineProperty(InvalidRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
var MethodNotFoundError = class _MethodNotFoundError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      code: _MethodNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Method does not exist."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotFoundError"
    });
  }
};
Object.defineProperty(MethodNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
var InvalidParamsError = class _InvalidParamsError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      code: _InvalidParamsError.code,
      data: parameters.data,
      message: parameters.message ?? "Invalid method parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidParamsError"
    });
  }
};
Object.defineProperty(InvalidParamsError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
var InternalError = class _InternalError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      cause: parameters.cause,
      code: _InternalError.code,
      data: parameters.data,
      message: parameters.message ?? "Internal JSON-RPC error.",
      stack: parameters.stack
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InternalError"
    });
  }
};
Object.defineProperty(InternalError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
var ParseError = class _ParseError extends BaseError2 {
  constructor(parameters = {}) {
    super({
      code: _ParseError.code,
      data: parameters.data,
      message: parameters.message ?? "Failed to parse JSON-RPC response."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ParseError"
    });
  }
};
Object.defineProperty(ParseError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});

// node_modules/viem/node_modules/ox/_esm/core/Provider.js
var ProviderRpcError = class extends Error {
  constructor(code, message) {
    super(message);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderRpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = code;
    this.details = message;
  }
};
var UserRejectedRequestError2 = class extends ProviderRpcError {
  constructor({ message = "The user rejected the request." } = {}) {
    super(4001, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UserRejectedRequestError"
    });
  }
};
Object.defineProperty(UserRejectedRequestError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
var UnauthorizedError = class extends ProviderRpcError {
  constructor({ message = "The requested method and/or account has not been authorized by the user." } = {}) {
    super(4100, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnauthorizedError"
    });
  }
};
Object.defineProperty(UnauthorizedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
var UnsupportedMethodError = class extends ProviderRpcError {
  constructor({ message = "The provider does not support the requested method." } = {}) {
    super(4200, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedMethodError"
    });
  }
};
Object.defineProperty(UnsupportedMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
var DisconnectedError = class extends ProviderRpcError {
  constructor({ message = "The provider is disconnected from all chains." } = {}) {
    super(4900, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.DisconnectedError"
    });
  }
};
Object.defineProperty(DisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
var ChainDisconnectedError = class extends ProviderRpcError {
  constructor({ message = "The provider is not connected to the requested chain." } = {}) {
    super(4901, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.ChainDisconnectedError"
    });
  }
};
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
var SwitchChainError2 = class extends ProviderRpcError {
  constructor({ message = "An error occurred when attempting to switch chain." } = {}) {
    super(4902, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4902
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.SwitchChainError"
    });
  }
};
Object.defineProperty(SwitchChainError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
var UnsupportedNonOptionalCapabilityError = class extends ProviderRpcError {
  constructor({ message = "This Wallet does not support a capability that was not marked as optional." } = {}) {
    super(5700, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5700
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedNonOptionalCapabilityError"
    });
  }
};
Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5700
});
var UnsupportedChainIdError = class extends ProviderRpcError {
  constructor({ message = "This Wallet does not support the requested chain ID." } = {}) {
    super(5710, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5710
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedChainIdError"
    });
  }
};
Object.defineProperty(UnsupportedChainIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5710
});
var DuplicateIdError = class extends ProviderRpcError {
  constructor({ message = "There is already a bundle submitted with this ID." } = {}) {
    super(5720, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5720
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.DuplicateIdError"
    });
  }
};
Object.defineProperty(DuplicateIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5720
});
var UnknownBundleIdError = class extends ProviderRpcError {
  constructor({ message = "This bundle id is unknown / has not been submitted." } = {}) {
    super(5730, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5730
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnknownBundleIdError"
    });
  }
};
Object.defineProperty(UnknownBundleIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5730
});
var BundleTooLargeError = class extends ProviderRpcError {
  constructor({ message = "The call bundle is too large for the Wallet to process." } = {}) {
    super(5740, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5740
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.BundleTooLargeError"
    });
  }
};
Object.defineProperty(BundleTooLargeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5740
});
var AtomicReadyWalletRejectedUpgradeError = class extends ProviderRpcError {
  constructor({ message = "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade." } = {}) {
    super(5750, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5750
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.AtomicReadyWalletRejectedUpgradeError"
    });
  }
};
Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5750
});
var AtomicityNotSupportedError = class extends ProviderRpcError {
  constructor({ message = "The wallet does not support atomic execution but the request requires it." } = {}) {
    super(5760, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5760
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.AtomicityNotSupportedError"
    });
  }
};
Object.defineProperty(AtomicityNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5760
});
function createEmitter() {
  const emitter = new import_index.default();
  return {
    get eventNames() {
      return emitter.eventNames.bind(emitter);
    },
    get listenerCount() {
      return emitter.listenerCount.bind(emitter);
    },
    get listeners() {
      return emitter.listeners.bind(emitter);
    },
    addListener: emitter.addListener.bind(emitter),
    emit: emitter.emit.bind(emitter),
    off: emitter.off.bind(emitter),
    on: emitter.on.bind(emitter),
    once: emitter.once.bind(emitter),
    removeAllListeners: emitter.removeAllListeners.bind(emitter),
    removeListener: emitter.removeListener.bind(emitter)
  };
}
function from14(provider, options = {}) {
  var _a, _b;
  const { includeEvents = true } = options;
  if (!provider)
    throw new IsUndefinedError();
  return {
    ...includeEvents ? {
      on: (_a = provider.on) == null ? void 0 : _a.bind(provider),
      removeListener: (_b = provider.removeListener) == null ? void 0 : _b.bind(provider)
    } : {},
    async request(args) {
      try {
        const result = await provider.request(args);
        if (result && typeof result === "object" && "jsonrpc" in result)
          return parse(result);
        return result;
      } catch (error) {
        throw parseError2(error);
      }
    }
  };
}
function parseError2(error) {
  const error_ = parseError(error);
  if (error_ instanceof InternalError) {
    if (!error_.data)
      return error_;
    const { code } = error_.data;
    if (code === DisconnectedError.code)
      return new DisconnectedError(error_);
    if (code === ChainDisconnectedError.code)
      return new ChainDisconnectedError(error_);
    if (code === UserRejectedRequestError2.code)
      return new UserRejectedRequestError2(error_);
    if (code === UnauthorizedError.code)
      return new UnauthorizedError(error_);
    if (code === UnsupportedMethodError.code)
      return new UnsupportedMethodError(error_);
    if (code === SwitchChainError2.code)
      return new SwitchChainError2(error_);
    if (code === AtomicReadyWalletRejectedUpgradeError.code)
      return new AtomicReadyWalletRejectedUpgradeError(error_);
    if (code === AtomicityNotSupportedError.code)
      return new AtomicityNotSupportedError(error_);
    if (code === BundleTooLargeError.code)
      return new BundleTooLargeError(error_);
    if (code === UnknownBundleIdError.code)
      return new UnknownBundleIdError(error_);
    if (code === DuplicateIdError.code)
      return new DuplicateIdError(error_);
    if (code === UnsupportedChainIdError.code)
      return new UnsupportedChainIdError(error_);
    if (code === UnsupportedNonOptionalCapabilityError.code)
      return new UnsupportedNonOptionalCapabilityError(error_);
  }
  return error_;
}
var IsUndefinedError = class extends BaseError {
  constructor() {
    super("`provider` is undefined.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.IsUndefinedError"
    });
  }
};

// node_modules/viem/node_modules/ox/_esm/core/RpcRequest.js
var RpcRequest_exports = {};
__export(RpcRequest_exports, {
  createStore: () => createStore,
  from: () => from15
});
function createStore(options = {}) {
  let id = options.id ?? 0;
  return {
    prepare(options2) {
      return from15({
        id: id++,
        ...options2
      });
    },
    get id() {
      return id;
    }
  };
}
function from15(options) {
  return {
    ...options,
    jsonrpc: "2.0"
  };
}

// node_modules/viem/node_modules/ox/_esm/core/RpcSchema.js
var RpcSchema_exports = {};
__export(RpcSchema_exports, {
  from: () => from16
});
function from16() {
  return null;
}

// node_modules/viem/node_modules/ox/_esm/core/RpcTransport.js
var RpcTransport_exports = {};
__export(RpcTransport_exports, {
  HttpError: () => HttpError,
  MalformedResponseError: () => MalformedResponseError,
  fromHttp: () => fromHttp
});

// node_modules/viem/node_modules/ox/_esm/core/internal/promise.js
function withTimeout2(fn, options) {
  const { errorInstance = new TimeoutError(), timeout, signal } = options;
  return new Promise((resolve, reject) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0)
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        resolve(await fn({ signal: controller.signal }));
      } catch (err) {
        if ((err == null ? void 0 : err.name) === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
var TimeoutError = class extends BaseError {
  constructor() {
    super("Operation timed out.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Promise.TimeoutError"
    });
  }
};

// node_modules/viem/node_modules/ox/_esm/core/internal/rpcTransport.js
function create3(transport, options_root) {
  const requestStore = createStore();
  return {
    request: async ({ method, params }, options = {}) => {
      const body = requestStore.prepare({ method, params });
      const data = await transport.request(body, options);
      return parse(data, {
        raw: options.raw ?? (options_root == null ? void 0 : options_root.raw)
      });
    }
  };
}

// node_modules/viem/node_modules/ox/_esm/core/RpcTransport.js
function fromHttp(url, options = {}) {
  return create3({
    async request(body_, options_) {
      const { fetchFn = options.fetchFn ?? fetch, fetchOptions: fetchOptions_ = options.fetchOptions, timeout = options.timeout ?? 1e4 } = options_;
      const body = JSON.stringify(body_);
      const fetchOptions = typeof fetchOptions_ === "function" ? await fetchOptions_(body_) : fetchOptions_;
      const response = await withTimeout2(({ signal }) => {
        const init = {
          ...fetchOptions,
          body,
          headers: {
            "Content-Type": "application/json",
            ...fetchOptions == null ? void 0 : fetchOptions.headers
          },
          method: (fetchOptions == null ? void 0 : fetchOptions.method) ?? "POST",
          signal: (fetchOptions == null ? void 0 : fetchOptions.signal) ?? (timeout > 0 ? signal : null)
        };
        const request = new Request(url, init);
        return fetchFn(request);
      }, {
        timeout,
        signal: true
      });
      const data = await (async () => {
        var _a;
        if ((_a = response.headers.get("Content-Type")) == null ? void 0 : _a.startsWith("application/json"))
          return response.json();
        return response.text().then((data2) => {
          try {
            return JSON.parse(data2 || "{}");
          } catch (_err) {
            if (response.ok)
              throw new MalformedResponseError({
                response: data2
              });
            return { error: data2 };
          }
        });
      })();
      if (!response.ok)
        throw new HttpError({
          body,
          details: JSON.stringify(data.error) ?? response.statusText,
          response,
          url
        });
      return data;
    }
  }, { raw: options.raw });
}
var HttpError = class extends BaseError {
  constructor({ body, details, response, url }) {
    super("HTTP request failed.", {
      details,
      metaMessages: [
        `Status: ${response.status}`,
        `URL: ${getUrl(url)}`,
        body ? `Body: ${JSON.stringify(body)}` : void 0
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcTransport.HttpError"
    });
  }
};
var MalformedResponseError = class extends BaseError {
  constructor({ response }) {
    super("HTTP Response could not be parsed as JSON.", {
      metaMessages: [`Response: ${response}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcTransport.MalformedResponseError"
    });
  }
};

// node_modules/viem/node_modules/ox/_esm/core/Siwe.js
var Siwe_exports = {};
__export(Siwe_exports, {
  InvalidMessageFieldError: () => InvalidMessageFieldError,
  createMessage: () => createMessage,
  domainRegex: () => domainRegex,
  generateNonce: () => generateNonce,
  ipRegex: () => ipRegex,
  isUri: () => isUri,
  localhostRegex: () => localhostRegex,
  nonceRegex: () => nonceRegex,
  parseMessage: () => parseMessage,
  prefixRegex: () => prefixRegex,
  schemeRegex: () => schemeRegex,
  suffixRegex: () => suffixRegex,
  validateMessage: () => validateMessage
});

// node_modules/viem/node_modules/ox/_esm/core/internal/uid.js
var size3 = 256;
var index = size3;
var buffer;
function uid(length = 11) {
  if (!buffer || index + length > size3 * 2) {
    buffer = "";
    index = 0;
    for (let i = 0; i < size3; i++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length);
}

// node_modules/viem/node_modules/ox/_esm/core/Siwe.js
var domainRegex = /^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/;
var ipRegex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/;
var localhostRegex = /^localhost(:[0-9]{1,5})?$/;
var nonceRegex = /^[a-zA-Z0-9]{8,}$/;
var schemeRegex = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/;
var prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
var suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function createMessage(value) {
  const { chainId, domain, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version: version5 } = value;
  {
    if (chainId !== Math.floor(chainId))
      throw new InvalidMessageFieldError({
        field: "chainId",
        metaMessages: [
          "- Chain ID must be a EIP-155 chain ID.",
          "- See https://eips.ethereum.org/EIPS/eip-155",
          "",
          `Provided value: ${chainId}`
        ]
      });
    if (!(domainRegex.test(domain) || ipRegex.test(domain) || localhostRegex.test(domain)))
      throw new InvalidMessageFieldError({
        field: "domain",
        metaMessages: [
          "- Domain must be an RFC 3986 authority.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${domain}`
        ]
      });
    if (!nonceRegex.test(nonce))
      throw new InvalidMessageFieldError({
        field: "nonce",
        metaMessages: [
          "- Nonce must be at least 8 characters.",
          "- Nonce must be alphanumeric.",
          "",
          `Provided value: ${nonce}`
        ]
      });
    if (!isUri(uri))
      throw new InvalidMessageFieldError({
        field: "uri",
        metaMessages: [
          "- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${uri}`
        ]
      });
    if (version5 !== "1")
      throw new InvalidMessageFieldError({
        field: "version",
        metaMessages: [
          "- Version must be '1'.",
          "",
          `Provided value: ${version5}`
        ]
      });
    if (scheme && !schemeRegex.test(scheme))
      throw new InvalidMessageFieldError({
        field: "scheme",
        metaMessages: [
          "- Scheme must be an RFC 3986 URI scheme.",
          "- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1",
          "",
          `Provided value: ${scheme}`
        ]
      });
    const statement2 = value.statement;
    if (statement2 == null ? void 0 : statement2.includes("\n"))
      throw new InvalidMessageFieldError({
        field: "statement",
        metaMessages: [
          "- Statement must not include '\\n'.",
          "",
          `Provided value: ${statement2}`
        ]
      });
  }
  const address = from4(value.address, { checksum: true });
  const origin = (() => {
    if (scheme)
      return `${scheme}://${domain}`;
    return domain;
  })();
  const statement = (() => {
    if (!value.statement)
      return "";
    return `${value.statement}
`;
  })();
  const prefix = `${origin} wants you to sign in with your Ethereum account:
${address}

${statement}`;
  let suffix = `URI: ${uri}
Version: ${version5}
Chain ID: ${chainId}
Nonce: ${nonce}
Issued At: ${issuedAt.toISOString()}`;
  if (expirationTime)
    suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
  if (notBefore)
    suffix += `
Not Before: ${notBefore.toISOString()}`;
  if (requestId)
    suffix += `
Request ID: ${requestId}`;
  if (resources) {
    let content2 = "\nResources:";
    for (const resource of resources) {
      if (!isUri(resource))
        throw new InvalidMessageFieldError({
          field: "resources",
          metaMessages: [
            "- Every resource must be a RFC 3986 URI.",
            "- See https://www.rfc-editor.org/rfc/rfc3986",
            "",
            `Provided value: ${resource}`
          ]
        });
      content2 += `
- ${resource}`;
    }
    suffix += content2;
  }
  return `${prefix}
${suffix}`;
}
function generateNonce() {
  return uid(96);
}
function isUri(value) {
  if (/[^a-z0-9:/?#[\]@!$&'()*+,;=.\-_~%]/i.test(value))
    return false;
  if (/%[^0-9a-f]/i.test(value))
    return false;
  if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value))
    return false;
  const splitted = splitUri(value);
  const scheme = splitted[1];
  const authority = splitted[2];
  const path2 = splitted[3];
  const query = splitted[4];
  const fragment = splitted[5];
  if (!((scheme == null ? void 0 : scheme.length) && path2 && path2.length >= 0))
    return false;
  if (authority == null ? void 0 : authority.length) {
    if (!(path2.length === 0 || /^\//.test(path2)))
      return false;
  } else {
    if (/^\/\//.test(path2))
      return false;
  }
  if (!/^[a-z][a-z0-9+\-.]*$/.test(scheme.toLowerCase()))
    return false;
  let out = "";
  out += `${scheme}:`;
  if (authority == null ? void 0 : authority.length)
    out += `//${authority}`;
  out += path2;
  if (query == null ? void 0 : query.length)
    out += `?${query}`;
  if (fragment == null ? void 0 : fragment.length)
    out += `#${fragment}`;
  return out;
}
function splitUri(value) {
  return value.match(/(?:([^:/?#]+):)?(?:\/\/([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
}
function parseMessage(message) {
  var _a, _b, _c;
  const { scheme, statement, ...prefix } = ((_a = message.match(prefixRegex)) == null ? void 0 : _a.groups) ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = ((_b = message.match(suffixRegex)) == null ? void 0 : _b.groups) ?? {};
  const resources = (_c = message.split("Resources:")[1]) == null ? void 0 : _c.split("\n- ").slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
function validateMessage(value) {
  const { address, domain, message, nonce, scheme, time = /* @__PURE__ */ new Date() } = value;
  if (domain && message.domain !== domain)
    return false;
  if (nonce && message.nonce !== nonce)
    return false;
  if (scheme && message.scheme !== scheme)
    return false;
  if (message.expirationTime && time >= message.expirationTime)
    return false;
  if (message.notBefore && time < message.notBefore)
    return false;
  try {
    if (!message.address)
      return false;
    if (address && !isEqual2(message.address, address))
      return false;
  } catch {
    return false;
  }
  return true;
}
var InvalidMessageFieldError = class extends BaseError {
  constructor(parameters) {
    const { field, metaMessages } = parameters;
    super(`Invalid Sign-In with Ethereum message field "${field}".`, {
      metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Siwe.InvalidMessageFieldError"
    });
  }
};

// node_modules/viem/node_modules/ox/_esm/core/StateOverrides.js
var StateOverrides_exports = {};
__export(StateOverrides_exports, {
  fromRpc: () => fromRpc5,
  toRpc: () => toRpc6
});
function fromRpc5(rpcStateOverrides) {
  const stateOverrides = {};
  for (const [address, accountOverridesRpc] of Object.entries(rpcStateOverrides)) {
    const accountOverrides = {};
    if (accountOverridesRpc.balance)
      accountOverrides.balance = BigInt(accountOverridesRpc.balance);
    if (accountOverridesRpc.code)
      accountOverrides.code = accountOverridesRpc.code;
    if (accountOverridesRpc.movePrecompileToAddress)
      accountOverrides.movePrecompileToAddress = accountOverridesRpc.movePrecompileToAddress;
    if (accountOverridesRpc.nonce)
      accountOverrides.nonce = BigInt(accountOverridesRpc.nonce);
    if (accountOverridesRpc.state)
      accountOverrides.state = accountOverridesRpc.state;
    if (accountOverridesRpc.stateDiff)
      accountOverrides.stateDiff = accountOverridesRpc.stateDiff;
    stateOverrides[address] = accountOverrides;
  }
  return stateOverrides;
}
function toRpc6(stateOverrides) {
  const rpcStateOverrides = {};
  for (const [address, accountOverrides] of Object.entries(stateOverrides)) {
    const accountOverridesRpc = {};
    if (typeof accountOverrides.balance === "bigint")
      accountOverridesRpc.balance = fromNumber2(accountOverrides.balance);
    if (accountOverrides.code)
      accountOverridesRpc.code = accountOverrides.code;
    if (accountOverrides.movePrecompileToAddress)
      accountOverridesRpc.movePrecompileToAddress = accountOverrides.movePrecompileToAddress;
    if (typeof accountOverrides.nonce === "bigint")
      accountOverridesRpc.nonce = fromNumber2(accountOverrides.nonce);
    if (accountOverrides.state)
      accountOverridesRpc.state = accountOverrides.state;
    if (accountOverrides.stateDiff)
      accountOverridesRpc.stateDiff = accountOverrides.stateDiff;
    rpcStateOverrides[address] = accountOverridesRpc;
  }
  return rpcStateOverrides;
}

// node_modules/viem/node_modules/ox/_esm/core/TransactionEnvelope.js
var TransactionEnvelope_exports = {};
__export(TransactionEnvelope_exports, {
  FeeCapTooHighError: () => FeeCapTooHighError,
  GasPriceTooHighError: () => GasPriceTooHighError,
  InvalidChainIdError: () => InvalidChainIdError,
  InvalidSerializedError: () => InvalidSerializedError,
  TipAboveFeeCapError: () => TipAboveFeeCapError
});

// node_modules/viem/node_modules/ox/_esm/core/Value.js
var Value_exports = {};
__export(Value_exports, {
  InvalidDecimalNumberError: () => InvalidDecimalNumberError,
  exponents: () => exponents,
  format: () => format4,
  formatEther: () => formatEther,
  formatGwei: () => formatGwei,
  from: () => from17,
  fromEther: () => fromEther,
  fromGwei: () => fromGwei
});
var exponents = {
  wei: 0,
  gwei: 9,
  szabo: 12,
  finney: 15,
  ether: 18
};
function format4(value, decimals = 0) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer2, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer2 || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatEther(wei, unit = "wei") {
  return format4(wei, exponents.ether - exponents[unit]);
}
function formatGwei(wei, unit = "wei") {
  return format4(wei, exponents.gwei - exponents[unit]);
}
function from17(value, decimals = 0) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value))
    throw new InvalidDecimalNumberError({ value });
  let [integer2 = "", fraction = "0"] = value.split(".");
  const negative = integer2.startsWith("-");
  if (negative)
    integer2 = integer2.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer2 = `${BigInt(integer2) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left, unit, right] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded = Math.round(Number(`${unit}.${right}`));
    if (rounded > 9)
      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
    else
      fraction = `${left}${rounded}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer2 = `${BigInt(integer2) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer2}${fraction}`);
}
function fromEther(ether, unit = "wei") {
  return from17(ether, exponents.ether - exponents[unit]);
}
function fromGwei(gwei, unit = "wei") {
  return from17(gwei, exponents.gwei - exponents[unit]);
}
var InvalidDecimalNumberError = class extends BaseError {
  constructor({ value }) {
    super(`Value \`${value}\` is not a valid decimal number.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Value.InvalidDecimalNumberError"
    });
  }
};

// node_modules/viem/node_modules/ox/_esm/core/TransactionEnvelope.js
var FeeCapTooHighError = class extends BaseError {
  constructor({ feeCap } = {}) {
    super(`The fee cap (\`maxFeePerGas\`/\`maxPriorityFeePerGas\`${feeCap ? ` = ${formatGwei(feeCap)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.FeeCapTooHighError"
    });
  }
};
var GasPriceTooHighError = class extends BaseError {
  constructor({ gasPrice } = {}) {
    super(`The gas price (\`gasPrice\`${gasPrice ? ` = ${formatGwei(gasPrice)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.GasPriceTooHighError"
    });
  }
};
var InvalidChainIdError = class extends BaseError {
  constructor({ chainId }) {
    super(typeof chainId !== "undefined" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.InvalidChainIdError"
    });
  }
};
var InvalidSerializedError = class extends BaseError {
  constructor({ attributes, serialized, type: type6 }) {
    const missing = Object.entries(attributes).map(([key, value]) => typeof value === "undefined" ? key : void 0).filter(Boolean);
    super(`Invalid serialized transaction of type "${type6}" was provided.`, {
      metaMessages: [
        `Serialized Transaction: "${serialized}"`,
        missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
      ].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.InvalidSerializedError"
    });
  }
};
var TipAboveFeeCapError = class extends BaseError {
  constructor({ maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.TipAboveFeeCapError"
    });
  }
};

// node_modules/viem/node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js
var TransactionEnvelopeEip1559_exports = {};
__export(TransactionEnvelopeEip1559_exports, {
  assert: () => assert2,
  deserialize: () => deserialize,
  from: () => from18,
  getSignPayload: () => getSignPayload2,
  hash: () => hash2,
  serialize: () => serialize,
  serializedType: () => serializedType,
  toRpc: () => toRpc7,
  type: () => type,
  validate: () => validate6
});
var serializedType = "0x02";
var type = "eip1559";
function assert2(envelope) {
  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to: to2 } = envelope;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to2)
    assert(to2, { strict: false });
  if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ feeCap: maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({
      maxFeePerGas,
      maxPriorityFeePerGas
    });
}
function deserialize(serialized) {
  const transactionArray = toHex2(slice2(serialized, 1));
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to2, value, data, accessList, yParity, r2, s] = transactionArray;
  if (!(transactionArray.length === 9 || transactionArray.length === 12))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to2,
        value,
        data,
        accessList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r2,
          s
        } : {}
      },
      serialized,
      type
    });
  let transaction = {
    chainId: Number(chainId),
    type
  };
  if (validate2(to2) && to2 !== "0x")
    transaction.to = to2;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce))
    transaction.nonce = nonce === "0x" ? 0n : BigInt(nonce);
  if (validate2(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate2(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate2(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList2(accessList);
  const signature = r2 && s && yParity ? fromTuple([yParity, r2, s]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert2(transaction);
  return transaction;
}
function from18(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize(envelope) : envelope;
  assert2(envelope_);
  return {
    ...envelope_,
    ...signature ? from5(signature) : {},
    type: "eip1559"
  };
}
function getSignPayload2(envelope) {
  return hash2(envelope, { presign: true });
}
function hash2(envelope, options = {}) {
  const { presign } = options;
  return keccak256(serialize({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize(envelope, options = {}) {
  const { chainId, gas, nonce, to: to2, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;
  assert2(envelope);
  const accessTupleList = toTupleList2(accessList);
  const signature = extract(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber2(maxFeePerGas) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to2 ?? "0x",
    value ? fromNumber2(value) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat2(serializedType, fromHex2(serialized));
}
function toRpc7(envelope) {
  const signature = extract(envelope);
  return {
    ...envelope,
    chainId: fromNumber2(envelope.chainId),
    data: envelope.data ?? envelope.input,
    type: "0x2",
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.maxFeePerGas === "bigint" ? { maxFeePerGas: fromNumber2(envelope.maxFeePerGas) } : {},
    ...typeof envelope.maxPriorityFeePerGas === "bigint" ? {
      maxPriorityFeePerGas: fromNumber2(envelope.maxPriorityFeePerGas)
    } : {},
    ...signature ? toRpc2(signature) : {}
  };
}
function validate6(envelope) {
  try {
    assert2(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/viem/node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js
var TransactionEnvelopeEip2930_exports = {};
__export(TransactionEnvelopeEip2930_exports, {
  assert: () => assert3,
  deserialize: () => deserialize2,
  from: () => from19,
  getSignPayload: () => getSignPayload3,
  hash: () => hash3,
  serialize: () => serialize2,
  serializedType: () => serializedType2,
  toRpc: () => toRpc8,
  type: () => type2,
  validate: () => validate7
});
var serializedType2 = "0x01";
var type2 = "eip2930";
function assert3(envelope) {
  const { chainId, gasPrice, to: to2 } = envelope;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to2)
    assert(to2, { strict: false });
  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)
    throw new GasPriceTooHighError({ gasPrice });
}
function deserialize2(serialized) {
  const transactionArray = toHex2(slice2(serialized, 1));
  const [chainId, nonce, gasPrice, gas, to2, value, data, accessList, yParity, r2, s] = transactionArray;
  if (!(transactionArray.length === 8 || transactionArray.length === 11))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        gasPrice,
        gas,
        to: to2,
        value,
        data,
        accessList,
        ...transactionArray.length > 8 ? {
          yParity,
          r: r2,
          s
        } : {}
      },
      serialized,
      type: type2
    });
  let transaction = {
    chainId: Number(chainId),
    type: type2
  };
  if (validate2(to2) && to2 !== "0x")
    transaction.to = to2;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce))
    transaction.nonce = nonce === "0x" ? 0n : BigInt(nonce);
  if (validate2(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate2(gasPrice) && gasPrice !== "0x")
    transaction.gasPrice = BigInt(gasPrice);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList2(accessList);
  const signature = r2 && s && yParity ? fromTuple([yParity, r2, s]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert3(transaction);
  return transaction;
}
function from19(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize2(envelope) : envelope;
  assert3(envelope_);
  return {
    ...envelope_,
    ...signature ? from5(signature) : {},
    type: "eip2930"
  };
}
function getSignPayload3(envelope) {
  return hash3(envelope, { presign: true });
}
function hash3(envelope, options = {}) {
  const { presign } = options;
  return keccak256(serialize2({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize2(envelope, options = {}) {
  const { chainId, gas, data, input, nonce, to: to2, value, accessList, gasPrice } = envelope;
  assert3(envelope);
  const accessTupleList = toTupleList2(accessList);
  const signature = extract(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    gasPrice ? fromNumber2(gasPrice) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to2 ?? "0x",
    value ? fromNumber2(value) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat2("0x01", fromHex2(serialized));
}
function toRpc8(envelope) {
  const signature = extract(envelope);
  return {
    ...envelope,
    chainId: fromNumber2(envelope.chainId),
    data: envelope.data ?? envelope.input,
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.gasPrice === "bigint" ? { gasPrice: fromNumber2(envelope.gasPrice) } : {},
    type: "0x1",
    ...signature ? toRpc2(signature) : {}
  };
}
function validate7(envelope) {
  try {
    assert3(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/viem/node_modules/ox/_esm/core/TransactionEnvelopeEip4844.js
var TransactionEnvelopeEip4844_exports = {};
__export(TransactionEnvelopeEip4844_exports, {
  assert: () => assert4,
  deserialize: () => deserialize3,
  from: () => from20,
  getSignPayload: () => getSignPayload4,
  hash: () => hash4,
  serialize: () => serialize3,
  serializedType: () => serializedType3,
  toRpc: () => toRpc9,
  type: () => type3,
  validate: () => validate8
});
var serializedType3 = "0x03";
var type3 = "eip4844";
function assert4(envelope) {
  const { blobVersionedHashes } = envelope;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0)
      throw new EmptyBlobVersionedHashesError();
    for (const hash8 of blobVersionedHashes) {
      const size5 = size2(hash8);
      const version5 = toNumber(slice2(hash8, 0, 1));
      if (size5 !== 32)
        throw new InvalidVersionedHashSizeError({ hash: hash8, size: size5 });
      if (version5 !== versionedHashVersion)
        throw new InvalidVersionedHashVersionError({
          hash: hash8,
          version: version5
        });
    }
  }
  assert2(envelope);
}
function deserialize3(serialized) {
  const transactionOrWrapperArray = toHex2(slice2(serialized, 1));
  const hasNetworkWrapper = transactionOrWrapperArray.length === 4;
  const transactionArray = hasNetworkWrapper ? transactionOrWrapperArray[0] : transactionOrWrapperArray;
  const wrapperArray = hasNetworkWrapper ? transactionOrWrapperArray.slice(1) : [];
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to2, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, yParity, r2, s] = transactionArray;
  const [blobs, commitments, proofs] = wrapperArray;
  if (!(transactionArray.length === 11 || transactionArray.length === 14))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to2,
        value,
        data,
        accessList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r2,
          s
        } : {}
      },
      serialized,
      type: type3
    });
  let transaction = {
    blobVersionedHashes,
    chainId: Number(chainId),
    type: type3
  };
  if (validate2(to2) && to2 !== "0x")
    transaction.to = to2;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce))
    transaction.nonce = nonce === "0x" ? 0n : BigInt(nonce);
  if (validate2(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate2(maxFeePerBlobGas) && maxFeePerBlobGas !== "0x")
    transaction.maxFeePerBlobGas = BigInt(maxFeePerBlobGas);
  if (validate2(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate2(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if ((accessList == null ? void 0 : accessList.length) !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList2(accessList);
  if (blobs && commitments && proofs)
    transaction.sidecars = toSidecars(blobs, {
      commitments,
      proofs
    });
  const signature = r2 && s && yParity ? fromTuple([yParity, r2, s]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert4(transaction);
  return transaction;
}
function from20(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize3(envelope) : envelope;
  assert4(envelope_);
  return {
    ...envelope_,
    ...signature ? from5(signature) : {},
    type: "eip4844"
  };
}
function getSignPayload4(envelope) {
  return hash4(envelope, { presign: true });
}
function hash4(envelope, options = {}) {
  const { presign } = options;
  return keccak256(serialize3({
    ...envelope,
    ...presign ? {
      sidecars: void 0,
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize3(envelope, options = {}) {
  const { blobVersionedHashes, chainId, gas, nonce, to: to2, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = envelope;
  assert4(envelope);
  const accessTupleList = toTupleList2(accessList);
  const signature = extract(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber2(maxFeePerGas) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to2 ?? "0x",
    value ? fromNumber2(value) : "0x",
    data ?? "0x",
    accessTupleList,
    maxFeePerBlobGas ? fromNumber2(maxFeePerBlobGas) : "0x",
    blobVersionedHashes ?? [],
    ...signature ? toTuple(signature) : []
  ];
  const sidecars = options.sidecars || envelope.sidecars;
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars)
    for (let i = 0; i < sidecars.length; i++) {
      const { blob, commitment, proof } = sidecars[i];
      blobs.push(blob);
      commitments.push(commitment);
      proofs.push(proof);
    }
  return concat2("0x03", sidecars ? (
    // If sidecars are provided, envelope turns into a "network wrapper":
    fromHex2([serialized, blobs, commitments, proofs])
  ) : (
    // Otherwise, standard envelope is used:
    fromHex2(serialized)
  ));
}
function toRpc9(envelope) {
  const signature = extract(envelope);
  return {
    ...envelope,
    chainId: fromNumber2(envelope.chainId),
    data: envelope.data ?? envelope.input,
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.maxFeePerBlobGas === "bigint" ? { maxFeePerBlobGas: fromNumber2(envelope.maxFeePerBlobGas) } : {},
    ...typeof envelope.maxFeePerGas === "bigint" ? { maxFeePerGas: fromNumber2(envelope.maxFeePerGas) } : {},
    ...typeof envelope.maxPriorityFeePerGas === "bigint" ? { maxPriorityFeePerGas: fromNumber2(envelope.maxPriorityFeePerGas) } : {},
    type: "0x3",
    ...signature ? toRpc2(signature) : {}
  };
}
function validate8(envelope) {
  try {
    assert4(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/viem/node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js
var TransactionEnvelopeEip7702_exports = {};
__export(TransactionEnvelopeEip7702_exports, {
  assert: () => assert5,
  deserialize: () => deserialize4,
  from: () => from21,
  getSignPayload: () => getSignPayload5,
  hash: () => hash5,
  serialize: () => serialize4,
  serializedType: () => serializedType4,
  type: () => type4,
  validate: () => validate9
});
var serializedType4 = "0x04";
var type4 = "eip7702";
function assert5(envelope) {
  const { authorizationList } = envelope;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const { address, chainId } = authorization;
      if (address)
        assert(address, { strict: false });
      if (Number(chainId) < 0)
        throw new InvalidChainIdError({ chainId });
    }
  }
  assert2(envelope);
}
function deserialize4(serialized) {
  const transactionArray = toHex2(slice2(serialized, 1));
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to2, value, data, accessList, authorizationList, yParity, r2, s] = transactionArray;
  if (!(transactionArray.length === 10 || transactionArray.length === 13))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to2,
        value,
        data,
        accessList,
        authorizationList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r2,
          s
        } : {}
      },
      serialized,
      type: type4
    });
  let transaction = {
    chainId: Number(chainId),
    type: type4
  };
  if (validate2(to2) && to2 !== "0x")
    transaction.to = to2;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce))
    transaction.nonce = nonce === "0x" ? 0n : BigInt(nonce);
  if (validate2(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate2(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate2(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList2(accessList);
  if (authorizationList !== "0x")
    transaction.authorizationList = fromTupleList(authorizationList);
  const signature = r2 && s && yParity ? fromTuple([yParity, r2, s]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert5(transaction);
  return transaction;
}
function from21(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize4(envelope) : envelope;
  assert5(envelope_);
  return {
    ...envelope_,
    ...signature ? from5(signature) : {},
    type: "eip7702"
  };
}
function getSignPayload5(envelope) {
  return hash5(envelope, { presign: true });
}
function hash5(envelope, options = {}) {
  const { presign } = options;
  return keccak256(serialize4({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0
    } : {}
  }));
}
function serialize4(envelope, options = {}) {
  const { authorizationList, chainId, gas, nonce, to: to2, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;
  assert5(envelope);
  const accessTupleList = toTupleList2(accessList);
  const authorizationTupleList = toTupleList(authorizationList);
  const signature = extract(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber2(maxFeePerGas) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to2 ?? "0x",
    value ? fromNumber2(value) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    authorizationTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat2(serializedType4, fromHex2(serialized));
}
function validate9(envelope) {
  try {
    assert5(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/viem/node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js
var TransactionEnvelopeLegacy_exports = {};
__export(TransactionEnvelopeLegacy_exports, {
  assert: () => assert6,
  deserialize: () => deserialize5,
  from: () => from22,
  getSignPayload: () => getSignPayload6,
  hash: () => hash6,
  serialize: () => serialize5,
  toRpc: () => toRpc10,
  type: () => type5,
  validate: () => validate10
});
var type5 = "legacy";
function assert6(envelope) {
  const { chainId, gasPrice, to: to2 } = envelope;
  if (to2)
    assert(to2, { strict: false });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)
    throw new GasPriceTooHighError({ gasPrice });
}
function deserialize5(serialized) {
  const tuple = toHex2(serialized);
  const [nonce, gasPrice, gas, to2, value, data, chainIdOrV_, r2, s] = tuple;
  if (!(tuple.length === 6 || tuple.length === 9))
    throw new InvalidSerializedError({
      attributes: {
        nonce,
        gasPrice,
        gas,
        to: to2,
        value,
        data,
        ...tuple.length > 6 ? {
          v: chainIdOrV_,
          r: r2,
          s
        } : {}
      },
      serialized,
      type: type5
    });
  const transaction = {
    type: type5
  };
  if (validate2(to2) && to2 !== "0x")
    transaction.to = to2;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce))
    transaction.nonce = nonce === "0x" ? 0n : BigInt(nonce);
  if (validate2(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate2(gasPrice) && gasPrice !== "0x")
    transaction.gasPrice = BigInt(gasPrice);
  if (tuple.length === 6)
    return transaction;
  const chainIdOrV = validate2(chainIdOrV_) && chainIdOrV_ !== "0x" ? Number(chainIdOrV_) : 0;
  if (s === "0x" && r2 === "0x") {
    if (chainIdOrV > 0)
      transaction.chainId = Number(chainIdOrV);
    return transaction;
  }
  const v = chainIdOrV;
  const chainId = Math.floor((v - 35) / 2);
  if (chainId > 0)
    transaction.chainId = chainId;
  else if (v !== 27 && v !== 28)
    throw new InvalidVError({ value: v });
  transaction.yParity = vToYParity(v);
  transaction.v = v;
  transaction.s = s === "0x" ? 0n : BigInt(s);
  transaction.r = r2 === "0x" ? 0n : BigInt(r2);
  assert6(transaction);
  return transaction;
}
function from22(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize5(envelope) : envelope;
  assert6(envelope_);
  const signature_ = (() => {
    if (!signature)
      return {};
    const s = from5(signature);
    s.v = yParityToV(s.yParity);
    return s;
  })();
  return {
    ...envelope_,
    ...signature_,
    type: "legacy"
  };
}
function getSignPayload6(envelope) {
  return hash6(envelope, { presign: true });
}
function hash6(envelope, options = {}) {
  const { presign } = options;
  return keccak256(serialize5({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize5(envelope, options = {}) {
  const { chainId = 0, gas, data, input, nonce, to: to2, value, gasPrice } = envelope;
  assert6(envelope);
  let serialized = [
    nonce ? fromNumber2(nonce) : "0x",
    gasPrice ? fromNumber2(gasPrice) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to2 ?? "0x",
    value ? fromNumber2(value) : "0x",
    data ?? input ?? "0x"
  ];
  const signature = (() => {
    if (options.signature)
      return {
        r: options.signature.r,
        s: options.signature.s,
        v: yParityToV(options.signature.yParity)
      };
    if (typeof envelope.r === "undefined" || typeof envelope.s === "undefined")
      return void 0;
    return {
      r: envelope.r,
      s: envelope.s,
      v: envelope.v
    };
  })();
  if (signature) {
    const v = (() => {
      if (signature.v >= 35) {
        const inferredChainId = Math.floor((signature.v - 35) / 2);
        if (inferredChainId > 0)
          return signature.v;
        return 27 + (signature.v === 35 ? 0 : 1);
      }
      if (chainId > 0)
        return chainId * 2 + 35 + signature.v - 27;
      const v2 = 27 + (signature.v === 27 ? 0 : 1);
      if (signature.v !== v2)
        throw new InvalidVError({ value: signature.v });
      return v2;
    })();
    serialized = [
      ...serialized,
      fromNumber2(v),
      signature.r === 0n ? "0x" : trimLeft(fromNumber2(signature.r)),
      signature.s === 0n ? "0x" : trimLeft(fromNumber2(signature.s))
    ];
  } else if (chainId > 0)
    serialized = [...serialized, fromNumber2(chainId), "0x", "0x"];
  return fromHex2(serialized);
}
function toRpc10(envelope) {
  const signature = extract(envelope);
  return {
    ...envelope,
    chainId: typeof envelope.chainId === "number" ? fromNumber2(envelope.chainId) : void 0,
    data: envelope.data ?? envelope.input,
    type: "0x0",
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.gasPrice === "bigint" ? { gasPrice: fromNumber2(envelope.gasPrice) } : {},
    ...signature ? {
      ...toRpc2(signature),
      v: signature.yParity === 0 ? "0x1b" : "0x1c"
    } : {}
  };
}
function validate10(envelope) {
  try {
    assert6(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/viem/node_modules/ox/_esm/core/TransactionRequest.js
var TransactionRequest_exports = {};
__export(TransactionRequest_exports, {
  toRpc: () => toRpc11
});
function toRpc11(request) {
  const request_rpc = {};
  if (typeof request.accessList !== "undefined")
    request_rpc.accessList = request.accessList;
  if (typeof request.authorizationList !== "undefined")
    request_rpc.authorizationList = toRpcList(request.authorizationList);
  if (typeof request.blobVersionedHashes !== "undefined")
    request_rpc.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== "undefined")
    request_rpc.blobs = request.blobs;
  if (typeof request.chainId !== "undefined")
    request_rpc.chainId = fromNumber2(request.chainId);
  if (typeof request.data !== "undefined") {
    request_rpc.data = request.data;
    request_rpc.input = request.data;
  } else if (typeof request.input !== "undefined") {
    request_rpc.data = request.input;
    request_rpc.input = request.input;
  }
  if (typeof request.from !== "undefined")
    request_rpc.from = request.from;
  if (typeof request.gas !== "undefined")
    request_rpc.gas = fromNumber2(request.gas);
  if (typeof request.gasPrice !== "undefined")
    request_rpc.gasPrice = fromNumber2(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== "undefined")
    request_rpc.maxFeePerBlobGas = fromNumber2(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== "undefined")
    request_rpc.maxFeePerGas = fromNumber2(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber2(request.maxPriorityFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber2(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== "undefined")
    request_rpc.nonce = fromNumber2(request.nonce);
  if (typeof request.to !== "undefined")
    request_rpc.to = request.to;
  if (typeof request.type !== "undefined")
    request_rpc.type = request.type;
  if (typeof request.value !== "undefined")
    request_rpc.value = fromNumber2(request.value);
  return request_rpc;
}

// node_modules/viem/node_modules/ox/_esm/core/ValidatorData.js
var ValidatorData_exports = {};
__export(ValidatorData_exports, {
  encode: () => encode4,
  getSignPayload: () => getSignPayload7
});
function encode4(value) {
  const { data, validator } = value;
  return concat2(
    // Validator Data Format: `0x19 ‖ 0x00 ‖ <intended validator address> ‖ <data to sign>`
    "0x19",
    "0x00",
    validator,
    from2(data)
  );
}
function getSignPayload7(value) {
  return keccak256(encode4(value));
}

// node_modules/viem/node_modules/ox/_esm/core/WebCryptoP256.js
var WebCryptoP256_exports = {};
__export(WebCryptoP256_exports, {
  createKeyPair: () => createKeyPair3,
  createKeyPairECDH: () => createKeyPairECDH,
  getSharedSecret: () => getSharedSecret,
  sign: () => sign3,
  verify: () => verify3
});
async function createKeyPair3(options = {}) {
  const { extractable = false } = options;
  const keypair = await globalThis.crypto.subtle.generateKey({
    name: "ECDSA",
    namedCurve: "P-256"
  }, extractable, ["sign", "verify"]);
  const publicKey_raw = await globalThis.crypto.subtle.exportKey("raw", keypair.publicKey);
  const publicKey = from3(new Uint8Array(publicKey_raw));
  return {
    privateKey: keypair.privateKey,
    publicKey
  };
}
async function createKeyPairECDH(options = {}) {
  const { extractable = false } = options;
  const keypair = await globalThis.crypto.subtle.generateKey({
    name: "ECDH",
    namedCurve: "P-256"
  }, extractable, ["deriveKey", "deriveBits"]);
  const publicKey_raw = await globalThis.crypto.subtle.exportKey("raw", keypair.publicKey);
  const publicKey = from3(new Uint8Array(publicKey_raw));
  return {
    privateKey: keypair.privateKey,
    publicKey
  };
}
async function getSharedSecret(options) {
  const { as = "Hex", privateKey, publicKey } = options;
  if (privateKey.algorithm.name === "ECDSA") {
    throw new Error("privateKey is not compatible with ECDH. please use `createKeyPairECDH` to create an ECDH key.");
  }
  const publicKeyCrypto = await globalThis.crypto.subtle.importKey("raw", toBytes2(publicKey), { name: "ECDH", namedCurve: "P-256" }, false, []);
  const sharedSecretBuffer = await globalThis.crypto.subtle.deriveBits({
    name: "ECDH",
    public: publicKeyCrypto
  }, privateKey, 256);
  const sharedSecret = new Uint8Array(sharedSecretBuffer);
  if (as === "Hex")
    return fromBytes(sharedSecret);
  return sharedSecret;
}
async function sign3(options) {
  const { payload, privateKey } = options;
  const signature = await globalThis.crypto.subtle.sign({
    name: "ECDSA",
    hash: "SHA-256"
  }, privateKey, from(payload));
  const signature_bytes = fromArray(new Uint8Array(signature));
  const r2 = toBigInt(slice(signature_bytes, 0, 32));
  let s = toBigInt(slice(signature_bytes, 32, 64));
  if (s > p256.CURVE.n / 2n)
    s = p256.CURVE.n - s;
  return { r: r2, s };
}
async function verify3(options) {
  const { payload, signature } = options;
  const publicKey = await globalThis.crypto.subtle.importKey("raw", toBytes2(options.publicKey), { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
  return await globalThis.crypto.subtle.verify({
    name: "ECDSA",
    hash: "SHA-256"
  }, publicKey, concat(fromNumber(signature.r), fromNumber(signature.s)), from(payload));
}

// node_modules/viem/node_modules/ox/_esm/core/X25519.js
var X25519_exports = {};
__export(X25519_exports, {
  createKeyPair: () => createKeyPair4,
  getPublicKey: () => getPublicKey4,
  getSharedSecret: () => getSharedSecret2,
  noble: () => noble3,
  randomPrivateKey: () => randomPrivateKey3
});
var noble3 = x25519;
function createKeyPair4(options = {}) {
  const { as = "Hex" } = options;
  const privateKey = randomPrivateKey3({ as });
  const publicKey = getPublicKey4({ privateKey, as });
  return {
    privateKey,
    publicKey
  };
}
function getPublicKey4(options) {
  const { as = "Hex", privateKey } = options;
  const privateKeyBytes = from(privateKey);
  const publicKeyBytes = x25519.getPublicKey(privateKeyBytes);
  if (as === "Hex")
    return fromBytes(publicKeyBytes);
  return publicKeyBytes;
}
function getSharedSecret2(options) {
  const { as = "Hex", privateKey, publicKey } = options;
  const privateKeyBytes = from(privateKey);
  const publicKeyBytes = from(publicKey);
  const sharedSecretBytes = x25519.getSharedSecret(privateKeyBytes, publicKeyBytes);
  if (as === "Hex")
    return fromBytes(sharedSecretBytes);
  return sharedSecretBytes;
}
function randomPrivateKey3(options = {}) {
  const { as = "Hex" } = options;
  const bytes = x25519.utils.randomPrivateKey();
  if (as === "Hex")
    return fromBytes(bytes);
  return bytes;
}

// node_modules/viem/node_modules/ox/_esm/core/internal/ens.js
function unwrapLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash8 = `0x${label.slice(1, 65)}`;
  if (!validate2(hash8, { strict: true }))
    return null;
  return hash8;
}

// node_modules/viem/node_modules/ox/_esm/core/Ens.js
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return fromBytes(result);
  return unwrapLabelhash(label) || keccak256(fromString2(label));
}
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return fromBytes(result);
  const labels = name.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashFromEncodedLabel = unwrapLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? fromHex(hashFromEncodedLabel) : keccak256(fromString(labels[i]), { as: "Bytes" });
    result = keccak256(concat(result, hashed), { as: "Bytes" });
  }
  return fromBytes(result);
}
function normalize(name) {
  return ens_normalize(name);
}

// node_modules/viem/_esm/utils/ens/normalize.js
function normalize2(name) {
  return normalize(name);
}

// node_modules/@rainbow-me/rainbowkit/dist/index.js
var import_react19 = __toESM(require_react());
var import_react20 = __toESM(require_react());
var import_react21 = __toESM(require_react());
var import_react22 = __toESM(require_react());
var import_react23 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/react-remove-scroll/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to2, from23, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from23.length, ar; i < l; i++) {
    if (ar || !(i in from23)) {
      if (!ar) ar = Array.prototype.slice.call(from23, 0, i);
      ar[i] = from23[i];
    }
  }
  return to2.concat(ar || Array.prototype.slice.call(from23));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React9 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
var React5 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react = __toESM(require_react());
function useCallbackRef(initialValue, callback) {
  var ref = (0, import_react.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-sidecar/node_modules/tslib/tslib.es6.mjs
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __rest2(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}

// node_modules/use-sidecar/dist/es2015/hoc.js
var React2 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react2 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer2 = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer2.length) {
        return buffer2[buffer2.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer2.push(item);
      return function() {
        buffer2 = buffer2.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb);
      }
      buffer2 = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer2;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb);
        pendingQueue = buffer2;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer2 = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer2;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign2({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
var React3 = __toESM(require_react());
var import_react3 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
var React4 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest2(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React4.createElement(Target, __assign2({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React5.forwardRef(function(props, parentRef) {
  var ref = React5.useRef(null);
  var _a = React5.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React5.createElement(
    React5.Fragment,
    null,
    enabled && React5.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React5.cloneElement(React5.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React5.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React8 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React7 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/hook.js
var React6 = __toESM(require_react());

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React6.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left), parse2(top), parse2(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React7.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React7.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React7.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React8.useRef([]);
  var touchStartRef = React8.useRef([0, 0]);
  var activeAxis = React8.useRef();
  var id = React8.useState(idCounter++)[0];
  var Style2 = React8.useState(styleSingleton)[0];
  var lastProps = React8.useRef(props);
  React8.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React8.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React8.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React8.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React8.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React8.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React8.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React8.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React8.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React8.createElement(
    React8.Fragment,
    null,
    inert ? React8.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React8.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React9.forwardRef(function(props, ref) {
  return React9.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/@rainbow-me/rainbowkit/dist/index.js
var import_react24 = __toESM(require_react());

// node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js
function getVarName(variable) {
  var matches = variable.match(/^var\((.*)\)$/);
  if (matches) {
    return matches[1];
  }
  return variable;
}
function get(obj, path2) {
  var result = obj;
  for (var key of path2) {
    if (!(key in result)) {
      throw new Error("Path ".concat(path2.join(" -> "), " does not exist in object"));
    }
    result = result[key];
  }
  return result;
}
function walkObject(obj, fn) {
  var path2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var clone = {};
  for (var key in obj) {
    var _value = obj[key];
    var currentPath = [...path2, key];
    if (typeof _value === "string" || typeof _value === "number" || _value == null) {
      clone[key] = fn(_value, currentPath);
    } else if (typeof _value === "object" && !Array.isArray(_value)) {
      clone[key] = walkObject(_value, fn, currentPath);
    } else {
      console.warn('Skipping invalid key "'.concat(currentPath.join("."), '". Should be a string, number, null or object. Received: "').concat(Array.isArray(_value) ? "Array" : typeof _value, '"'));
    }
  }
  return clone;
}

// node_modules/@vanilla-extract/dynamic/dist/vanilla-extract-dynamic.esm.js
function assignInlineVars(varsOrContract, tokens) {
  var styles = {};
  if (typeof tokens === "object") {
    var _contract = varsOrContract;
    walkObject(tokens, (value2, path2) => {
      if (value2 == null) {
        return;
      }
      var varName2 = get(_contract, path2);
      styles[getVarName(varName2)] = String(value2);
    });
  } else {
    var _vars = varsOrContract;
    for (var varName in _vars) {
      var value = _vars[varName];
      if (value == null) {
        continue;
      }
      styles[getVarName(varName)] = value;
    }
  }
  Object.defineProperty(styles, "toString", {
    value: function value2() {
      return Object.keys(this).map((key) => "".concat(key, ":").concat(this[key])).join(";");
    },
    writable: false
  });
  return styles;
}

// node_modules/@rainbow-me/rainbowkit/dist/index.js
var import_react25 = __toESM(require_react());
var import_react26 = __toESM(require_react());
var import_react27 = __toESM(require_react());
var import_react28 = __toESM(require_react());
var import_react29 = __toESM(require_react());
var import_react30 = __toESM(require_react());
var import_react31 = __toESM(require_react());
var import_react32 = __toESM(require_react());
var import_ua_parser_js = __toESM(require_ua_parser());
var import_react33 = __toESM(require_react());
var import_react34 = __toESM(require_react());
var import_react35 = __toESM(require_react());
var import_react36 = __toESM(require_react());
var import_react37 = __toESM(require_react());
var import_react38 = __toESM(require_react());
var import_react39 = __toESM(require_react());
var import_react40 = __toESM(require_react());
var import_react41 = __toESM(require_react());
var import_react42 = __toESM(require_react());
var import_react43 = __toESM(require_react());
var import_react44 = __toESM(require_react());
var import_react45 = __toESM(require_react());
var import_react46 = __toESM(require_react());
var import_react47 = __toESM(require_react());
var import_react48 = __toESM(require_react());
var import_react49 = __toESM(require_react());
var import_react50 = __toESM(require_react());
var import_react51 = __toESM(require_react());
var import_react52 = __toESM(require_react());
var import_react53 = __toESM(require_react());
var import_react54 = __toESM(require_react());
var import_react55 = __toESM(require_react());
var import_react56 = __toESM(require_react());
var import_react57 = __toESM(require_react());
var import_react58 = __toESM(require_react());
var import_react59 = __toESM(require_react());
var import_react60 = __toESM(require_react());
var import_react61 = __toESM(require_react());
var import_react62 = __toESM(require_react());
var import_react63 = __toESM(require_react());
var import_react64 = __toESM(require_react());
var import_react65 = __toESM(require_react());
var import_react66 = __toESM(require_react());
var import_react67 = __toESM(require_react());
var import_react68 = __toESM(require_react());
var import_react69 = __toESM(require_react());
var import_react70 = __toESM(require_react());
var import_react71 = __toESM(require_react());
var import_react72 = __toESM(require_react());
var import_react73 = __toESM(require_react());
var import_react74 = __toESM(require_react());

// node_modules/cuer/_dist/Cuer.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React10 = __toESM(require_react(), 1);

// node_modules/qr/index.js
var chCodes = { newline: 10, reset: 27 };
function assertNumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`integer expected: ${n}`);
}
function validateVersion(ver) {
  if (!Number.isSafeInteger(ver) || ver < 1 || ver > 40)
    throw new Error(`Invalid version=${ver}. Expected number [1..40]`);
}
function bin(dec, pad2) {
  return dec.toString(2).padStart(pad2, "0");
}
function mod2(a, b) {
  const result = a % b;
  return result >= 0 ? result : b + result;
}
function fillArr(length, val) {
  return new Array(length).fill(val);
}
function interleaveBytes(...blocks) {
  let len = 0;
  for (const b of blocks)
    len = Math.max(len, b.length);
  const res = [];
  for (let i = 0; i < len; i++) {
    for (const b of blocks) {
      if (i >= b.length)
        continue;
      res.push(b[i]);
    }
  }
  return new Uint8Array(res);
}
function includesAt(lst, pattern, index2) {
  if (index2 < 0 || index2 + pattern.length > lst.length)
    return false;
  for (let i = 0; i < pattern.length; i++)
    if (pattern[i] !== lst[index2 + i])
      return false;
  return true;
}
function best() {
  let best2;
  let bestScore = Infinity;
  return {
    add(score, value) {
      if (score >= bestScore)
        return;
      best2 = value;
      bestScore = score;
    },
    get: () => best2,
    score: () => bestScore
  };
}
function alphabet(alphabet2) {
  return {
    has: (char) => alphabet2.includes(char),
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index2 = alphabet2.indexOf(letter);
        if (index2 === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index2;
      });
    },
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i) => {
        assertNumber(i);
        if (i < 0 || i >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
        return alphabet2[i];
      });
    }
  };
}
var Bitmap = class _Bitmap {
  constructor(size5, data) {
    __publicField(this, "data");
    __publicField(this, "height");
    __publicField(this, "width");
    const { height, width } = _Bitmap.size(size5);
    this.data = data || Array.from({ length: height }, () => fillArr(width, void 0));
    this.height = height;
    this.width = width;
  }
  static size(size5, limit2) {
    if (typeof size5 === "number")
      size5 = { height: size5, width: size5 };
    if (!Number.isSafeInteger(size5.height) && size5.height !== Infinity)
      throw new Error(`Bitmap: invalid height=${size5.height} (${typeof size5.height})`);
    if (!Number.isSafeInteger(size5.width) && size5.width !== Infinity)
      throw new Error(`Bitmap: invalid width=${size5.width} (${typeof size5.width})`);
    if (limit2 !== void 0) {
      size5 = {
        width: Math.min(size5.width, limit2.width),
        height: Math.min(size5.height, limit2.height)
      };
    }
    return size5;
  }
  static fromString(s) {
    s = s.replace(/^\n+/g, "").replace(/\n+$/g, "");
    const lines = s.split(String.fromCharCode(chCodes.newline));
    const height = lines.length;
    const data = new Array(height);
    let width;
    for (const line of lines) {
      const row = line.split("").map((i) => {
        if (i === "X")
          return true;
        if (i === " ")
          return false;
        if (i === "?")
          return void 0;
        throw new Error(`Bitmap.fromString: unknown symbol=${i}`);
      });
      if (width && row.length !== width)
        throw new Error(`Bitmap.fromString different row sizes: width=${width} cur=${row.length}`);
      width = row.length;
      data.push(row);
    }
    if (!width)
      width = 0;
    return new _Bitmap({ height, width }, data);
  }
  point(p) {
    return this.data[p.y][p.x];
  }
  isInside(p) {
    return 0 <= p.x && p.x < this.width && 0 <= p.y && p.y < this.height;
  }
  size(offset) {
    if (!offset)
      return { height: this.height, width: this.width };
    const { x, y } = this.xy(offset);
    return { height: this.height - y, width: this.width - x };
  }
  xy(c) {
    if (typeof c === "number")
      c = { x: c, y: c };
    if (!Number.isSafeInteger(c.x))
      throw new Error(`Bitmap: invalid x=${c.x}`);
    if (!Number.isSafeInteger(c.y))
      throw new Error(`Bitmap: invalid y=${c.y}`);
    c.x = mod2(c.x, this.width);
    c.y = mod2(c.y, this.height);
    return c;
  }
  // Basically every operation can be represented as rect
  rect(c, size5, value) {
    const { x, y } = this.xy(c);
    const { height, width } = _Bitmap.size(size5, this.size({ x, y }));
    for (let yPos = 0; yPos < height; yPos++) {
      for (let xPos = 0; xPos < width; xPos++) {
        this.data[y + yPos][x + xPos] = typeof value === "function" ? value({ x: xPos, y: yPos }, this.data[y + yPos][x + xPos]) : value;
      }
    }
    return this;
  }
  // returns rectangular part of bitmap
  rectRead(c, size5, fn) {
    return this.rect(c, size5, (c2, cur) => {
      fn(c2, cur);
      return cur;
    });
  }
  // Horizontal & vertical lines
  hLine(c, len, value) {
    return this.rect(c, { width: len, height: 1 }, value);
  }
  vLine(c, len, value) {
    return this.rect(c, { width: 1, height: len }, value);
  }
  // add border
  border(border2 = 2, value) {
    const height = this.height + 2 * border2;
    const width = this.width + 2 * border2;
    const v = fillArr(border2, value);
    const h = Array.from({ length: border2 }, () => fillArr(width, value));
    return new _Bitmap({ height, width }, [...h, ...this.data.map((i) => [...v, ...i, ...v]), ...h]);
  }
  // Embed another bitmap on coordinates
  embed(c, bm) {
    return this.rect(c, bm.size(), ({ x, y }) => bm.data[y][x]);
  }
  // returns rectangular part of bitmap
  rectSlice(c, size5 = this.size()) {
    const rect = new _Bitmap(_Bitmap.size(size5, this.size(this.xy(c))));
    this.rect(c, size5, ({ x, y }, cur) => rect.data[y][x] = cur);
    return rect;
  }
  // Change shape, replace rows with columns (data[y][x] -> data[x][y])
  inverse() {
    const { height, width } = this;
    const res = new _Bitmap({ height: width, width: height });
    return res.rect({ x: 0, y: 0 }, Infinity, ({ x, y }) => this.data[x][y]);
  }
  // Each pixel size is multiplied by factor
  scale(factor) {
    if (!Number.isSafeInteger(factor) || factor > 1024)
      throw new Error(`invalid scale factor: ${factor}`);
    const { height, width } = this;
    const res = new _Bitmap({ height: factor * height, width: factor * width });
    return res.rect({ x: 0, y: 0 }, Infinity, ({ x, y }) => this.data[Math.floor(y / factor)][Math.floor(x / factor)]);
  }
  clone() {
    const res = new _Bitmap(this.size());
    return res.rect({ x: 0, y: 0 }, this.size(), ({ x, y }) => this.data[y][x]);
  }
  // Ensure that there is no undefined values left
  assertDrawn() {
    this.rectRead(0, Infinity, (_, cur) => {
      if (typeof cur !== "boolean")
        throw new Error(`Invalid color type=${typeof cur}`);
    });
  }
  // Simple string representation for debugging
  toString() {
    return this.data.map((i) => i.map((j) => j === void 0 ? "?" : j ? "X" : " ").join("")).join(String.fromCharCode(chCodes.newline));
  }
  toASCII() {
    const { height, width, data } = this;
    let out = "";
    for (let y = 0; y < height; y += 2) {
      for (let x = 0; x < width; x++) {
        const first = data[y][x];
        const second = y + 1 >= height ? true : data[y + 1][x];
        if (!first && !second)
          out += "█";
        else if (!first && second)
          out += "▀";
        else if (first && !second)
          out += "▄";
        else if (first && second)
          out += " ";
      }
      out += String.fromCharCode(chCodes.newline);
    }
    return out;
  }
  toTerm() {
    const cc = String.fromCharCode(chCodes.reset);
    const reset = cc + "[0m";
    const whiteBG = cc + "[1;47m  " + reset;
    const darkBG = cc + `[40m  ` + reset;
    return this.data.map((i) => i.map((j) => j ? darkBG : whiteBG).join("")).join(String.fromCharCode(chCodes.newline));
  }
  toSVG(optimize = true) {
    let out = `<svg viewBox="0 0 ${this.width} ${this.height}" xmlns="http://www.w3.org/2000/svg">`;
    let pathData = "";
    let prevPoint;
    this.rectRead(0, Infinity, (point, val) => {
      if (!val)
        return;
      const { x, y } = point;
      if (!optimize) {
        out += `<rect x="${x}" y="${y}" width="1" height="1" />`;
        return;
      }
      let m = `M${x} ${y}`;
      if (prevPoint) {
        const relM = `m${x - prevPoint.x} ${y - prevPoint.y}`;
        if (relM.length <= m.length)
          m = relM;
      }
      const bH = x < 10 ? `H${x}` : "h-1";
      pathData += `${m}h1v1${bH}Z`;
      prevPoint = point;
    });
    if (optimize)
      out += `<path d="${pathData}"/>`;
    out += `</svg>`;
    return out;
  }
  toGIF() {
    const u16le = (i) => [i & 255, i >>> 8 & 255];
    const dims = [...u16le(this.width), ...u16le(this.height)];
    const data = [];
    this.rectRead(0, Infinity, (_, cur) => data.push(+(cur === true)));
    const N = 126;
    const bytes = [
      71,
      73,
      70,
      56,
      55,
      97,
      ...dims,
      246,
      0,
      0,
      255,
      255,
      255,
      ...fillArr(3 * 127, 0),
      44,
      0,
      0,
      0,
      0,
      ...dims,
      0,
      7
    ];
    const fullChunks = Math.floor(data.length / N);
    for (let i = 0; i < fullChunks; i++)
      bytes.push(N + 1, 128, ...data.slice(N * i, N * (i + 1)).map((i2) => +i2));
    bytes.push(data.length % N + 1, 128, ...data.slice(fullChunks * N).map((i) => +i));
    bytes.push(1, 129, 0, 59);
    return new Uint8Array(bytes);
  }
  toImage(isRGB = false) {
    const { height, width } = this.size();
    const data = new Uint8Array(height * width * (isRGB ? 3 : 4));
    let i = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const value = !!this.data[y][x] ? 0 : 255;
        data[i++] = value;
        data[i++] = value;
        data[i++] = value;
        if (!isRGB)
          data[i++] = 255;
      }
    }
    return { height, width, data };
  }
};
var ECMode = ["low", "medium", "quartile", "high"];
var Encoding = ["numeric", "alphanumeric", "byte", "kanji", "eci"];
var BYTES = [
  // 1,  2,  3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,   20,
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  //  21,   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
var WORDS_PER_BLOCK = {
  // Version 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40
  low: [7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  medium: [10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
  quartile: [13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  high: [17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
};
var ECC_BLOCKS = {
  // Version   1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40
  low: [1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
  medium: [1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
  quartile: [1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
  high: [1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
};
var info = {
  size: {
    encode: (ver) => 21 + 4 * (ver - 1),
    // ver1 = 21, ver40=177 blocks
    decode: (size5) => (size5 - 17) / 4
  },
  sizeType: (ver) => Math.floor((ver + 7) / 17),
  // Based on https://codereview.stackexchange.com/questions/74925/algorithm-to-generate-this-alignment-pattern-locations-table-for-qr-codes
  alignmentPatterns(ver) {
    if (ver === 1)
      return [];
    const first = 6;
    const last = info.size.encode(ver) - first - 1;
    const distance = last - first;
    const count = Math.ceil(distance / 28);
    let interval = Math.floor(distance / count);
    if (interval % 2)
      interval += 1;
    else if (distance % count * 2 >= count)
      interval += 2;
    const res = [first];
    for (let m = 1; m < count; m++)
      res.push(last - (count - m) * interval);
    res.push(last);
    return res;
  },
  ECCode: {
    low: 1,
    medium: 0,
    quartile: 3,
    high: 2
  },
  formatMask: 21522,
  formatBits(ecc, maskIdx) {
    const data = info.ECCode[ecc] << 3 | maskIdx;
    let d = data;
    for (let i = 0; i < 10; i++)
      d = d << 1 ^ (d >> 9) * 1335;
    return (data << 10 | d) ^ info.formatMask;
  },
  versionBits(ver) {
    let d = ver;
    for (let i = 0; i < 12; i++)
      d = d << 1 ^ (d >> 11) * 7973;
    return ver << 12 | d;
  },
  alphabet: {
    numeric: alphabet("0123456789"),
    alphanumerc: alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:")
  },
  // as Record<EncodingType, ReturnType<typeof alphabet>>,
  lengthBits(ver, type6) {
    const table = {
      numeric: [10, 12, 14],
      alphanumeric: [9, 11, 13],
      byte: [8, 16, 16],
      kanji: [8, 10, 12],
      eci: [0, 0, 0]
    };
    return table[type6][info.sizeType(ver)];
  },
  modeBits: {
    numeric: "0001",
    alphanumeric: "0010",
    byte: "0100",
    kanji: "1000",
    eci: "0111"
  },
  capacity(ver, ecc) {
    const bytes = BYTES[ver - 1];
    const words = WORDS_PER_BLOCK[ecc][ver - 1];
    const numBlocks = ECC_BLOCKS[ecc][ver - 1];
    const blockLen = Math.floor(bytes / numBlocks) - words;
    const shortBlocks = numBlocks - bytes % numBlocks;
    return {
      words,
      numBlocks,
      shortBlocks,
      blockLen,
      capacity: (bytes - words * numBlocks) * 8,
      total: (words + blockLen) * numBlocks + numBlocks - shortBlocks
    };
  }
};
var PATTERNS = [
  (x, y) => (x + y) % 2 == 0,
  (_x, y) => y % 2 == 0,
  (x, _y) => x % 3 == 0,
  (x, y) => (x + y) % 3 == 0,
  (x, y) => (Math.floor(y / 2) + Math.floor(x / 3)) % 2 == 0,
  (x, y) => x * y % 2 + x * y % 3 == 0,
  (x, y) => (x * y % 2 + x * y % 3) % 2 == 0,
  (x, y) => ((x + y) % 2 + x * y % 3) % 2 == 0
];
var GF = {
  tables: ((p_poly) => {
    const exp = fillArr(256, 0);
    const log = fillArr(256, 0);
    for (let i = 0, x = 1; i < 256; i++) {
      exp[i] = x;
      log[x] = i;
      x <<= 1;
      if (x & 256)
        x ^= p_poly;
    }
    return { exp, log };
  })(285),
  exp: (x) => GF.tables.exp[x],
  log(x) {
    if (x === 0)
      throw new Error(`GF.log: invalid arg=${x}`);
    return GF.tables.log[x] % 255;
  },
  mul(x, y) {
    if (x === 0 || y === 0)
      return 0;
    return GF.tables.exp[(GF.tables.log[x] + GF.tables.log[y]) % 255];
  },
  add: (x, y) => x ^ y,
  pow: (x, e) => GF.tables.exp[GF.tables.log[x] * e % 255],
  inv(x) {
    if (x === 0)
      throw new Error(`GF.inverse: invalid arg=${x}`);
    return GF.tables.exp[255 - GF.tables.log[x]];
  },
  polynomial(poly) {
    if (poly.length == 0)
      throw new Error("GF.polymomial: invalid length");
    if (poly[0] !== 0)
      return poly;
    let i = 0;
    for (; i < poly.length - 1 && poly[i] == 0; i++)
      ;
    return poly.slice(i);
  },
  monomial(degree, coefficient) {
    if (degree < 0)
      throw new Error(`GF.monomial: invalid degree=${degree}`);
    if (coefficient == 0)
      return [0];
    let coefficients = fillArr(degree + 1, 0);
    coefficients[0] = coefficient;
    return GF.polynomial(coefficients);
  },
  degree: (a) => a.length - 1,
  coefficient: (a, degree) => a[GF.degree(a) - degree],
  mulPoly(a, b) {
    if (a[0] === 0 || b[0] === 0)
      return [0];
    const res = fillArr(a.length + b.length - 1, 0);
    for (let i = 0; i < a.length; i++) {
      for (let j = 0; j < b.length; j++) {
        res[i + j] = GF.add(res[i + j], GF.mul(a[i], b[j]));
      }
    }
    return GF.polynomial(res);
  },
  mulPolyScalar(a, scalar) {
    if (scalar == 0)
      return [0];
    if (scalar == 1)
      return a;
    const res = fillArr(a.length, 0);
    for (let i = 0; i < a.length; i++)
      res[i] = GF.mul(a[i], scalar);
    return GF.polynomial(res);
  },
  mulPolyMonomial(a, degree, coefficient) {
    if (degree < 0)
      throw new Error("GF.mulPolyMonomial: invalid degree");
    if (coefficient == 0)
      return [0];
    const res = fillArr(a.length + degree, 0);
    for (let i = 0; i < a.length; i++)
      res[i] = GF.mul(a[i], coefficient);
    return GF.polynomial(res);
  },
  addPoly(a, b) {
    if (a[0] === 0)
      return b;
    if (b[0] === 0)
      return a;
    let smaller = a;
    let larger = b;
    if (smaller.length > larger.length)
      [smaller, larger] = [larger, smaller];
    let sumDiff = fillArr(larger.length, 0);
    let lengthDiff = larger.length - smaller.length;
    let s = larger.slice(0, lengthDiff);
    for (let i = 0; i < s.length; i++)
      sumDiff[i] = s[i];
    for (let i = lengthDiff; i < larger.length; i++)
      sumDiff[i] = GF.add(smaller[i - lengthDiff], larger[i]);
    return GF.polynomial(sumDiff);
  },
  remainderPoly(data, divisor) {
    const out = Array.from(data);
    for (let i = 0; i < data.length - divisor.length + 1; i++) {
      const elm = out[i];
      if (elm === 0)
        continue;
      for (let j = 1; j < divisor.length; j++) {
        if (divisor[j] !== 0)
          out[i + j] = GF.add(out[i + j], GF.mul(divisor[j], elm));
      }
    }
    return out.slice(data.length - divisor.length + 1, out.length);
  },
  divisorPoly(degree) {
    let g = [1];
    for (let i = 0; i < degree; i++)
      g = GF.mulPoly(g, [1, GF.pow(2, i)]);
    return g;
  },
  evalPoly(poly, a) {
    if (a == 0)
      return GF.coefficient(poly, 0);
    let res = poly[0];
    for (let i = 1; i < poly.length; i++)
      res = GF.add(GF.mul(a, res), poly[i]);
    return res;
  },
  // TODO: cleanup
  euclidian(a, b, R) {
    if (GF.degree(a) < GF.degree(b))
      [a, b] = [b, a];
    let rLast = a;
    let r2 = b;
    let tLast = [0];
    let t = [1];
    while (2 * GF.degree(r2) >= R) {
      let rLastLast = rLast;
      let tLastLast = tLast;
      rLast = r2;
      tLast = t;
      if (rLast[0] === 0)
        throw new Error("rLast[0] === 0");
      r2 = rLastLast;
      let q = [0];
      const dltInverse = GF.inv(rLast[0]);
      while (GF.degree(r2) >= GF.degree(rLast) && r2[0] !== 0) {
        const degreeDiff = GF.degree(r2) - GF.degree(rLast);
        const scale = GF.mul(r2[0], dltInverse);
        q = GF.addPoly(q, GF.monomial(degreeDiff, scale));
        r2 = GF.addPoly(r2, GF.mulPolyMonomial(rLast, degreeDiff, scale));
      }
      q = GF.mulPoly(q, tLast);
      t = GF.addPoly(q, tLastLast);
      if (GF.degree(r2) >= GF.degree(rLast))
        throw new Error(`Division failed r: ${r2}, rLast: ${rLast}`);
    }
    const sigmaTildeAtZero = GF.coefficient(t, 0);
    if (sigmaTildeAtZero == 0)
      throw new Error("sigmaTilde(0) was zero");
    const inverse = GF.inv(sigmaTildeAtZero);
    return [GF.mulPolyScalar(t, inverse), GF.mulPolyScalar(r2, inverse)];
  }
};
function RS(eccWords) {
  return {
    encode(from23) {
      const d = GF.divisorPoly(eccWords);
      const pol = Array.from(from23);
      pol.push(...d.slice(0, -1).fill(0));
      return Uint8Array.from(GF.remainderPoly(pol, d));
    },
    decode(to2) {
      const res = to2.slice();
      const poly = GF.polynomial(Array.from(to2));
      let syndrome = fillArr(eccWords, 0);
      let hasError = false;
      for (let i = 0; i < eccWords; i++) {
        const evl = GF.evalPoly(poly, GF.exp(i));
        syndrome[syndrome.length - 1 - i] = evl;
        if (evl !== 0)
          hasError = true;
      }
      if (!hasError)
        return res;
      syndrome = GF.polynomial(syndrome);
      const monomial = GF.monomial(eccWords, 1);
      const [errorLocator, errorEvaluator] = GF.euclidian(monomial, syndrome, eccWords);
      const locations = fillArr(GF.degree(errorLocator), 0);
      let e = 0;
      for (let i = 1; i < 256 && e < locations.length; i++) {
        if (GF.evalPoly(errorLocator, i) === 0)
          locations[e++] = GF.inv(i);
      }
      if (e !== locations.length)
        throw new Error("RS.decode: invalid errors number");
      for (let i = 0; i < locations.length; i++) {
        const pos = res.length - 1 - GF.log(locations[i]);
        if (pos < 0)
          throw new Error("RS.decode: invalid error location");
        const xiInverse = GF.inv(locations[i]);
        let denominator = 1;
        for (let j = 0; j < locations.length; j++) {
          if (i === j)
            continue;
          denominator = GF.mul(denominator, GF.add(1, GF.mul(locations[j], xiInverse)));
        }
        res[pos] = GF.add(res[pos], GF.mul(GF.evalPoly(errorEvaluator, xiInverse), GF.inv(denominator)));
      }
      return res;
    }
  };
}
function interleave(ver, ecc) {
  const { words, shortBlocks, numBlocks, blockLen, total } = info.capacity(ver, ecc);
  const rs = RS(words);
  return {
    encode(bytes) {
      const blocks = [];
      const eccBlocks = [];
      for (let i = 0; i < numBlocks; i++) {
        const isShort = i < shortBlocks;
        const len = blockLen + (isShort ? 0 : 1);
        blocks.push(bytes.subarray(0, len));
        eccBlocks.push(rs.encode(bytes.subarray(0, len)));
        bytes = bytes.subarray(len);
      }
      const resBlocks = interleaveBytes(...blocks);
      const resECC = interleaveBytes(...eccBlocks);
      const res = new Uint8Array(resBlocks.length + resECC.length);
      res.set(resBlocks);
      res.set(resECC, resBlocks.length);
      return res;
    },
    decode(data) {
      if (data.length !== total)
        throw new Error(`interleave.decode: len(data)=${data.length}, total=${total}`);
      const blocks = [];
      for (let i = 0; i < numBlocks; i++) {
        const isShort = i < shortBlocks;
        blocks.push(new Uint8Array(words + blockLen + (isShort ? 0 : 1)));
      }
      let pos = 0;
      for (let i = 0; i < blockLen; i++) {
        for (let j = 0; j < numBlocks; j++)
          blocks[j][i] = data[pos++];
      }
      for (let j = shortBlocks; j < numBlocks; j++)
        blocks[j][blockLen] = data[pos++];
      for (let i = blockLen; i < blockLen + words; i++) {
        for (let j = 0; j < numBlocks; j++) {
          const isShort = j < shortBlocks;
          blocks[j][i + (isShort ? 0 : 1)] = data[pos++];
        }
      }
      const res = [];
      for (const block of blocks)
        res.push(...Array.from(rs.decode(block)).slice(0, -words));
      return Uint8Array.from(res);
    }
  };
}
function drawTemplate(ver, ecc, maskIdx, test = false) {
  const size5 = info.size.encode(ver);
  let b = new Bitmap(size5 + 2);
  const finder = new Bitmap(3).rect(0, 3, true).border(1, false).border(1, true).border(1, false);
  b = b.embed(0, finder).embed({ x: -finder.width, y: 0 }, finder).embed({ x: 0, y: -finder.height }, finder);
  b = b.rectSlice(1, size5);
  const align = new Bitmap(1).rect(0, 1, true).border(1, false).border(1, true);
  const alignPos = info.alignmentPatterns(ver);
  for (const y of alignPos) {
    for (const x of alignPos) {
      if (b.data[y][x] !== void 0)
        continue;
      b.embed({ x: x - 2, y: y - 2 }, align);
    }
  }
  b = b.hLine({ x: 0, y: 6 }, Infinity, ({ x }, cur) => cur === void 0 ? x % 2 == 0 : cur).vLine({ x: 6, y: 0 }, Infinity, ({ y }, cur) => cur === void 0 ? y % 2 == 0 : cur);
  {
    const bits = info.formatBits(ecc, maskIdx);
    const getBit = (i) => !test && (bits >> i & 1) == 1;
    for (let i = 0; i < 6; i++)
      b.data[i][8] = getBit(i);
    for (let i = 6; i < 8; i++)
      b.data[i + 1][8] = getBit(i);
    for (let i = 8; i < 15; i++)
      b.data[size5 - 15 + i][8] = getBit(i);
    for (let i = 0; i < 8; i++)
      b.data[8][size5 - i - 1] = getBit(i);
    for (let i = 8; i < 9; i++)
      b.data[8][15 - i - 1 + 1] = getBit(i);
    for (let i = 9; i < 15; i++)
      b.data[8][15 - i - 1] = getBit(i);
    b.data[size5 - 8][8] = !test;
  }
  if (ver >= 7) {
    const bits = info.versionBits(ver);
    for (let i = 0; i < 18; i += 1) {
      const bit = !test && (bits >> i & 1) == 1;
      const x = Math.floor(i / 3);
      const y = i % 3 + size5 - 8 - 3;
      b.data[x][y] = bit;
      b.data[y][x] = bit;
    }
  }
  return b;
}
function zigzag(tpl, maskIdx, fn) {
  const size5 = tpl.height;
  const pattern = PATTERNS[maskIdx];
  let dir = -1;
  let y = size5 - 1;
  for (let xOffset = size5 - 1; xOffset > 0; xOffset -= 2) {
    if (xOffset == 6)
      xOffset = 5;
    for (; ; y += dir) {
      for (let j = 0; j < 2; j += 1) {
        const x = xOffset - j;
        if (tpl.data[y][x] !== void 0)
          continue;
        fn(x, y, pattern(x, y));
      }
      if (y + dir < 0 || y + dir >= size5)
        break;
    }
    dir = -dir;
  }
}
function detectType(str) {
  let type6 = "numeric";
  for (let x of str) {
    if (info.alphabet.numeric.has(x))
      continue;
    type6 = "alphanumeric";
    if (!info.alphabet.alphanumerc.has(x))
      return "byte";
  }
  return type6;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function encode5(ver, ecc, data, type6) {
  let encoded = "";
  let dataLen = data.length;
  if (type6 === "numeric") {
    const t = info.alphabet.numeric.decode(data.split(""));
    const n = t.length;
    for (let i = 0; i < n - 2; i += 3)
      encoded += bin(t[i] * 100 + t[i + 1] * 10 + t[i + 2], 10);
    if (n % 3 === 1) {
      encoded += bin(t[n - 1], 4);
    } else if (n % 3 === 2) {
      encoded += bin(t[n - 2] * 10 + t[n - 1], 7);
    }
  } else if (type6 === "alphanumeric") {
    const t = info.alphabet.alphanumerc.decode(data.split(""));
    const n = t.length;
    for (let i = 0; i < n - 1; i += 2)
      encoded += bin(t[i] * 45 + t[i + 1], 11);
    if (n % 2 == 1)
      encoded += bin(t[n - 1], 6);
  } else if (type6 === "byte") {
    const utf8 = utf8ToBytes3(data);
    dataLen = utf8.length;
    encoded = Array.from(utf8).map((i) => bin(i, 8)).join("");
  } else {
    throw new Error("encode: unsupported type");
  }
  const { capacity } = info.capacity(ver, ecc);
  const len = bin(dataLen, info.lengthBits(ver, type6));
  let bits = info.modeBits[type6] + len + encoded;
  if (bits.length > capacity)
    throw new Error("Capacity overflow");
  bits += "0".repeat(Math.min(4, Math.max(0, capacity - bits.length)));
  if (bits.length % 8)
    bits += "0".repeat(8 - bits.length % 8);
  const padding = "1110110000010001";
  for (let idx = 0; bits.length !== capacity; idx++)
    bits += padding[idx % padding.length];
  const bytes = Uint8Array.from(bits.match(/(.{8})/g).map((i) => Number(`0b${i}`)));
  return interleave(ver, ecc).encode(bytes);
}
function drawQR(ver, ecc, data, maskIdx, test = false) {
  const b = drawTemplate(ver, ecc, maskIdx, test);
  let i = 0;
  const need = 8 * data.length;
  zigzag(b, maskIdx, (x, y, mask2) => {
    let value = false;
    if (i < need) {
      value = (data[i >>> 3] >> (7 - i & 7) & 1) !== 0;
      i++;
    }
    b.data[y][x] = value !== mask2;
  });
  if (i !== need)
    throw new Error("QR: bytes left after draw");
  return b;
}
function penalty(bm) {
  const inverse = bm.inverse();
  const sameColor = (row) => {
    let res = 0;
    for (let i = 0, same = 1, last = void 0; i < row.length; i++) {
      if (last === row[i]) {
        same++;
        if (i !== row.length - 1)
          continue;
      }
      if (same >= 5)
        res += 3 + (same - 5);
      last = row[i];
      same = 1;
    }
    return res;
  };
  let adjacent = 0;
  bm.data.forEach((row) => adjacent += sameColor(row));
  inverse.data.forEach((column) => adjacent += sameColor(column));
  let box = 0;
  let b = bm.data;
  const lastW = bm.width - 1;
  const lastH = bm.height - 1;
  for (let x = 0; x < lastW; x++) {
    for (let y = 0; y < lastH; y++) {
      const x1 = x + 1;
      const y1 = y + 1;
      if (b[x][y] === b[x1][y] && b[x1][y] === b[x][y1] && b[x1][y] === b[x1][y1]) {
        box += 3;
      }
    }
  }
  const finderPattern = (row) => {
    const finderPattern2 = [true, false, true, true, true, false, true];
    const lightPattern = [false, false, false, false];
    const p1 = [...finderPattern2, ...lightPattern];
    const p2 = [...lightPattern, ...finderPattern2];
    let res = 0;
    for (let i = 0; i < row.length; i++) {
      if (includesAt(row, p1, i))
        res += 40;
      if (includesAt(row, p2, i))
        res += 40;
    }
    return res;
  };
  let finder = 0;
  for (const row of bm.data)
    finder += finderPattern(row);
  for (const column of inverse.data)
    finder += finderPattern(column);
  let darkPixels = 0;
  bm.rectRead(0, Infinity, (_c, val) => darkPixels += val ? 1 : 0);
  const darkPercent = darkPixels / (bm.height * bm.width) * 100;
  const dark = 10 * Math.floor(Math.abs(darkPercent - 50) / 5);
  return adjacent + box + finder + dark;
}
function drawQRBest(ver, ecc, data, maskIdx) {
  if (maskIdx === void 0) {
    const bestMask = best();
    for (let mask2 = 0; mask2 < PATTERNS.length; mask2++)
      bestMask.add(penalty(drawQR(ver, ecc, data, mask2, true)), mask2);
    maskIdx = bestMask.get();
  }
  if (maskIdx === void 0)
    throw new Error("Cannot find mask");
  return drawQR(ver, ecc, data, maskIdx);
}
function validateECC(ec) {
  if (!ECMode.includes(ec))
    throw new Error(`Invalid error correction mode=${ec}. Expected: ${ECMode}`);
}
function validateEncoding(enc) {
  if (!Encoding.includes(enc))
    throw new Error(`Encoding: invalid mode=${enc}. Expected: ${Encoding}`);
  if (enc === "kanji" || enc === "eci")
    throw new Error(`Encoding: ${enc} is not supported (yet?).`);
}
function validateMask(mask2) {
  if (![0, 1, 2, 3, 4, 5, 6, 7].includes(mask2) || !PATTERNS[mask2])
    throw new Error(`Invalid mask=${mask2}. Expected number [0..7]`);
}
function encodeQR(text, output = "raw", opts = {}) {
  const ecc = opts.ecc !== void 0 ? opts.ecc : "medium";
  validateECC(ecc);
  const encoding = opts.encoding !== void 0 ? opts.encoding : detectType(text);
  validateEncoding(encoding);
  if (opts.mask !== void 0)
    validateMask(opts.mask);
  let ver = opts.version;
  let data, err = new Error("Unknown error");
  if (ver !== void 0) {
    validateVersion(ver);
    data = encode5(ver, ecc, text, encoding);
  } else {
    for (let i = 1; i <= 40; i++) {
      try {
        data = encode5(i, ecc, text, encoding);
        ver = i;
        break;
      } catch (e) {
        err = e;
      }
    }
  }
  if (!ver || !data)
    throw err;
  let res = drawQRBest(ver, ecc, data, opts.mask);
  res.assertDrawn();
  const border2 = opts.border === void 0 ? 2 : opts.border;
  if (!Number.isSafeInteger(border2))
    throw new Error(`invalid border type=${typeof border2}`);
  res = res.border(border2, false);
  if (opts.scale !== void 0)
    res = res.scale(opts.scale);
  if (output === "raw")
    return res.data;
  else if (output === "ascii")
    return res.toASCII();
  else if (output === "svg")
    return res.toSVG(opts.optimize);
  else if (output === "gif")
    return res.toGIF();
  else if (output === "term")
    return res.toTerm();
  else
    throw new Error(`Unknown output: ${output}`);
}

// node_modules/cuer/_dist/QrCode.js
function create4(value, options = {}) {
  const { errorCorrection, version: version5 } = options;
  const grid = encodeQR(value, "raw", {
    border: 0,
    ecc: errorCorrection,
    scale: 1,
    version: version5
  });
  const finderLength = 7;
  const edgeLength = grid.length;
  return {
    edgeLength,
    finderLength,
    grid,
    value
  };
}

// node_modules/cuer/_dist/Cuer.js
function Cuer(props) {
  const { arena, ...rest } = props;
  return (0, import_jsx_runtime.jsxs)(Cuer.Root, { ...rest, children: [(0, import_jsx_runtime.jsx)(Cuer.Finder, {}), (0, import_jsx_runtime.jsx)(Cuer.Cells, {}), arena && (0, import_jsx_runtime.jsx)(Cuer.Arena, { children: typeof arena === "string" ? (0, import_jsx_runtime.jsx)("img", { alt: "Arena", src: arena, style: {
    borderRadius: 1,
    height: "100%",
    objectFit: "cover",
    width: "100%"
  } }) : arena })] });
}
(function(Cuer2) {
  Cuer2.Context = React10.createContext(null);
  function Root(props) {
    const { children, size: size5 = "100%", value, version: version5, errorCorrection, ...rest } = props;
    const hasArena = React10.useMemo(() => (React10.Children.map(children, (child) => {
      if (!React10.isValidElement(child))
        return null;
      if (typeof child.type === "string")
        return null;
      if ("displayName" in child.type && child.type.displayName === "Arena")
        return true;
      return null;
    }) ?? []).some(Boolean), [children]);
    const qrcode = React10.useMemo(() => {
      let ecl = errorCorrection;
      if (hasArena && errorCorrection === "low")
        ecl = "medium";
      return create4(value, {
        errorCorrection: ecl,
        version: version5
      });
    }, [value, hasArena, errorCorrection, version5]);
    const cellSize = 1;
    const edgeSize = qrcode.edgeLength * cellSize;
    const finderSize = qrcode.finderLength * cellSize / 2;
    const arenaSize = hasArena ? Math.floor(edgeSize / 4) : 0;
    const context = React10.useMemo(() => ({ arenaSize, cellSize, edgeSize, qrcode, finderSize }), [arenaSize, edgeSize, qrcode, finderSize]);
    return (0, import_jsx_runtime.jsx)(Cuer2.Context.Provider, { value: context, children: (0, import_jsx_runtime.jsxs)("svg", { ...rest, width: size5, height: size5, viewBox: `0 0 ${edgeSize} ${edgeSize}`, xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("title", { children: "QR Code" }), children] }) });
  }
  Cuer2.Root = Root;
  (function(Root2) {
    Root2.displayName = "Root";
  })(Root = Cuer2.Root || (Cuer2.Root = {}));
  function Finder(props) {
    const { className, fill, innerClassName, radius = 0.25 } = props;
    const { cellSize, edgeSize, finderSize } = React10.useContext(Cuer2.Context);
    function Inner({ position }) {
      let outerX = finderSize - (finderSize - cellSize) - cellSize / 2;
      if (position === "top-right")
        outerX = edgeSize - finderSize - (finderSize - cellSize) - cellSize / 2;
      let outerY = finderSize - (finderSize - cellSize) - cellSize / 2;
      if (position === "bottom-left")
        outerY = edgeSize - finderSize - (finderSize - cellSize) - cellSize / 2;
      let innerX = finderSize - cellSize * 1.5;
      if (position === "top-right")
        innerX = edgeSize - finderSize - cellSize * 1.5;
      let innerY = finderSize - cellSize * 1.5;
      if (position === "bottom-left")
        innerY = edgeSize - finderSize - cellSize * 1.5;
      return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("rect", { className, stroke: fill ?? "currentColor", fill: "transparent", x: outerX, y: outerY, width: cellSize + (finderSize - cellSize) * 2, height: cellSize + (finderSize - cellSize) * 2, rx: 2 * radius * (finderSize - cellSize), ry: 2 * radius * (finderSize - cellSize), strokeWidth: cellSize }), (0, import_jsx_runtime.jsx)("rect", { className: innerClassName, fill: fill ?? "currentColor", x: innerX, y: innerY, width: cellSize * 3, height: cellSize * 3, rx: 2 * radius * cellSize, ry: 2 * radius * cellSize })] });
    }
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Inner, { position: "top-left" }), (0, import_jsx_runtime.jsx)(Inner, { position: "top-right" }), (0, import_jsx_runtime.jsx)(Inner, { position: "bottom-left" })] });
  }
  Cuer2.Finder = Finder;
  (function(Finder2) {
    Finder2.displayName = "Finder";
  })(Finder = Cuer2.Finder || (Cuer2.Finder = {}));
  function Cells(props) {
    const { className, fill = "currentColor", inset: inset_ = true, radius = 1 } = props;
    const { arenaSize, cellSize, qrcode } = React10.useContext(Cuer2.Context);
    const { edgeLength, finderLength } = qrcode;
    const path2 = React10.useMemo(() => {
      let path3 = "";
      for (let i = 0; i < qrcode.grid.length; i++) {
        const row = qrcode.grid[i];
        if (!row)
          continue;
        for (let j = 0; j < row.length; j++) {
          const cell = row[j];
          if (!cell)
            continue;
          const start = edgeLength / 2 - arenaSize / 2;
          const end = start + arenaSize;
          if (i >= start && i <= end && j >= start && j <= end)
            continue;
          const topLeftFinder = i < finderLength && j < finderLength;
          const topRightFinder = i < finderLength && j >= edgeLength - finderLength;
          const bottomLeftFinder = i >= edgeLength - finderLength && j < finderLength;
          if (topLeftFinder || topRightFinder || bottomLeftFinder)
            continue;
          const inset = inset_ ? cellSize * 0.1 : 0;
          const innerSize = (cellSize - inset * 2) / 2;
          const cx = j * cellSize + cellSize / 2;
          const cy = i * cellSize + cellSize / 2;
          const left = cx - innerSize;
          const right = cx + innerSize;
          const top = cy - innerSize;
          const bottom = cy + innerSize;
          const r2 = radius * innerSize;
          path3 += [
            `M ${left + r2},${top}`,
            `L ${right - r2},${top}`,
            `A ${r2},${r2} 0 0,1 ${right},${top + r2}`,
            `L ${right},${bottom - r2}`,
            `A ${r2},${r2} 0 0,1 ${right - r2},${bottom}`,
            `L ${left + r2},${bottom}`,
            `A ${r2},${r2} 0 0,1 ${left},${bottom - r2}`,
            `L ${left},${top + r2}`,
            `A ${r2},${r2} 0 0,1 ${left + r2},${top}`,
            "z"
          ].join(" ");
        }
      }
      return path3;
    }, [
      arenaSize,
      cellSize,
      edgeLength,
      finderLength,
      qrcode.grid,
      inset_,
      radius
    ]);
    return (0, import_jsx_runtime.jsx)("path", { className, d: path2, fill });
  }
  Cuer2.Cells = Cells;
  (function(Cells2) {
    Cells2.displayName = "Cells";
  })(Cells = Cuer2.Cells || (Cuer2.Cells = {}));
  function Arena(props) {
    const { children } = props;
    const { arenaSize, cellSize, edgeSize } = React10.useContext(Cuer2.Context);
    const start = Math.ceil(edgeSize / 2 - arenaSize / 2);
    const size5 = arenaSize + arenaSize % 2;
    const padding = cellSize / 2;
    return (0, import_jsx_runtime.jsx)("foreignObject", { x: start, y: start, width: size5, height: size5, children: (0, import_jsx_runtime.jsx)("div", { style: {
      alignItems: "center",
      display: "flex",
      fontSize: 1,
      justifyContent: "center",
      height: "100%",
      overflow: "hidden",
      width: "100%",
      padding,
      boxSizing: "border-box"
    }, children }) });
  }
  Cuer2.Arena = Arena;
  (function(Arena2) {
    Arena2.displayName = "Arena";
  })(Arena = Cuer2.Arena || (Cuer2.Arena = {}));
})(Cuer || (Cuer = {}));

// node_modules/@rainbow-me/rainbowkit/dist/index.js
var import_react75 = __toESM(require_react());
var import_react76 = __toESM(require_react());
var import_react77 = __toESM(require_react());
var import_react78 = __toESM(require_react());

// node_modules/@wagmi/connectors/dist/esm/baseAccount.js
function baseAccount(parameters = {}) {
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect;
  return createConnector((config) => ({
    id: "baseAccount",
    name: "Base Account",
    rdns: "app.base.account",
    type: "baseAccount",
    async connect({ chainId, withCapabilities } = {}) {
      try {
        const provider = await this.getProvider();
        const accounts = (await provider.request({
          method: "eth_requestAccounts",
          params: []
        })).map((x) => getAddress(x));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        return {
          // TODO(v3): Make `withCapabilities: true` default behavior
          accounts: withCapabilities ? accounts.map((address) => ({ address, capabilities: {} })) : accounts,
          chainId: currentChainId
        };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
      provider.disconnect();
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return (await provider.request({
        method: "eth_accounts"
      })).map((x) => getAddress(x));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      if (!walletProvider) {
        const preference = (() => {
          var _a;
          if (typeof parameters.preference === "string")
            return { options: parameters.preference };
          return {
            ...parameters.preference,
            options: ((_a = parameters.preference) == null ? void 0 : _a.options) ?? "all"
          };
        })();
        const { createBaseAccountSDK } = await import("./dist-3OKCLCGD.js");
        const sdk = createBaseAccountSDK({
          ...parameters,
          appChainIds: config.chains.map((x) => x.id),
          preference
        });
        walletProvider = sdk.getProvider();
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a, _b, _c, _d;
      const chain = config.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = ((_a = chain.blockExplorers) == null ? void 0 : _a.default.url) ? [(_b = chain.blockExplorers) == null ? void 0 : _b.default.url] : [];
            let rpcUrls;
            if ((_c = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d = chain.rpcUrls.default) == null ? void 0 : _d.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
    }
  }));
}

// node_modules/@wagmi/connectors/dist/esm/coinbaseWallet.js
coinbaseWallet.type = "coinbaseWallet";
function coinbaseWallet(parameters = {}) {
  if (parameters.version === "3" || parameters.headlessMode)
    return version3(parameters);
  return version4(parameters);
}
function version4(parameters) {
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect;
  return createConnector((config) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    rdns: "com.coinbase.wallet",
    type: coinbaseWallet.type,
    async connect({ chainId, withCapabilities, ...rest } = {}) {
      try {
        const provider = await this.getProvider();
        const accounts = (await provider.request({
          method: "eth_requestAccounts",
          params: "instantOnboarding" in rest && rest.instantOnboarding ? [{ onboarding: "instant" }] : []
        })).map((x) => getAddress(x));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        return {
          accounts: withCapabilities ? accounts.map((address) => ({ address, capabilities: {} })) : accounts,
          chainId: currentChainId
        };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a;
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
      provider.disconnect();
      (_a = provider.close) == null ? void 0 : _a.call(provider);
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return (await provider.request({
        method: "eth_accounts"
      })).map((x) => getAddress(x));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      if (!walletProvider) {
        const preference = (() => {
          var _a;
          if (typeof parameters.preference === "string")
            return { options: parameters.preference };
          return {
            ...parameters.preference,
            options: ((_a = parameters.preference) == null ? void 0 : _a.options) ?? "all"
          };
        })();
        const { createCoinbaseWalletSDK } = await import("./dist-CODA6GWE.js");
        const sdk = createCoinbaseWalletSDK({
          ...parameters,
          appChainIds: config.chains.map((x) => x.id),
          preference
        });
        walletProvider = sdk.getProvider();
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a, _b, _c, _d;
      const chain = config.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = ((_a = chain.blockExplorers) == null ? void 0 : _a.default.url) ? [(_b = chain.blockExplorers) == null ? void 0 : _b.default.url] : [];
            let rpcUrls;
            if ((_c = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d = chain.rpcUrls.default) == null ? void 0 : _d.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
    }
  }));
}
function version3(parameters) {
  const reloadOnDisconnect = false;
  let sdk;
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect;
  return createConnector((config) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    rdns: "com.coinbase.wallet",
    type: coinbaseWallet.type,
    async connect({ chainId, withCapabilities } = {}) {
      try {
        const provider = await this.getProvider();
        const accounts = (await provider.request({
          method: "eth_requestAccounts"
        })).map((x) => getAddress(x));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        return {
          accounts: withCapabilities ? accounts.map((address) => ({ address, capabilities: {} })) : accounts,
          chainId: currentChainId
        };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
      provider.disconnect();
      provider.close();
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return (await provider.request({
        method: "eth_accounts"
      })).map((x) => getAddress(x));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      var _a;
      if (!walletProvider) {
        const CoinbaseWalletSDK = await (async () => {
          const { default: SDK } = await import("./dist-WCQLJ3UE.js");
          if (typeof SDK !== "function" && typeof SDK.default === "function")
            return SDK.default;
          return SDK;
        })();
        sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect });
        const walletExtensionChainId = (_a = sdk.walletExtension) == null ? void 0 : _a.getChainId();
        const chain = config.chains.find((chain2) => parameters.chainId ? chain2.id === parameters.chainId : chain2.id === walletExtensionChainId) || config.chains[0];
        const chainId = parameters.chainId || (chain == null ? void 0 : chain.id);
        const jsonRpcUrl = parameters.jsonRpcUrl || (chain == null ? void 0 : chain.rpcUrls.default.http[0]);
        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId);
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a, _b, _c, _d;
      const chain = config.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = ((_a = chain.blockExplorers) == null ? void 0 : _a.default.url) ? [(_b = chain.blockExplorers) == null ? void 0 : _b.default.url] : [];
            let rpcUrls;
            if ((_c = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d = chain.rpcUrls.default) == null ? void 0 : _d.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
    }
  }));
}

// node_modules/@gemini-wallet/core/dist/index.js
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM2 = (mod3, isNodeMode, target) => {
  target = mod3 != null ? __create(__getProtoOf(mod3)) : {};
  const to2 = isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod3))
    if (!__hasOwnProp.call(to2, key))
      __defProp(to2, key, {
        get: () => mod3[key],
        enumerable: true
      });
  return to2;
};
var __commonJS2 = (cb, mod3) => () => (mod3 || cb((mod3 = { exports: {} }).exports, mod3), mod3.exports);
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var U32_MASK64;
var _32n;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
var init__u64 = __esm(() => {
  U32_MASK64 = BigInt(2 ** 32 - 1);
  _32n = BigInt(32);
});
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes2(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance) {
  abytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u323(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean3(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView2(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function byteSwap2(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap2(arr[i]);
  }
  return arr;
}
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes7(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  abytes2(data);
  return data;
}
var Hash2 = class {
};
function createHasher2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes7(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
var isLE2;
var swap32IfBE2;
var init_utils = __esm(() => {
  isLE2 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  swap32IfBE2 = isLE2 ? (u) => u : byteSwap32;
});
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  clean3(B);
}
var _0n7;
var _1n7;
var _2n7;
var _7n;
var _256n;
var _0x71n;
var SHA3_PI;
var SHA3_ROTL;
var _SHA3_IOTA;
var IOTAS;
var SHA3_IOTA_H;
var SHA3_IOTA_L;
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
var Keccak;
var gen = (suffix, blockLen, outputLen) => createHasher2(() => new Keccak(blockLen, suffix, outputLen));
var keccak_256;
var init_sha3 = __esm(() => {
  init__u64();
  init_utils();
  _0n7 = BigInt(0);
  _1n7 = BigInt(1);
  _2n7 = BigInt(2);
  _7n = BigInt(7);
  _256n = BigInt(256);
  _0x71n = BigInt(113);
  SHA3_PI = [];
  SHA3_ROTL = [];
  _SHA3_IOTA = [];
  for (let round = 0, R = _1n7, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n7;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n7 ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n7)
        t ^= _1n7 << (_1n7 << BigInt(j)) - _1n7;
    }
    _SHA3_IOTA.push(t);
  }
  IOTAS = split(_SHA3_IOTA, true);
  SHA3_IOTA_H = IOTAS[0];
  SHA3_IOTA_L = IOTAS[1];
  Keccak = class Keccak2 extends Hash2 {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      this.enableXOF = false;
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      anumber2(outputLen);
      if (!(0 < blockLen && blockLen < 200))
        throw new Error("only keccak-f1600 function is supported");
      this.state = new Uint8Array(200);
      this.state32 = u323(this.state);
    }
    clone() {
      return this._cloneInto();
    }
    keccak() {
      swap32IfBE2(this.state32);
      keccakP(this.state32, this.rounds);
      swap32IfBE2(this.state32);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      aexists2(this);
      data = toBytes7(data);
      abytes2(data);
      const { blockLen, state } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0; i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      aexists2(this, false);
      abytes2(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes) {
      anumber2(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
      aoutput2(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      clean3(this.state);
    }
    _cloneInto(to2) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to2 || (to2 = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
      to2.state32.set(this.state32);
      to2.pos = this.pos;
      to2.posOut = this.posOut;
      to2.finished = this.finished;
      to2.rounds = rounds;
      to2.suffix = suffix;
      to2.outputLen = outputLen;
      to2.enableXOF = enableXOF;
      to2.destroyed = this.destroyed;
      return to2;
    }
  };
  keccak_256 = (() => gen(1, 136, 256 / 8))();
});
var require_fast_safe_stringify = __commonJS2((exports, module) => {
  module.exports = stringify;
  stringify.default = stringify;
  stringify.stable = deterministicStringify;
  stringify.stableStringify = deterministicStringify;
  var LIMIT_REPLACE_NODE = "[...]";
  var CIRCULAR_REPLACE_NODE = "[Circular]";
  var arr = [];
  var replacerStack = [];
  function defaultOptions2() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function stringify(obj, replacer, spacer, options) {
    if (typeof options === "undefined") {
      options = defaultOptions2();
    }
    decirc(obj, "", 0, [], void 0, 0, options);
    var res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(obj, replacer, spacer);
      } else {
        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        var part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return res;
  }
  function setReplace(replace, val, k, parent) {
    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
    if (propertyDescriptor.get !== void 0) {
      if (propertyDescriptor.configurable) {
        Object.defineProperty(parent, k, { value: replace });
        arr.push([parent, k, val, propertyDescriptor]);
      } else {
        replacerStack.push([val, k, replace]);
      }
    } else {
      parent[k] = replace;
      arr.push([parent, k, val]);
    }
  }
  function decirc(val, k, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i;
    if (typeof val === "object" && val !== null) {
      for (i = 0; i < stack.length; i++) {
        if (stack[i] === val) {
          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
          return;
        }
      }
      if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return;
      }
      if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return;
      }
      stack.push(val);
      if (Array.isArray(val)) {
        for (i = 0; i < val.length; i++) {
          decirc(val[i], i, i, stack, val, depth, options);
        }
      } else {
        var keys = Object.keys(val);
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          decirc(val[key], key, i, stack, val, depth, options);
        }
      }
      stack.pop();
    }
  }
  function compareFunction(a, b) {
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  }
  function deterministicStringify(obj, replacer, spacer, options) {
    if (typeof options === "undefined") {
      options = defaultOptions2();
    }
    var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
    var res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(tmp, replacer, spacer);
      } else {
        res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        var part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return res;
  }
  function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i;
    if (typeof val === "object" && val !== null) {
      for (i = 0; i < stack.length; i++) {
        if (stack[i] === val) {
          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
          return;
        }
      }
      try {
        if (typeof val.toJSON === "function") {
          return;
        }
      } catch (_) {
        return;
      }
      if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return;
      }
      if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return;
      }
      stack.push(val);
      if (Array.isArray(val)) {
        for (i = 0; i < val.length; i++) {
          deterministicDecirc(val[i], i, i, stack, val, depth, options);
        }
      } else {
        var tmp = {};
        var keys = Object.keys(val).sort(compareFunction);
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          deterministicDecirc(val[key], key, i, stack, val, depth, options);
          tmp[key] = val[key];
        }
        if (typeof parent !== "undefined") {
          arr.push([parent, k, val]);
          parent[k] = tmp;
        } else {
          return tmp;
        }
      }
      stack.pop();
    }
  }
  function replaceGetterValues(replacer) {
    replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
      return v;
    };
    return function(key, val) {
      if (replacerStack.length > 0) {
        for (var i = 0; i < replacerStack.length; i++) {
          var part = replacerStack[i];
          if (part[1] === key && part[0] === val) {
            val = part[2];
            replacerStack.splice(i, 1);
            break;
          }
        }
      }
      return replacer.call(this, key, val);
    };
  }
});
var require_eventemitter3 = __commonJS2((exports, module) => {
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter2;
  }
});
function execTyped(regex, string2) {
  const match = regex.exec(string2);
  return match == null ? void 0 : match.groups;
}
var init_regex = () => {
};
function formatAbiParameter(abiParameter) {
  let type6 = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type6 = "(";
    const length = abiParameter.components.length;
    for (let i = 0; i < length; i++) {
      const component = abiParameter.components[i];
      type6 += formatAbiParameter(component);
      if (i < length - 1)
        type6 += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type6 += `)${(result == null ? void 0 : result.array) ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type: type6
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type6 = `${type6} indexed`;
  if (abiParameter.name)
    return `${type6} ${abiParameter.name}`;
  return type6;
}
var tupleRegex;
var init_formatAbiParameter = __esm(() => {
  init_regex();
  tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
});
function formatAbiParameters(abiParameters) {
  let params = "";
  const length = abiParameters.length;
  for (let i = 0; i < length; i++) {
    const abiParameter = abiParameters[i];
    params += formatAbiParameter(abiParameter);
    if (i !== length - 1)
      params += ", ";
  }
  return params;
}
var init_formatAbiParameters = __esm(() => {
  init_formatAbiParameter();
});
function formatAbiItem2(abiItem) {
  var _a;
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${((_a = abiItem.outputs) == null ? void 0 : _a.length) ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  if (abiItem.type === "fallback")
    return `fallback() external${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  return "receive() external payable";
}
var init_formatAbiItem = __esm(() => {
  init_formatAbiParameters();
});
var init_exports = __esm(() => {
  init_formatAbiItem();
});
function formatAbiItem22(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}
var init_formatAbiItem2 = __esm(() => {
  init_abi();
});
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
function size4(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
var init_size = () => {
};
var version = "2.33.3";
function walk(err, fn) {
  if (fn == null ? void 0 : fn(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause !== void 0)
    return walk(err.cause, fn);
  return fn ? null : err;
}
var errorConfig;
var BaseError3;
var init_base = __esm(() => {
  errorConfig = {
    getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
    version: `viem@${version}`
  };
  BaseError3 = class BaseError4 extends Error {
    constructor(shortMessage, args = {}) {
      var _a;
      const details = (() => {
        var _a2;
        if (args.cause instanceof BaseError4)
          return args.cause.details;
        if ((_a2 = args.cause) == null ? void 0 : _a2.message)
          return args.cause.message;
        return args.details;
      })();
      const docsPath = (() => {
        if (args.cause instanceof BaseError4)
          return args.cause.docsPath || args.docsPath;
        return args.docsPath;
      })();
      const docsUrl = (_a = errorConfig.getDocsUrl) == null ? void 0 : _a.call(errorConfig, { ...args, docsPath });
      const message = [
        shortMessage || "An error occurred.",
        "",
        ...args.metaMessages ? [...args.metaMessages, ""] : [],
        ...docsUrl ? [`Docs: ${docsUrl}`] : [],
        ...details ? [`Details: ${details}`] : [],
        ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
      ].join(`
`);
      super(message, args.cause ? { cause: args.cause } : void 0);
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "metaMessages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "version", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BaseError"
      });
      this.details = details;
      this.docsPath = docsPath;
      this.metaMessages = args.metaMessages;
      this.name = args.name ?? this.name;
      this.shortMessage = shortMessage;
      this.version = version;
    }
    walk(fn) {
      return walk(this, fn);
    }
  };
});
var AbiEncodingArrayLengthMismatchError;
var AbiEncodingBytesSizeMismatchError;
var AbiEncodingLengthMismatchError;
var AbiFunctionNotFoundError;
var AbiItemAmbiguityError;
var BytesSizeMismatchError;
var InvalidAbiEncodingTypeError;
var InvalidArrayError;
var InvalidDefinitionTypeError;
var UnsupportedPackedAbiType;
var init_abi = __esm(() => {
  init_formatAbiItem2();
  init_size();
  init_base();
  AbiEncodingArrayLengthMismatchError = class AbiEncodingArrayLengthMismatchError extends BaseError3 {
    constructor({ expectedLength, givenLength, type: type6 }) {
      super([
        `ABI encoding array length mismatch for type ${type6}.`,
        `Expected length: ${expectedLength}`,
        `Given length: ${givenLength}`
      ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
    }
  };
  AbiEncodingBytesSizeMismatchError = class AbiEncodingBytesSizeMismatchError extends BaseError3 {
    constructor({ expectedSize, value }) {
      super(`Size of bytes "${value}" (bytes${size4(value)}) does not match expected size (bytes${expectedSize}).`, { name: "AbiEncodingBytesSizeMismatchError" });
    }
  };
  AbiEncodingLengthMismatchError = class AbiEncodingLengthMismatchError extends BaseError3 {
    constructor({ expectedLength, givenLength }) {
      super([
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${expectedLength}`,
        `Given length (values): ${givenLength}`
      ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
    }
  };
  AbiFunctionNotFoundError = class AbiFunctionNotFoundError extends BaseError3 {
    constructor(functionName, { docsPath } = {}) {
      super([
        `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiFunctionNotFoundError"
      });
    }
  };
  AbiItemAmbiguityError = class AbiItemAmbiguityError extends BaseError3 {
    constructor(x, y) {
      super("Found ambiguous types in overloaded ABI items.", {
        metaMessages: [
          `\`${x.type}\` in \`${formatAbiItem22(x.abiItem)}\`, and`,
          `\`${y.type}\` in \`${formatAbiItem22(y.abiItem)}\``,
          "",
          "These types encode differently and cannot be distinguished at runtime.",
          "Remove one of the ambiguous items in the ABI."
        ],
        name: "AbiItemAmbiguityError"
      });
    }
  };
  BytesSizeMismatchError = class BytesSizeMismatchError extends BaseError3 {
    constructor({ expectedSize, givenSize }) {
      super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
        name: "BytesSizeMismatchError"
      });
    }
  };
  InvalidAbiEncodingTypeError = class InvalidAbiEncodingTypeError extends BaseError3 {
    constructor(type6, { docsPath }) {
      super([
        `Type "${type6}" is not a valid encoding type.`,
        "Please provide a valid ABI type."
      ].join(`
`), { docsPath, name: "InvalidAbiEncodingType" });
    }
  };
  InvalidArrayError = class InvalidArrayError extends BaseError3 {
    constructor(value) {
      super([`Value "${value}" is not a valid array.`].join(`
`), {
        name: "InvalidArrayError"
      });
    }
  };
  InvalidDefinitionTypeError = class InvalidDefinitionTypeError extends BaseError3 {
    constructor(type6) {
      super([
        `"${type6}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"'
      ].join(`
`), { name: "InvalidDefinitionTypeError" });
    }
  };
  UnsupportedPackedAbiType = class UnsupportedPackedAbiType extends BaseError3 {
    constructor(type6) {
      super(`Type "${type6}" is not supported for packed encoding.`, {
        name: "UnsupportedPackedAbiType"
      });
    }
  };
});
var SliceOffsetOutOfBoundsError;
var SizeExceedsPaddingSizeError;
var init_data = __esm(() => {
  init_base();
  SliceOffsetOutOfBoundsError = class SliceOffsetOutOfBoundsError extends BaseError3 {
    constructor({ offset, position, size: size22 }) {
      super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size22}).`, { name: "SliceOffsetOutOfBoundsError" });
    }
  };
  SizeExceedsPaddingSizeError = class SizeExceedsPaddingSizeError extends BaseError3 {
    constructor({ size: size22, targetSize, type: type6 }) {
      super(`${type6.charAt(0).toUpperCase()}${type6.slice(1).toLowerCase()} size (${size22}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
    }
  };
});
function pad(hexOrBytes, { dir, size: size22 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size22 });
  return padBytes(hexOrBytes, { dir, size: size22 });
}
function padHex(hex_, { dir, size: size22 = 32 } = {}) {
  if (size22 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size22 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size22,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size22 * 2, "0")}`;
}
function padBytes(bytes, { dir, size: size22 = 32 } = {}) {
  if (size22 === null)
    return bytes;
  if (bytes.length > size22)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size22,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size22);
  for (let i = 0; i < size22; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size22 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
  }
  return paddedBytes;
}
var init_pad = __esm(() => {
  init_data();
});
var IntegerOutOfRangeError;
var SizeOverflowError;
var init_encoding = __esm(() => {
  init_base();
  IntegerOutOfRangeError = class IntegerOutOfRangeError extends BaseError3 {
    constructor({ max, min, signed, size: size22, value }) {
      super(`Number "${value}" is not in safe ${size22 ? `${size22 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
    }
  };
  SizeOverflowError = class SizeOverflowError extends BaseError3 {
    constructor({ givenSize, maxSize }) {
      super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
    }
  };
});
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}
function assertSize(hexOrBytes, { size: size22 }) {
  if (size4(hexOrBytes) > size22)
    throw new SizeOverflowError({
      givenSize: size4(hexOrBytes),
      maxSize: size22
    });
}
function hexToBigInt(hex, opts = {}) {
  const { signed } = opts;
  if (opts.size)
    assertSize(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed)
    return value;
  const size22 = (hex.length - 2) / 2;
  const max = (1n << BigInt(size22) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size22 * 2, "f")}`) - 1n;
}
function hexToNumber2(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
var init_fromHex = __esm(() => {
  init_encoding();
  init_size();
});
function toHex6(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex2(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex2(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex2(value, opts = {}) {
  let string2 = "";
  for (let i = 0; i < value.length; i++) {
    string2 += hexes2[value[i]];
  }
  const hex = `0x${string2}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex2(value_, opts = {}) {
  const { signed, size: size22 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size22) {
    if (signed)
      maxValue = (1n << BigInt(size22) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size22) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size22,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size22 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size22)
    return pad(hex, { size: size22 });
  return hex;
}
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex2(value, opts);
}
var hexes2;
var encoder;
var init_toHex = __esm(() => {
  init_encoding();
  init_pad();
  init_fromHex();
  hexes2 = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
  encoder = new TextEncoder();
});
function toBytes22(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes = new Uint8Array(1);
  bytes[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { size: opts.size });
  }
  return bytes;
}
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return;
}
function hexToBytes(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = pad(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index2 = 0, j = 0; index2 < length; index2++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError3(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function numberToBytes(value, opts) {
  const hex = numberToHex2(value, opts);
  return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
  const bytes = encoder2.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { dir: "right", size: opts.size });
  }
  return bytes;
}
var encoder2;
var charCodeMap;
var init_toBytes = __esm(() => {
  init_base();
  init_pad();
  init_fromHex();
  init_toHex();
  encoder2 = new TextEncoder();
  charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
});
function keccak2562(value, to_) {
  const to2 = to_ || "hex";
  const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes22(value) : value);
  if (to2 === "bytes")
    return bytes;
  return toHex6(bytes);
}
var init_keccak256 = __esm(() => {
  init_sha3();
  init_toBytes();
  init_toHex();
});
function hashSignature(sig) {
  return hash7(sig);
}
var hash7 = (value) => keccak2562(toBytes22(value));
var init_hashSignature = __esm(() => {
  init_toBytes();
  init_keccak256();
});
function normalizeSignature(signature) {
  let active2 = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i = 0; i < signature.length; i++) {
    const char = signature[i];
    if (["(", ")", ","].includes(char))
      active2 = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active2)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active2 = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError3("Unable to normalize signature.");
  return result;
}
var init_normalizeSignature = __esm(() => {
  init_base();
});
var toSignature = (def) => {
  const def_ = (() => {
    if (typeof def === "string")
      return def;
    return formatAbiItem2(def);
  })();
  return normalizeSignature(def_);
};
var init_toSignature = __esm(() => {
  init_exports();
  init_normalizeSignature();
});
function toSignatureHash(fn) {
  return hashSignature(toSignature(fn));
}
var init_toSignatureHash = __esm(() => {
  init_hashSignature();
  init_toSignature();
});
var toEventSelector;
var init_toEventSelector = __esm(() => {
  init_toSignatureHash();
  toEventSelector = toSignatureHash;
});
var InvalidAddressError;
var init_address = __esm(() => {
  init_base();
  InvalidAddressError = class InvalidAddressError extends BaseError3 {
    constructor({ address }) {
      super(`Address "${address}" is invalid.`, {
        metaMessages: [
          "- Address must be a hex value of 20 bytes (40 hex characters).",
          "- Address must match its checksum counterpart."
        ],
        name: "InvalidAddressError"
      });
    }
  };
});
var LruMap;
var init_lru = __esm(() => {
  LruMap = class LruMap extends Map {
    constructor(size22) {
      super();
      Object.defineProperty(this, "maxSize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.maxSize = size22;
    }
    get(key) {
      const value = super.get(key);
      if (super.has(key) && value !== void 0) {
        this.delete(key);
        super.set(key, value);
      }
      return value;
    }
    set(key, value) {
      super.set(key, value);
      if (this.maxSize && this.size > this.maxSize) {
        const firstKey = this.keys().next().value;
        if (firstKey)
          this.delete(firstKey);
      }
      return this;
    }
  };
});
function checksumAddress(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash22 = keccak2562(stringToBytes(hexAddress), "bytes");
  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i = 0; i < 40; i += 2) {
    if (hash22[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash22[i >> 1] & 15) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  const result = `0x${address.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
var checksumAddressCache;
var init_getAddress = __esm(() => {
  init_address();
  init_toBytes();
  init_keccak256();
  init_lru();
  init_isAddress();
  checksumAddressCache = new LruMap(8192);
});
function isAddress2(address, options) {
  const { strict = true } = options ?? {};
  const cacheKey = `${address}.${strict}`;
  if (isAddressCache.has(cacheKey))
    return isAddressCache.get(cacheKey);
  const result = (() => {
    if (!addressRegex.test(address))
      return false;
    if (address.toLowerCase() === address)
      return true;
    if (strict)
      return checksumAddress(address) === address;
    return true;
  })();
  isAddressCache.set(cacheKey, result);
  return result;
}
var addressRegex;
var isAddressCache;
var init_isAddress = __esm(() => {
  init_lru();
  init_getAddress();
  addressRegex = /^0x[a-fA-F0-9]{40}$/;
  isAddressCache = new LruMap(8192);
});
function concatHex(values) {
  return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
}
function slice3(value, start, end, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size4(value) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: size4(value)
    });
}
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size4(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size4(value)
    });
  }
}
function sliceBytes(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
var init_slice = __esm(() => {
  init_data();
  init_size();
});
var arrayRegex;
var bytesRegex;
var integerRegex;
var init_regex2 = __esm(() => {
  arrayRegex = /^(.*)\[([0-9]*)\]$/;
  bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
});
var init_encodeAbiParameters = __esm(() => {
  init_abi();
  init_address();
  init_base();
  init_encoding();
  init_isAddress();
  init_pad();
  init_size();
  init_slice();
  init_toHex();
  init_regex2();
});
var init_toFunctionSelector = __esm(() => {
  init_slice();
  init_toSignatureHash();
});
var init_getAbiItem = __esm(() => {
  init_abi();
  init_isAddress();
  init_toEventSelector();
  init_toFunctionSelector();
});
var init_prepareEncodeFunctionData = __esm(() => {
  init_abi();
  init_toFunctionSelector();
  init_formatAbiItem2();
  init_getAbiItem();
});
var init_encodeFunctionData = __esm(() => {
  init_encodeAbiParameters();
  init_prepareEncodeFunctionData();
});
var NegativeOffsetError;
var PositionOutOfBoundsError2;
var RecursiveReadLimitExceededError;
var init_cursor = __esm(() => {
  init_base();
  NegativeOffsetError = class NegativeOffsetError extends BaseError3 {
    constructor({ offset }) {
      super(`Offset \`${offset}\` cannot be negative.`, {
        name: "NegativeOffsetError"
      });
    }
  };
  PositionOutOfBoundsError2 = class PositionOutOfBoundsError extends BaseError3 {
    constructor({ length, position }) {
      super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, { name: "PositionOutOfBoundsError" });
    }
  };
  RecursiveReadLimitExceededError = class RecursiveReadLimitExceededError extends BaseError3 {
    constructor({ count, limit: limit2 }) {
      super(`Recursive read limit of \`${limit2}\` exceeded (recursive read count: \`${count}\`).`, { name: "RecursiveReadLimitExceededError" });
    }
  };
});
function createCursor(bytes, { recursiveReadLimit = 8192 } = {}) {
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes;
  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  cursor.positionReadCount = /* @__PURE__ */ new Map();
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
var staticCursor;
var init_cursor2 = __esm(() => {
  init_cursor();
  staticCursor = {
    bytes: new Uint8Array(),
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: /* @__PURE__ */ new Map(),
    recursiveReadCount: 0,
    recursiveReadLimit: Number.POSITIVE_INFINITY,
    assertReadLimit() {
      if (this.recursiveReadCount >= this.recursiveReadLimit)
        throw new RecursiveReadLimitExceededError({
          count: this.recursiveReadCount + 1,
          limit: this.recursiveReadLimit
        });
    },
    assertPosition(position) {
      if (position < 0 || position > this.bytes.length - 1)
        throw new PositionOutOfBoundsError2({
          length: this.bytes.length,
          position
        });
    },
    decrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position - offset;
      this.assertPosition(position);
      this.position = position;
    },
    getReadCount(position) {
      return this.positionReadCount.get(position || this.position) || 0;
    },
    incrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position + offset;
      this.assertPosition(position);
      this.position = position;
    },
    inspectByte(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectBytes(length, position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + length - 1);
      return this.bytes.subarray(position, position + length);
    },
    inspectUint8(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectUint16(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 1);
      return this.dataView.getUint16(position);
    },
    inspectUint24(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 2);
      return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
    },
    inspectUint32(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 3);
      return this.dataView.getUint32(position);
    },
    pushByte(byte) {
      this.assertPosition(this.position);
      this.bytes[this.position] = byte;
      this.position++;
    },
    pushBytes(bytes) {
      this.assertPosition(this.position + bytes.length - 1);
      this.bytes.set(bytes, this.position);
      this.position += bytes.length;
    },
    pushUint8(value) {
      this.assertPosition(this.position);
      this.bytes[this.position] = value;
      this.position++;
    },
    pushUint16(value) {
      this.assertPosition(this.position + 1);
      this.dataView.setUint16(this.position, value);
      this.position += 2;
    },
    pushUint24(value) {
      this.assertPosition(this.position + 2);
      this.dataView.setUint16(this.position, value >> 8);
      this.dataView.setUint8(this.position + 2, value & ~4294967040);
      this.position += 3;
    },
    pushUint32(value) {
      this.assertPosition(this.position + 3);
      this.dataView.setUint32(this.position, value);
      this.position += 4;
    },
    readByte() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectByte();
      this.position++;
      return value;
    },
    readBytes(length, size22) {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectBytes(length);
      this.position += size22 ?? length;
      return value;
    },
    readUint8() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint8();
      this.position += 1;
      return value;
    },
    readUint16() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint16();
      this.position += 2;
      return value;
    },
    readUint24() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint24();
      this.position += 3;
      return value;
    },
    readUint32() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint32();
      this.position += 4;
      return value;
    },
    get remaining() {
      return this.bytes.length - this.position;
    },
    setPosition(position) {
      const oldPosition = this.position;
      this.assertPosition(position);
      this.position = position;
      return () => this.position = oldPosition;
    },
    _touch() {
      if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
        return;
      const count = this.getReadCount();
      this.positionReadCount.set(this.position, count + 1);
      if (count > 0)
        this.recursiveReadCount++;
    }
  };
});
var gweiUnits;
var init_unit = __esm(() => {
  gweiUnits = {
    ether: -9,
    wei: 9
  };
});
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer2, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer2 || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatGwei2(wei, unit = "wei") {
  return formatUnits(wei, gweiUnits[unit]);
}
var init_formatGwei = __esm(() => {
  init_unit();
});
function prettyPrint2(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === void 0 || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join(`
`);
}
var InvalidLegacyVError;
var InvalidSerializableTransactionError;
var InvalidStorageKeySizeError2;
var init_transaction = __esm(() => {
  init_base();
  InvalidLegacyVError = class InvalidLegacyVError extends BaseError3 {
    constructor({ v }) {
      super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
        name: "InvalidLegacyVError"
      });
    }
  };
  InvalidSerializableTransactionError = class InvalidSerializableTransactionError extends BaseError3 {
    constructor({ transaction }) {
      super("Cannot infer a transaction type from provided transaction.", {
        metaMessages: [
          "Provided Transaction:",
          "{",
          prettyPrint2(transaction),
          "}",
          "",
          "To infer the type, either provide:",
          "- a `type` to the Transaction, or",
          "- an EIP-1559 Transaction with `maxFeePerGas`, or",
          "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
          "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
          "- an EIP-7702 Transaction with `authorizationList`, or",
          "- a Legacy Transaction with `gasPrice`"
        ],
        name: "InvalidSerializableTransactionError"
      });
    }
  };
  InvalidStorageKeySizeError2 = class InvalidStorageKeySizeError extends BaseError3 {
    constructor({ storageKey: storageKey6 }) {
      super(`Size for storage key "${storageKey6}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey6.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
    }
  };
});
var ExecutionRevertedError;
var FeeCapTooHighError2;
var FeeCapTooLowError;
var NonceTooHighError;
var NonceTooLowError;
var NonceMaxValueError;
var InsufficientFundsError;
var IntrinsicGasTooHighError;
var IntrinsicGasTooLowError;
var TransactionTypeNotSupportedError;
var TipAboveFeeCapError2;
var init_node = __esm(() => {
  init_formatGwei();
  init_base();
  ExecutionRevertedError = class ExecutionRevertedError extends BaseError3 {
    constructor({ cause, message } = {}) {
      var _a;
      const reason = (_a = message == null ? void 0 : message.replace("execution reverted: ", "")) == null ? void 0 : _a.replace("execution reverted", "");
      super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
        cause,
        name: "ExecutionRevertedError"
      });
    }
  };
  Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 3
  });
  Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /execution reverted/
  });
  FeeCapTooHighError2 = class FeeCapTooHighError extends BaseError3 {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei2(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
        cause,
        name: "FeeCapTooHighError"
      });
    }
  };
  Object.defineProperty(FeeCapTooHighError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
  });
  FeeCapTooLowError = class FeeCapTooLowError extends BaseError3 {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei2(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
        cause,
        name: "FeeCapTooLowError"
      });
    }
  };
  Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
  });
  NonceTooHighError = class NonceTooHighError extends BaseError3 {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause, name: "NonceTooHighError" });
    }
  };
  Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too high/
  });
  NonceTooLowError = class NonceTooLowError extends BaseError3 {
    constructor({ cause, nonce } = {}) {
      super([
        `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
        "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
      ].join(`
`), { cause, name: "NonceTooLowError" });
    }
  };
  Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too low|transaction already imported|already known/
  });
  NonceMaxValueError = class NonceMaxValueError extends BaseError3 {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause, name: "NonceMaxValueError" });
    }
  };
  Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce has max value/
  });
  InsufficientFundsError = class InsufficientFundsError extends BaseError3 {
    constructor({ cause } = {}) {
      super([
        "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
      ].join(`
`), {
        cause,
        metaMessages: [
          "This error could arise when the account does not have enough funds to:",
          " - pay for the total gas fee,",
          " - pay for the value to send.",
          " ",
          "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
          " - `gas` is the amount of gas needed for transaction to execute,",
          " - `gas fee` is the gas fee,",
          " - `value` is the amount of ether to send to the recipient."
        ],
        name: "InsufficientFundsError"
      });
    }
  };
  Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /insufficient funds|exceeds transaction sender account balance/
  });
  IntrinsicGasTooHighError = class IntrinsicGasTooHighError extends BaseError3 {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
        cause,
        name: "IntrinsicGasTooHighError"
      });
    }
  };
  Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too high|gas limit reached/
  });
  IntrinsicGasTooLowError = class IntrinsicGasTooLowError extends BaseError3 {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
        cause,
        name: "IntrinsicGasTooLowError"
      });
    }
  };
  Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too low/
  });
  TransactionTypeNotSupportedError = class TransactionTypeNotSupportedError extends BaseError3 {
    constructor({ cause }) {
      super("The transaction type is not supported for this chain.", {
        cause,
        name: "TransactionTypeNotSupportedError"
      });
    }
  };
  Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /transaction type not valid/
  });
  TipAboveFeeCapError2 = class TipAboveFeeCapError extends BaseError3 {
    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
      super([
        `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei2(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei2(maxFeePerGas)} gwei` : ""}).`
      ].join(`
`), {
        cause,
        name: "TipAboveFeeCapError"
      });
    }
  };
  Object.defineProperty(TipAboveFeeCapError2, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
  });
});
function defineFormatter(type6, format5) {
  return ({ exclude, format: overrides }) => {
    return {
      exclude,
      format: (args) => {
        const formatted = format5(args);
        if (exclude) {
          for (const key of exclude) {
            delete formatted[key];
          }
        }
        return {
          ...formatted,
          ...overrides(args)
        };
      },
      type: type6
    };
  };
}
var maxInt8;
var maxInt16;
var maxInt24;
var maxInt32;
var maxInt40;
var maxInt48;
var maxInt56;
var maxInt64;
var maxInt72;
var maxInt80;
var maxInt88;
var maxInt96;
var maxInt104;
var maxInt112;
var maxInt120;
var maxInt128;
var maxInt136;
var maxInt144;
var maxInt152;
var maxInt160;
var maxInt168;
var maxInt176;
var maxInt184;
var maxInt192;
var maxInt200;
var maxInt208;
var maxInt216;
var maxInt224;
var maxInt232;
var maxInt240;
var maxInt248;
var maxInt256;
var minInt8;
var minInt16;
var minInt24;
var minInt32;
var minInt40;
var minInt48;
var minInt56;
var minInt64;
var minInt72;
var minInt80;
var minInt88;
var minInt96;
var minInt104;
var minInt112;
var minInt120;
var minInt128;
var minInt136;
var minInt144;
var minInt152;
var minInt160;
var minInt168;
var minInt176;
var minInt184;
var minInt192;
var minInt200;
var minInt208;
var minInt216;
var minInt224;
var minInt232;
var minInt240;
var minInt248;
var minInt256;
var maxUint8;
var maxUint16;
var maxUint24;
var maxUint32;
var maxUint40;
var maxUint48;
var maxUint56;
var maxUint64;
var maxUint72;
var maxUint80;
var maxUint88;
var maxUint96;
var maxUint104;
var maxUint112;
var maxUint120;
var maxUint128;
var maxUint136;
var maxUint144;
var maxUint152;
var maxUint160;
var maxUint168;
var maxUint176;
var maxUint184;
var maxUint192;
var maxUint200;
var maxUint208;
var maxUint216;
var maxUint224;
var maxUint232;
var maxUint240;
var maxUint248;
var maxUint256;
var init_number = __esm(() => {
  maxInt8 = 2n ** (8n - 1n) - 1n;
  maxInt16 = 2n ** (16n - 1n) - 1n;
  maxInt24 = 2n ** (24n - 1n) - 1n;
  maxInt32 = 2n ** (32n - 1n) - 1n;
  maxInt40 = 2n ** (40n - 1n) - 1n;
  maxInt48 = 2n ** (48n - 1n) - 1n;
  maxInt56 = 2n ** (56n - 1n) - 1n;
  maxInt64 = 2n ** (64n - 1n) - 1n;
  maxInt72 = 2n ** (72n - 1n) - 1n;
  maxInt80 = 2n ** (80n - 1n) - 1n;
  maxInt88 = 2n ** (88n - 1n) - 1n;
  maxInt96 = 2n ** (96n - 1n) - 1n;
  maxInt104 = 2n ** (104n - 1n) - 1n;
  maxInt112 = 2n ** (112n - 1n) - 1n;
  maxInt120 = 2n ** (120n - 1n) - 1n;
  maxInt128 = 2n ** (128n - 1n) - 1n;
  maxInt136 = 2n ** (136n - 1n) - 1n;
  maxInt144 = 2n ** (144n - 1n) - 1n;
  maxInt152 = 2n ** (152n - 1n) - 1n;
  maxInt160 = 2n ** (160n - 1n) - 1n;
  maxInt168 = 2n ** (168n - 1n) - 1n;
  maxInt176 = 2n ** (176n - 1n) - 1n;
  maxInt184 = 2n ** (184n - 1n) - 1n;
  maxInt192 = 2n ** (192n - 1n) - 1n;
  maxInt200 = 2n ** (200n - 1n) - 1n;
  maxInt208 = 2n ** (208n - 1n) - 1n;
  maxInt216 = 2n ** (216n - 1n) - 1n;
  maxInt224 = 2n ** (224n - 1n) - 1n;
  maxInt232 = 2n ** (232n - 1n) - 1n;
  maxInt240 = 2n ** (240n - 1n) - 1n;
  maxInt248 = 2n ** (248n - 1n) - 1n;
  maxInt256 = 2n ** (256n - 1n) - 1n;
  minInt8 = -(2n ** (8n - 1n));
  minInt16 = -(2n ** (16n - 1n));
  minInt24 = -(2n ** (24n - 1n));
  minInt32 = -(2n ** (32n - 1n));
  minInt40 = -(2n ** (40n - 1n));
  minInt48 = -(2n ** (48n - 1n));
  minInt56 = -(2n ** (56n - 1n));
  minInt64 = -(2n ** (64n - 1n));
  minInt72 = -(2n ** (72n - 1n));
  minInt80 = -(2n ** (80n - 1n));
  minInt88 = -(2n ** (88n - 1n));
  minInt96 = -(2n ** (96n - 1n));
  minInt104 = -(2n ** (104n - 1n));
  minInt112 = -(2n ** (112n - 1n));
  minInt120 = -(2n ** (120n - 1n));
  minInt128 = -(2n ** (128n - 1n));
  minInt136 = -(2n ** (136n - 1n));
  minInt144 = -(2n ** (144n - 1n));
  minInt152 = -(2n ** (152n - 1n));
  minInt160 = -(2n ** (160n - 1n));
  minInt168 = -(2n ** (168n - 1n));
  minInt176 = -(2n ** (176n - 1n));
  minInt184 = -(2n ** (184n - 1n));
  minInt192 = -(2n ** (192n - 1n));
  minInt200 = -(2n ** (200n - 1n));
  minInt208 = -(2n ** (208n - 1n));
  minInt216 = -(2n ** (216n - 1n));
  minInt224 = -(2n ** (224n - 1n));
  minInt232 = -(2n ** (232n - 1n));
  minInt240 = -(2n ** (240n - 1n));
  minInt248 = -(2n ** (248n - 1n));
  minInt256 = -(2n ** (256n - 1n));
  maxUint8 = 2n ** 8n - 1n;
  maxUint16 = 2n ** 16n - 1n;
  maxUint24 = 2n ** 24n - 1n;
  maxUint32 = 2n ** 32n - 1n;
  maxUint40 = 2n ** 40n - 1n;
  maxUint48 = 2n ** 48n - 1n;
  maxUint56 = 2n ** 56n - 1n;
  maxUint64 = 2n ** 64n - 1n;
  maxUint72 = 2n ** 72n - 1n;
  maxUint80 = 2n ** 80n - 1n;
  maxUint88 = 2n ** 88n - 1n;
  maxUint96 = 2n ** 96n - 1n;
  maxUint104 = 2n ** 104n - 1n;
  maxUint112 = 2n ** 112n - 1n;
  maxUint120 = 2n ** 120n - 1n;
  maxUint128 = 2n ** 128n - 1n;
  maxUint136 = 2n ** 136n - 1n;
  maxUint144 = 2n ** 144n - 1n;
  maxUint152 = 2n ** 152n - 1n;
  maxUint160 = 2n ** 160n - 1n;
  maxUint168 = 2n ** 168n - 1n;
  maxUint176 = 2n ** 176n - 1n;
  maxUint184 = 2n ** 184n - 1n;
  maxUint192 = 2n ** 192n - 1n;
  maxUint200 = 2n ** 200n - 1n;
  maxUint208 = 2n ** 208n - 1n;
  maxUint216 = 2n ** 216n - 1n;
  maxUint224 = 2n ** 224n - 1n;
  maxUint232 = 2n ** 232n - 1n;
  maxUint240 = 2n ** 240n - 1n;
  maxUint248 = 2n ** 248n - 1n;
  maxUint256 = 2n ** 256n - 1n;
});
function setBigUint642(view, byteOffset, value, isLE22) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE22);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE22 ? 4 : 0;
  const l = isLE22 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE22);
  view.setUint32(byteOffset + l, wl, isLE22);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD;
var SHA256_IV;
var init__md = __esm(() => {
  init_utils();
  HashMD = class HashMD extends Hash2 {
    constructor(blockLen, outputLen, padOffset, isLE22) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE22;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView2(this.buffer);
    }
    update(data) {
      aexists2(this);
      data = toBytes7(data);
      abytes2(data);
      const { view, buffer: buffer2, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView2(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer2.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists2(this);
      aoutput2(out, this);
      this.finished = true;
      const { buffer: buffer2, view, blockLen, isLE: isLE22 } = this;
      let { pos } = this;
      buffer2[pos++] = 128;
      clean3(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer2[i] = 0;
      setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE22);
      this.process(view, 0);
      const oview = createView2(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE22);
    }
    digest() {
      const { buffer: buffer2, outputLen } = this;
      this.digestInto(buffer2);
      const res = buffer2.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to2) {
      to2 || (to2 = new this.constructor());
      to2.set(...this.get());
      const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
      to2.destroyed = destroyed;
      to2.finished = finished;
      to2.length = length;
      to2.pos = pos;
      if (length % blockLen)
        to2.buffer.set(buffer2);
      return to2;
    }
    clone() {
      return this._cloneInto();
    }
  };
  SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
});
var SHA256_K;
var SHA256_W;
var SHA256;
var sha2563;
var init_sha2 = __esm(() => {
  init__md();
  init_utils();
  SHA256_K = Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  SHA256_W = new Uint32Array(64);
  SHA256 = class SHA256 extends HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      clean3(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean3(this.buffer);
    }
  };
  sha2563 = createHasher2(() => new SHA256());
});
var InvalidChainIdError2;
var init_chain = __esm(() => {
  init_base();
  InvalidChainIdError2 = class InvalidChainIdError extends BaseError3 {
    constructor({ chainId }) {
      super(typeof chainId === "number" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
    }
  };
});
var StructError = class extends TypeError {
  constructor(failure, failures) {
    let cached;
    const { message, explanation, ...rest } = failure;
    const { path: path2 } = failure;
    const cause = path2.length === 0 ? message : `At path: ${path2.join(".")} -- ${message}`;
    super(explanation ?? cause);
    if (explanation !== null && explanation !== void 0) {
      this.cause = cause;
    }
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      return cached ?? (cached = [failure, ...failures()]);
    };
  }
};
function isIterable(value) {
  return isObject(value) && typeof value[Symbol.iterator] === "function";
}
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function print(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
  const { done, value } = input.next();
  return done ? void 0 : value;
}
function toFailure(result, context, struct, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path: path2, branch } = context;
  const { type: type6 } = struct;
  const { refinement, message = `Expected a value of type \`${type6}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
  return {
    value,
    type: type6,
    refinement,
    key: path2[path2.length - 1],
    path: path2,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const validationResult of result) {
    const failure = toFailure(validationResult, context, struct, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct, options = {}) {
  const { path: path2 = [], branch = [value], coerce: coerce2 = false, mask: mask2 = false } = options;
  const context = { path: path2, branch };
  if (coerce2) {
    value = struct.coercer(value, context);
    if (mask2 && struct.type !== "type" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct.schema[key] === void 0) {
          delete value[key];
        }
      }
    }
  }
  let status = "valid";
  for (const failure of struct.validator(value, context)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, void 0];
  }
  for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)) {
    const iterable = run(innerValue, innerStruct, {
      path: innerKey === void 0 ? path2 : [...path2, innerKey],
      branch: innerKey === void 0 ? branch : [...branch, innerValue],
      coerce: coerce2,
      mask: mask2,
      message: options.message
    });
    for (const result of iterable) {
      if (result[0]) {
        status = result[0].refinement === null || result[0].refinement === void 0 ? "not_valid" : "not_refined";
        yield [result[0], void 0];
      } else if (coerce2) {
        innerValue = result[1];
        if (innerKey === void 0) {
          value = innerValue;
        } else if (value instanceof Map) {
          value.set(innerKey, innerValue);
        } else if (value instanceof Set) {
          value.add(innerValue);
        } else if (isObject(value)) {
          if (innerValue !== void 0 || innerKey in value) {
            value[innerKey] = innerValue;
          }
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct.refiner(value, context)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, void 0];
    }
  }
  if (status === "valid") {
    yield [void 0, value];
  }
}
var Struct = class {
  constructor(props) {
    const { type: type6, schema, validator, refiner, coercer = (value) => value, entries = function* () {
    } } = props;
    this.type = type6;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  assert(value, message) {
    return assert7(value, this, message);
  }
  create(value, message) {
    return create5(value, this, message);
  }
  is(value) {
    return is(value, this);
  }
  mask(value, message) {
    return mask(value, this, message);
  }
  validate(value, options = {}) {
    return validate11(value, this, options);
  }
};
var ExactOptionalBrand = "EXACT_OPTIONAL";
var ExactOptionalStruct = class extends Struct {
  constructor(props) {
    super({
      ...props,
      type: `exact optional ${props.type}`
    });
    this.brand = ExactOptionalBrand;
  }
  static isExactOptional(value) {
    return isObject(value) && "brand" in value && value.brand === ExactOptionalBrand;
  }
};
function assert7(value, struct, message) {
  const result = validate11(value, struct, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create5(value, struct, message) {
  const result = validate11(value, struct, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct, message) {
  const result = validate11(value, struct, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct) {
  const result = validate11(value, struct);
  return !result[0];
}
function validate11(value, struct, options = {}) {
  const tuples = run(value, struct, options);
  const tuple = shiftIterator(tuples);
  if (tuple[0]) {
    const error = new StructError(tuple[0], function* () {
      for (const innerTuple of tuples) {
        if (innerTuple[0]) {
          yield innerTuple[0];
        }
      }
    });
    return [error, void 0];
  }
  const validatedValue = tuple[1];
  return [void 0, validatedValue];
}
function define2(name, validator) {
  return new Struct({ type: name, schema: null, validator });
}
function any() {
  return define2("any", () => true);
}
function array(Element2) {
  return new Struct({
    type: "array",
    schema: Element2,
    *entries(value) {
      if (Element2 && Array.isArray(value)) {
        for (const [index2, arrayValue] of value.entries()) {
          yield [index2, arrayValue, Element2];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
    }
  });
}
function integer() {
  return define2("integer", (value) => {
    return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;
  });
}
function literal(constant) {
  const description = print(constant);
  const valueType = typeof constant;
  return new Struct({
    type: "literal",
    schema: valueType === "string" || valueType === "number" || valueType === "boolean" ? constant : null,
    validator(value) {
      return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
    }
  });
}
function never() {
  return define2("never", () => false);
}
function nullable(struct) {
  return new Struct({
    ...struct,
    validator: (value, ctx) => value === null || struct.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
  });
}
function number() {
  return define2("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
  });
}
function object(schema) {
  const knowns = schema ? Object.keys(schema) : [];
  const Never = never();
  return new Struct({
    type: "object",
    schema: schema ?? null,
    *entries(value) {
      if (schema && isObject(value)) {
        const unknowns = new Set(Object.keys(value));
        for (const key of knowns) {
          unknowns.delete(key);
          const propertySchema = schema[key];
          if (ExactOptionalStruct.isExactOptional(propertySchema) && !Object.prototype.hasOwnProperty.call(value, key)) {
            continue;
          }
          yield [key, value[key], schema[key]];
        }
        for (const key of unknowns) {
          yield [key, value[key], Never];
        }
      }
    },
    validator(value) {
      return isObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isObject(value) ? { ...value } : value;
    }
  });
}
function optional(struct) {
  return new Struct({
    ...struct,
    validator: (value, ctx) => value === void 0 || struct.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct.refiner(value, ctx)
  });
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject(value)) {
        for (const objectKey in value) {
          const objectValue = value[objectKey];
          yield [objectKey, objectKey, Key];
          yield [objectKey, objectValue, Value];
        }
      }
    },
    validator(value) {
      return isObject(value) || `Expected an object, but received: ${print(value)}`;
    }
  });
}
function string() {
  return define2("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
  });
}
function union(Structs) {
  const description = Structs.map((struct) => struct.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    coercer(value) {
      for (const InnerStruct of Structs) {
        const [error, coerced] = InnerStruct.validate(value, { coerce: true });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const InnerStruct of Structs) {
        const [...tuples] = run(value, InnerStruct, ctx);
        const [first] = tuples;
        if (!(first == null ? void 0 : first[0])) {
          return [];
        }
        for (const [failure] of tuples) {
          if (failure) {
            failures.push(failure);
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
        ...failures
      ];
    }
  });
}
function unknown() {
  return define2("unknown", () => true);
}
function coerce(struct, condition, coercer) {
  return new Struct({
    ...struct,
    coercer: (value, ctx) => {
      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
    }
  });
}
function refine(struct, name, refiner) {
  return new Struct({
    ...struct,
    *refiner(value, ctx) {
      yield* struct.refiner(value, ctx);
      const result = refiner(value, ctx);
      const failures = toFailures(result, ctx, struct, value);
      for (const failure of failures) {
        yield { ...failure, refinement: name };
      }
    }
  });
}
function isObject2(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
var hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
var JsonSize;
(function(JsonSize2) {
  JsonSize2[JsonSize2["Null"] = 4] = "Null";
  JsonSize2[JsonSize2["Comma"] = 1] = "Comma";
  JsonSize2[JsonSize2["Wrapper"] = 1] = "Wrapper";
  JsonSize2[JsonSize2["True"] = 4] = "True";
  JsonSize2[JsonSize2["False"] = 5] = "False";
  JsonSize2[JsonSize2["Quote"] = 1] = "Quote";
  JsonSize2[JsonSize2["Colon"] = 1] = "Colon";
  JsonSize2[JsonSize2["Date"] = 24] = "Date";
})(JsonSize = JsonSize || (JsonSize = {}));
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  try {
    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
  } catch (_) {
    return false;
  }
}
var object2 = (schema) => object(schema);
function hasOptional({ path: path2, branch }) {
  const field = path2[path2.length - 1];
  return hasProperty(branch[branch.length - 2], field);
}
function exactOptional(struct) {
  return new Struct({
    ...struct,
    type: `optional ${struct.type}`,
    validator: (value, context) => !hasOptional(context) || struct.validator(value, context),
    refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context)
  });
}
function validateJson(json) {
  if (json === null || typeof json === "boolean" || typeof json === "string") {
    return true;
  }
  if (typeof json === "number" && Number.isFinite(json)) {
    return true;
  }
  if (typeof json === "object") {
    let every = true;
    if (Array.isArray(json)) {
      for (let i = 0; i < json.length; i++) {
        if (!validateJson(json[i])) {
          every = false;
          break;
        }
      }
      return every;
    }
    const entries = Object.entries(json);
    for (let i = 0; i < entries.length; i++) {
      if (typeof entries[i][0] !== "string" || !validateJson(entries[i][1])) {
        every = false;
        break;
      }
    }
    return every;
  }
  return false;
}
var UnsafeJsonStruct = define2("JSON", (json) => validateJson(json));
var JsonStruct = coerce(UnsafeJsonStruct, refine(any(), "JSON", (value) => is(value, UnsafeJsonStruct)), (value) => JSON.parse(JSON.stringify(value, (propKey, propValue) => {
  if (propKey === "__proto__" || propKey === "constructor") {
    return;
  }
  return propValue;
})));
function isValidJson(value) {
  try {
    getSafeJson(value);
    return true;
  } catch {
    return false;
  }
}
function getSafeJson(value) {
  return create5(value, JsonStruct);
}
var jsonrpc2 = "2.0";
var JsonRpcVersionStruct = literal(jsonrpc2);
var JsonRpcIdStruct = nullable(union([number(), string()]));
var JsonRpcErrorStruct = object2({
  code: integer(),
  message: string(),
  data: exactOptional(JsonStruct),
  stack: exactOptional(string())
});
var JsonRpcParamsStruct = union([record(string(), JsonStruct), array(JsonStruct)]);
var JsonRpcRequestStruct = object2({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  method: string(),
  params: exactOptional(JsonRpcParamsStruct)
});
var JsonRpcNotificationStruct = object2({
  jsonrpc: JsonRpcVersionStruct,
  method: string(),
  params: exactOptional(JsonRpcParamsStruct)
});
var PendingJsonRpcResponseStruct = object({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  result: optional(unknown()),
  error: optional(JsonRpcErrorStruct)
});
var JsonRpcSuccessStruct = object2({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  result: JsonStruct
});
var JsonRpcFailureStruct = object2({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  error: JsonRpcErrorStruct
});
var JsonRpcResponseStruct = union([
  JsonRpcSuccessStruct,
  JsonRpcFailureStruct
]);
function isJsonRpcError(value) {
  return is(value, JsonRpcErrorStruct);
}
var import_fast_safe_stringify = __toESM2(require_fast_safe_stringify(), 1);
var errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
var errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  "4001": {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  "4100": {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  "4200": {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  "4900": {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  "4901": {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
var FALLBACK_ERROR_CODE = errorCodes.rpc.internal;
var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
var FALLBACK_ERROR = {
  code: FALLBACK_ERROR_CODE,
  message: getMessageFromCode(FALLBACK_ERROR_CODE)
};
var JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
  if (isValidCode(code)) {
    const codeString = code.toString();
    if (hasProperty(errorValues, codeString)) {
      return errorValues[codeString].message;
    }
    if (isJsonRpcServerError(code)) {
      return JSON_RPC_SERVER_ERROR_MESSAGE;
    }
  }
  return fallbackMessage;
}
function isValidCode(code) {
  return Number.isInteger(code);
}
function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true, shouldPreserveMessage = true } = {}) {
  if (!isJsonRpcError(fallbackError)) {
    throw new Error("Must provide fallback error with integer number code and string message.");
  }
  const serialized = buildError(error, fallbackError, shouldPreserveMessage);
  if (!shouldIncludeStack) {
    delete serialized.stack;
  }
  return serialized;
}
function buildError(error, fallbackError, shouldPreserveMessage) {
  if (error && typeof error === "object" && "serialize" in error && typeof error.serialize === "function") {
    return error.serialize();
  }
  if (isJsonRpcError(error)) {
    return error;
  }
  const originalMessage = getOriginalMessage(error);
  const cause = serializeCause(error);
  const fallbackWithCause = {
    ...fallbackError,
    ...shouldPreserveMessage && originalMessage && { message: originalMessage },
    data: { cause }
  };
  return fallbackWithCause;
}
function getOriginalMessage(error) {
  if (isObject2(error) && hasProperty(error, "message") && typeof error.message === "string" && error.message.length > 0) {
    return error.message;
  }
  return;
}
function isJsonRpcServerError(code) {
  return code >= -32099 && code <= -32e3;
}
function serializeCause(error) {
  if (Array.isArray(error)) {
    return error.map((entry) => {
      if (isValidJson(entry)) {
        return entry;
      } else if (isObject2(entry)) {
        return serializeObject(entry);
      }
      return null;
    });
  } else if (isObject2(error)) {
    return serializeObject(error);
  }
  if (isValidJson(error)) {
    return error;
  }
  return null;
}
function serializeObject(object3) {
  return Object.getOwnPropertyNames(object3).reduce((acc, key) => {
    const value = object3[key];
    if (isValidJson(value)) {
      acc[key] = value;
    }
    return acc;
  }, {});
}
function dataHasCause(data) {
  return isObject2(data) && hasProperty(data, "cause") && isObject2(data.cause);
}
function $importDefault(module) {
  if (module == null ? void 0 : module.__esModule) {
    return module.default;
  }
  return module;
}
var safeStringify = $importDefault(import_fast_safe_stringify.default);
var JsonRpcError = class extends Error {
  constructor(code, message, data) {
    if (!Number.isInteger(code)) {
      throw new Error('"code" must be an integer.');
    }
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a non-empty string.');
    }
    if (dataHasCause(data)) {
      super(message, { cause: data.cause });
      if (!hasProperty(this, "cause")) {
        Object.assign(this, { cause: data.cause });
      }
    } else {
      super(message);
    }
    if (data !== void 0) {
      this.data = data;
    }
    this.code = code;
  }
  serialize() {
    const serialized = {
      code: this.code,
      message: this.message
    };
    if (this.data !== void 0) {
      serialized.data = this.data;
      if (isPlainObject(this.data)) {
        serialized.data.cause = serializeCause(this.data.cause);
      }
    }
    if (this.stack) {
      serialized.stack = this.stack;
    }
    return serialized;
  }
  toString() {
    return safeStringify(this.serialize(), stringifyReplacer, 2);
  }
};
var EthereumProviderError = class extends JsonRpcError {
  constructor(code, message, data) {
    if (!isValidEthProviderCode(code)) {
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    }
    super(code, message, data);
  }
};
function isValidEthProviderCode(code) {
  return Number.isInteger(code) && code >= 1e3 && code <= 4999;
}
function stringifyReplacer(_, value) {
  if (value === "[Circular]") {
    return;
  }
  return value;
}
var rpcErrors = {
  parse: (arg) => getJsonRpcError(errorCodes.rpc.parse, arg),
  invalidRequest: (arg) => getJsonRpcError(errorCodes.rpc.invalidRequest, arg),
  invalidParams: (arg) => getJsonRpcError(errorCodes.rpc.invalidParams, arg),
  methodNotFound: (arg) => getJsonRpcError(errorCodes.rpc.methodNotFound, arg),
  internal: (arg) => getJsonRpcError(errorCodes.rpc.internal, arg),
  server: (opts) => {
    if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
      throw new Error("Ethereum RPC Server errors must provide single object argument.");
    }
    const { code } = opts;
    if (!Number.isInteger(code) || code > -32005 || code < -32099) {
      throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
    }
    return getJsonRpcError(code, opts);
  },
  invalidInput: (arg) => getJsonRpcError(errorCodes.rpc.invalidInput, arg),
  resourceNotFound: (arg) => getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),
  resourceUnavailable: (arg) => getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),
  transactionRejected: (arg) => getJsonRpcError(errorCodes.rpc.transactionRejected, arg),
  methodNotSupported: (arg) => getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),
  limitExceeded: (arg) => getJsonRpcError(errorCodes.rpc.limitExceeded, arg)
};
var providerErrors = {
  userRejectedRequest: (arg) => {
    return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);
  },
  unauthorized: (arg) => {
    return getEthProviderError(errorCodes.provider.unauthorized, arg);
  },
  unsupportedMethod: (arg) => {
    return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);
  },
  disconnected: (arg) => {
    return getEthProviderError(errorCodes.provider.disconnected, arg);
  },
  chainDisconnected: (arg) => {
    return getEthProviderError(errorCodes.provider.chainDisconnected, arg);
  },
  custom: (opts) => {
    if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
      throw new Error("Ethereum Provider custom errors must provide single object argument.");
    }
    const { code, message, data } = opts;
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a nonempty string');
    }
    return new EthereumProviderError(code, message, data);
  }
};
function getJsonRpcError(code, arg) {
  const [message, data] = parseOpts(arg);
  return new JsonRpcError(code, message ?? getMessageFromCode(code), data);
}
function getEthProviderError(code, arg) {
  const [message, data] = parseOpts(arg);
  return new EthereumProviderError(code, message ?? getMessageFromCode(code), data);
}
function parseOpts(arg) {
  if (arg) {
    if (typeof arg === "string") {
      return [arg];
    } else if (typeof arg === "object" && !Array.isArray(arg)) {
      const { message, data } = arg;
      if (message && typeof message !== "string") {
        throw new Error("Must specify string message.");
      }
      return [message ?? void 0, data];
    }
  }
  return [];
}
var import__2 = __toESM2(require_eventemitter3(), 1);
var GeminiSdkEvent;
((GeminiSdkEvent2) => {
  GeminiSdkEvent2["POPUP_LOADED"] = "POPUP_LOADED";
  GeminiSdkEvent2["POPUP_UNLOADED"] = "POPUP_UNLOADED";
  GeminiSdkEvent2["POPUP_APP_CONTEXT"] = "POPUP_APP_CONTEXT";
  GeminiSdkEvent2["SDK_CONNECT"] = "SDK_CONNECT";
  GeminiSdkEvent2["SDK_DISCONNECT"] = "SDK_DISCONNECT";
  GeminiSdkEvent2["SDK_SEND_TRANSACTION"] = "SDK_SEND_TRANSACTION";
  GeminiSdkEvent2["SDK_SIGN_DATA"] = "SDK_SIGN_DATA";
  GeminiSdkEvent2["SDK_SIGN_TYPED_DATA"] = "SDK_SIGN_TYPED_DATA";
  GeminiSdkEvent2["SDK_SWITCH_CHAIN"] = "SDK_SWITCH_CHAIN";
  GeminiSdkEvent2["SDK_OPEN_SETTINGS"] = "SDK_OPEN_SETTINGS";
})(GeminiSdkEvent || (GeminiSdkEvent = {}));
var ProviderEventEmitter = class extends import__2.default {
};
init_base();
init_cursor2();
init_toBytes();
init_toHex();
function toRlp(bytes, to2 = "hex") {
  const encodable = getEncodable(bytes);
  const cursor = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to2 === "hex")
    return bytesToHex2(cursor.bytes);
  return cursor.bytes;
}
function getEncodable(bytes) {
  if (Array.isArray(bytes))
    return getEncodableList(bytes.map((x) => getEncodable(x)));
  return getEncodableBytes(bytes);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode: encode6 } of list) {
        encode6(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === "string" ? hexToBytes(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length = (() => {
    if (bytes.length === 1 && bytes[0] < 128)
      return 1;
    if (bytes.length <= 55)
      return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 128) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(128 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes.length);
        else
          cursor.pushUint32(bytes.length);
        cursor.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength(length) {
  if (length < 2 ** 8)
    return 1;
  if (length < 2 ** 16)
    return 2;
  if (length < 2 ** 24)
    return 3;
  if (length < 2 ** 32)
    return 4;
  throw new BaseError3("Length is too large.");
}
init_fromHex();
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber2(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber2(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);
init_toBytes();
init_toHex();
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to2 = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to2 === "bytes" ? commitments : commitments.map((x) => bytesToHex2(x));
}
init_toBytes();
init_toHex();
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to2 = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => hexToBytes(x)) : parameters.commitments;
  const proofs = [];
  for (let i = 0; i < blobs.length; i++) {
    const blob = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to2 === "bytes" ? proofs : proofs.map((x) => bytesToHex2(x));
}
init_toHex();
init_sha2();
var sha25622 = sha2563;
init_toBytes();
init_toHex();
function sha25632(value, to_) {
  const to2 = to_ || "hex";
  const bytes = sha25622(isHex(value, { strict: false }) ? toBytes22(value) : value);
  if (to2 === "bytes")
    return bytes;
  return toHex6(bytes);
}
function commitmentToVersionedHash2(parameters) {
  const { commitment, version: version22 = 1 } = parameters;
  const to2 = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha25632(commitment, "bytes");
  versionedHash.set([version22], 0);
  return to2 === "bytes" ? versionedHash : bytesToHex2(versionedHash);
}
function commitmentsToVersionedHashes2(parameters) {
  const { commitments, version: version22 } = parameters;
  const to2 = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash2({
      commitment,
      to: to2,
      version: version22
    }));
  }
  return hashes;
}
var blobsPerTransaction2 = 6;
var bytesPerFieldElement2 = 32;
var fieldElementsPerBlob2 = 4096;
var bytesPerBlob2 = bytesPerFieldElement2 * fieldElementsPerBlob2;
var maxBytesPerTransaction2 = bytesPerBlob2 * blobsPerTransaction2 - 1 - 1 * fieldElementsPerBlob2 * blobsPerTransaction2;
var versionedHashVersionKzg = 1;
init_base();
var BlobSizeTooLargeError2 = class extends BaseError3 {
  constructor({ maxSize, size: size22 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size22} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
};
var EmptyBlobError2 = class extends BaseError3 {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
};
var InvalidVersionedHashSizeError2 = class extends BaseError3 {
  constructor({ hash: hash22, size: size22 }) {
    super(`Versioned hash "${hash22}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${size22}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
};
var InvalidVersionedHashVersionError2 = class extends BaseError3 {
  constructor({ hash: hash22, version: version22 }) {
    super(`Versioned hash "${hash22}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersionKzg}`,
        `Received: ${version22}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
};
init_cursor2();
init_size();
init_toBytes();
init_toHex();
function toBlobs(parameters) {
  const to2 = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
  const data = typeof parameters.data === "string" ? hexToBytes(parameters.data) : parameters.data;
  const size_ = size4(data);
  if (!size_)
    throw new EmptyBlobError2();
  if (size_ > maxBytesPerTransaction2)
    throw new BlobSizeTooLargeError2({
      maxSize: maxBytesPerTransaction2,
      size: size_
    });
  const blobs = [];
  let active2 = true;
  let position = 0;
  while (active2) {
    const blob = createCursor(new Uint8Array(bytesPerBlob2));
    let size22 = 0;
    while (size22 < fieldElementsPerBlob2) {
      const bytes = data.slice(position, position + (bytesPerFieldElement2 - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active2 = false;
        break;
      }
      size22++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to2 === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex2(x.bytes));
}
function toBlobSidecars(parameters) {
  const { data, kzg, to: to2 } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data, to: to2 });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to: to2 });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to: to2 });
  const sidecars = [];
  for (let i = 0; i < blobs.length; i++)
    sidecars.push({
      blob: blobs[i],
      commitment: commitments[i],
      proof: proofs[i]
    });
  return sidecars;
}
init_transaction();
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.authorizationList !== "undefined")
    return "eip7702";
  if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}
init_fromHex();
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber2(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);
function defineChain(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}
init_abi();
init_address();
init_isAddress();
init_pad();
init_toHex();
init_regex2();
init_toHex();
init_transaction();
init_toHex();
init_number();
init_address();
init_base();
init_chain();
init_node();
init_isAddress();
init_size();
init_slice();
init_fromHex();
function assertTransactionEIP7702(transaction) {
  const { authorizationList } = transaction;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const { chainId } = authorization;
      const address = authorization.address;
      if (!isAddress2(address))
        throw new InvalidAddressError({ address });
      if (chainId < 0)
        throw new InvalidChainIdError2({ chainId });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP4844(transaction) {
  const { blobVersionedHashes } = transaction;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0)
      throw new EmptyBlobError2();
    for (const hash22 of blobVersionedHashes) {
      const size_ = size4(hash22);
      const version22 = hexToNumber2(slice3(hash22, 0, 1));
      if (size_ !== 32)
        throw new InvalidVersionedHashSizeError2({ hash: hash22, size: size_ });
      if (version22 !== versionedHashVersionKzg)
        throw new InvalidVersionedHashVersionError2({
          hash: hash22,
          version: version22
        });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP1559(transaction) {
  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to: to2 } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (to2 && !isAddress2(to2))
    throw new InvalidAddressError({ address: to2 });
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError2({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError2({ maxFeePerGas, maxPriorityFeePerGas });
}
function assertTransactionEIP2930(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to: to2 } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (to2 && !isAddress2(to2))
    throw new InvalidAddressError({ address: to2 });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError3("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError2({ maxFeePerGas: gasPrice });
}
function assertTransactionLegacy(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to: to2 } = transaction;
  if (to2 && !isAddress2(to2))
    throw new InvalidAddressError({ address: to2 });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError3("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError2({ maxFeePerGas: gasPrice });
}
init_address();
init_transaction();
init_isAddress();
function serializeAccessList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const serializedAccessList = [];
  for (let i = 0; i < accessList.length; i++) {
    const { address, storageKeys } = accessList[i];
    for (let j = 0; j < storageKeys.length; j++) {
      if (storageKeys[j].length - 2 !== 64) {
        throw new InvalidStorageKeySizeError2({ storageKey: storageKeys[j] });
      }
    }
    if (!isAddress2(address, { strict: false })) {
      throw new InvalidAddressError({ address });
    }
    serializedAccessList.push([address, storageKeys]);
  }
  return serializedAccessList;
}
function serializeTransaction(transaction, signature) {
  const type6 = getTransactionType(transaction);
  if (type6 === "eip1559")
    return serializeTransactionEIP1559(transaction, signature);
  if (type6 === "eip2930")
    return serializeTransactionEIP2930(transaction, signature);
  if (type6 === "eip4844")
    return serializeTransactionEIP4844(transaction, signature);
  if (type6 === "eip7702")
    return serializeTransactionEIP7702(transaction, signature);
  return serializeTransactionLegacy(transaction, signature);
}
function serializeTransactionEIP7702(transaction, signature) {
  const { authorizationList, chainId, gas, nonce, to: to2, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP7702(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedAuthorizationList = serializeAuthorizationList(authorizationList);
  return concatHex([
    "0x04",
    toRlp([
      numberToHex2(chainId),
      nonce ? numberToHex2(nonce) : "0x",
      maxPriorityFeePerGas ? numberToHex2(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? numberToHex2(maxFeePerGas) : "0x",
      gas ? numberToHex2(gas) : "0x",
      to2 ?? "0x",
      value ? numberToHex2(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      serializedAuthorizationList,
      ...toYParitySignatureArray(transaction, signature)
    ])
  ]);
}
function serializeTransactionEIP4844(transaction, signature) {
  const { chainId, gas, nonce, to: to2, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP4844(transaction);
  let blobVersionedHashes = transaction.blobVersionedHashes;
  let sidecars = transaction.sidecars;
  if (transaction.blobs && (typeof blobVersionedHashes === "undefined" || typeof sidecars === "undefined")) {
    const blobs2 = typeof transaction.blobs[0] === "string" ? transaction.blobs : transaction.blobs.map((x) => bytesToHex2(x));
    const kzg = transaction.kzg;
    const commitments2 = blobsToCommitments({
      blobs: blobs2,
      kzg
    });
    if (typeof blobVersionedHashes === "undefined")
      blobVersionedHashes = commitmentsToVersionedHashes2({
        commitments: commitments2
      });
    if (typeof sidecars === "undefined") {
      const proofs2 = blobsToProofs({ blobs: blobs2, commitments: commitments2, kzg });
      sidecars = toBlobSidecars({ blobs: blobs2, commitments: commitments2, proofs: proofs2 });
    }
  }
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    numberToHex2(chainId),
    nonce ? numberToHex2(nonce) : "0x",
    maxPriorityFeePerGas ? numberToHex2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? numberToHex2(maxFeePerGas) : "0x",
    gas ? numberToHex2(gas) : "0x",
    to2 ?? "0x",
    value ? numberToHex2(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    maxFeePerBlobGas ? numberToHex2(maxFeePerBlobGas) : "0x",
    blobVersionedHashes ?? [],
    ...toYParitySignatureArray(transaction, signature)
  ];
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars)
    for (let i = 0; i < sidecars.length; i++) {
      const { blob, commitment, proof } = sidecars[i];
      blobs.push(blob);
      commitments.push(commitment);
      proofs.push(proof);
    }
  return concatHex([
    "0x03",
    sidecars ? toRlp([serializedTransaction, blobs, commitments, proofs]) : toRlp(serializedTransaction)
  ]);
}
function serializeTransactionEIP1559(transaction, signature) {
  const { chainId, gas, nonce, to: to2, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP1559(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    numberToHex2(chainId),
    nonce ? numberToHex2(nonce) : "0x",
    maxPriorityFeePerGas ? numberToHex2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? numberToHex2(maxFeePerGas) : "0x",
    gas ? numberToHex2(gas) : "0x",
    to2 ?? "0x",
    value ? numberToHex2(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x02",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionEIP2930(transaction, signature) {
  const { chainId, gas, data, nonce, to: to2, value, accessList, gasPrice } = transaction;
  assertTransactionEIP2930(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    numberToHex2(chainId),
    nonce ? numberToHex2(nonce) : "0x",
    gasPrice ? numberToHex2(gasPrice) : "0x",
    gas ? numberToHex2(gas) : "0x",
    to2 ?? "0x",
    value ? numberToHex2(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x01",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionLegacy(transaction, signature) {
  const { chainId = 0, gas, data, nonce, to: to2, value, gasPrice } = transaction;
  assertTransactionLegacy(transaction);
  let serializedTransaction = [
    nonce ? numberToHex2(nonce) : "0x",
    gasPrice ? numberToHex2(gasPrice) : "0x",
    gas ? numberToHex2(gas) : "0x",
    to2 ?? "0x",
    value ? numberToHex2(value) : "0x",
    data ?? "0x"
  ];
  if (signature) {
    const v = (() => {
      if (signature.v >= 35n) {
        const inferredChainId = (signature.v - 35n) / 2n;
        if (inferredChainId > 0)
          return signature.v;
        return 27n + (signature.v === 35n ? 0n : 1n);
      }
      if (chainId > 0)
        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
      const v2 = 27n + (signature.v === 27n ? 0n : 1n);
      if (signature.v !== v2)
        throw new InvalidLegacyVError({ v: signature.v });
      return v2;
    })();
    const r2 = trim(signature.r);
    const s = trim(signature.s);
    serializedTransaction = [
      ...serializedTransaction,
      numberToHex2(v),
      r2 === "0x00" ? "0x" : r2,
      s === "0x00" ? "0x" : s
    ];
  } else if (chainId > 0) {
    serializedTransaction = [
      ...serializedTransaction,
      numberToHex2(chainId),
      "0x",
      "0x"
    ];
  }
  return toRlp(serializedTransaction);
}
function toYParitySignatureArray(transaction, signature_) {
  const signature = signature_ ?? transaction;
  const { v, yParity } = signature;
  if (typeof signature.r === "undefined")
    return [];
  if (typeof signature.s === "undefined")
    return [];
  if (typeof v === "undefined" && typeof yParity === "undefined")
    return [];
  const r2 = trim(signature.r);
  const s = trim(signature.s);
  const yParity_ = (() => {
    if (typeof yParity === "number")
      return yParity ? numberToHex2(1) : "0x";
    if (v === 0n)
      return "0x";
    if (v === 1n)
      return numberToHex2(1);
    return v === 27n ? "0x" : numberToHex2(1);
  })();
  return [yParity_, r2 === "0x00" ? "0x" : r2, s === "0x00" ? "0x" : s];
}
function serializeAuthorizationList(authorizationList) {
  if (!authorizationList || authorizationList.length === 0)
    return [];
  const serializedAuthorizationList = [];
  for (const authorization of authorizationList) {
    const { chainId, nonce, ...signature } = authorization;
    const contractAddress = authorization.address;
    serializedAuthorizationList.push([
      chainId ? toHex6(chainId) : "0x",
      contractAddress,
      nonce ? toHex6(nonce) : "0x",
      ...toYParitySignatureArray({}, signature)
    ]);
  }
  return serializedAuthorizationList;
}
init_pad();
init_slice();
init_toBytes();
init_keccak256();
init_getAddress();
init_encodeAbiParameters();
init_encodeFunctionData();
init_keccak256();
var contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
};
init_fromHex();
var formatters = {
  block: defineBlock({
    format(args) {
      var _a;
      const transactions = (_a = args.transactions) == null ? void 0 : _a.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        if (formatted.typeHex === "0x7e") {
          formatted.isSystemTx = transaction.isSystemTx;
          formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : void 0;
          formatted.sourceHash = transaction.sourceHash;
          formatted.type = "deposit";
        }
        return formatted;
      });
      return {
        transactions,
        stateRoot: args.stateRoot
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x7e") {
        transaction.isSystemTx = args.isSystemTx;
        transaction.mint = args.mint ? hexToBigInt(args.mint) : void 0;
        transaction.sourceHash = args.sourceHash;
        transaction.type = "deposit";
      }
      return transaction;
    }
  }),
  transactionReceipt: defineTransactionReceipt({
    format(args) {
      return {
        l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
        l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
        l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
      };
    }
  })
};
init_address();
init_isAddress();
init_toHex();
function serializeTransaction2(transaction, signature) {
  if (isDeposit(transaction))
    return serializeTransactionDeposit(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers = {
  transaction: serializeTransaction2
};
function serializeTransactionDeposit(transaction) {
  assertTransactionDeposit(transaction);
  const { sourceHash, data, from: from23, gas, isSystemTx, mint, to: to2, value } = transaction;
  const serializedTransaction = [
    sourceHash,
    from23,
    to2 ?? "0x",
    mint ? toHex6(mint) : "0x",
    value ? toHex6(value) : "0x",
    gas ? toHex6(gas) : "0x",
    isSystemTx ? "0x1" : "0x",
    data ?? "0x"
  ];
  return concatHex([
    "0x7e",
    toRlp(serializedTransaction)
  ]);
}
function isDeposit(transaction) {
  if (transaction.type === "deposit")
    return true;
  if (typeof transaction.sourceHash !== "undefined")
    return true;
  return false;
}
function assertTransactionDeposit(transaction) {
  const { from: from23, to: to2 } = transaction;
  if (from23 && !isAddress2(from23))
    throw new InvalidAddressError({ address: from23 });
  if (to2 && !isAddress2(to2))
    throw new InvalidAddressError({ address: to2 });
}
var chainConfig = {
  blockTime: 2e3,
  contracts,
  formatters,
  serializers
};
var arbitrum = defineChain({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockTime: 250,
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});
var arbitrumSepolia = defineChain({
  id: 421614,
  name: "Arbitrum Sepolia",
  blockTime: 250,
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: true
});
var sourceId = 1;
var base = defineChain({
  ...chainConfig,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [sourceId]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [sourceId]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [sourceId]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId
});
var basePreconf = defineChain({
  ...base,
  experimental_preconfirmationTime: 200,
  rpcUrls: {
    default: {
      http: ["https://mainnet-preconf.base.org"]
    }
  }
});
var sourceId2 = 11155111;
var baseSepolia = defineChain({
  ...chainConfig,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId2]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [sourceId2]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [sourceId2]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [sourceId2]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: true,
  sourceId: sourceId2
});
var baseSepoliaPreconf = defineChain({
  ...baseSepolia,
  experimental_preconfirmationTime: 200,
  rpcUrls: {
    default: {
      http: ["https://sepolia-preconf.base.org"]
    }
  }
});
var mainnet2 = defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
var sourceId3 = 1;
var optimism = defineChain({
  ...chainConfig,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId3]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [sourceId3]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [sourceId3]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [sourceId3]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: sourceId3
});
var sourceId4 = 11155111;
var optimismSepolia = defineChain({
  ...chainConfig,
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId4]: {
        address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
      }
    },
    l2OutputOracle: {
      [sourceId4]: {
        address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    },
    portal: {
      [sourceId4]: {
        address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
      }
    },
    l1StandardBridge: {
      [sourceId4]: {
        address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
      }
    }
  },
  testnet: true,
  sourceId: sourceId4
});
var polygon = defineChain({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});
var polygonAmoy = defineChain({
  id: 80002,
  name: "Polygon Amoy",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-amoy.polygon.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://amoy.polygonscan.com",
      apiUrl: "https://api-amoy.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3127388
    }
  },
  testnet: true
});
var sepolia = defineChain({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: true
});
var SDK_BACKEND_URL = "https://keys.gemini.com";
var ENS_API_URL = "https://horizon-api.gemini.com/api/ens";
var SDK_VERSION = "0.2.0";
var DEFAULT_CHAIN_ID = 42161;
var MAINNET_CHAIN_IDS = {
  ARBITRUM_ONE: 42161,
  BASE: 8453,
  ETHEREUM: 1,
  OP_MAINNET: 10,
  POLYGON: 137
};
var TESTNET_CHAIN_IDS = {
  ARBITRUM_SEPOLIA: 421614,
  BASE_SEPOLIA: 84532,
  OP_SEPOLIA: 11155420,
  POLYGON_AMOY: 80002,
  SEPOLIA: 11155111
};
var SUPPORTED_CHAIN_IDS = [
  ...Object.values(MAINNET_CHAIN_IDS),
  ...Object.values(TESTNET_CHAIN_IDS)
];
function getDefaultRpcUrl(chainId) {
  const chainMap = {
    [mainnet2.id]: mainnet2.rpcUrls.default.http[0],
    [arbitrum.id]: arbitrum.rpcUrls.default.http[0],
    [optimism.id]: optimism.rpcUrls.default.http[0],
    [base.id]: base.rpcUrls.default.http[0],
    [polygon.id]: polygon.rpcUrls.default.http[0],
    [sepolia.id]: sepolia.rpcUrls.default.http[0],
    [arbitrumSepolia.id]: arbitrumSepolia.rpcUrls.default.http[0],
    [optimismSepolia.id]: optimismSepolia.rpcUrls.default.http[0],
    [baseSepolia.id]: baseSepolia.rpcUrls.default.http[0],
    [polygonAmoy.id]: polygonAmoy.rpcUrls.default.http[0]
  };
  return chainMap[chainId];
}
var POPUP_WIDTH = 420;
var POPUP_HEIGHT = 650;
async function reverseResolveEns(address) {
  try {
    const response = await fetch(`${ENS_API_URL}/reverse/${address}`);
    if (!response.ok) {
      throw new Error(`ENS API request failed: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    return {
      address: data.address,
      name: data.name || null
    };
  } catch (error) {
    console.error("Failed to resolve ENS name:", error);
    return {
      address,
      name: null
    };
  }
}
var openPopup = (url) => {
  const left = (window.innerWidth - POPUP_WIDTH) / 2 + window.screenX;
  const top = (window.innerHeight - POPUP_HEIGHT) / 2 + window.screenY;
  const popupId = `gemini_wallet_${crypto.randomUUID()}`;
  const popup = window.open(url, popupId, `width=${POPUP_WIDTH}, height=${POPUP_HEIGHT}, left=${left}, top=${top}`);
  popup == null ? void 0 : popup.focus();
  if (!popup) {
    throw rpcErrors.internal("Pop up window failed to open");
  }
  return popup;
};
var closePopup = (popup) => {
  if (popup && !popup.closed) {
    popup.close();
  }
};
var hexStringFromNumber = (num) => `0x${BigInt(num).toString(16)}`;
var safeJsonStringify = (obj) => JSON.stringify(obj, (_, value) => typeof value === "bigint" ? value.toString() + "n" : value, 2);
var Communicator = class {
  constructor({ appMetadata, onDisconnectCallback }) {
    __publicField(this, "appMetadata");
    __publicField(this, "url");
    __publicField(this, "popup", null);
    __publicField(this, "listeners", /* @__PURE__ */ new Map());
    __publicField(this, "onDisconnectCallback");
    this.url = new URL(SDK_BACKEND_URL);
    this.appMetadata = appMetadata;
    this.onDisconnectCallback = onDisconnectCallback;
  }
  async postMessage(message) {
    const popup = await this.waitForPopupLoaded();
    popup.postMessage(message, this.url.origin);
  }
  async postRequestAndWaitForResponse(request) {
    const responsePromise = this.onMessage(({ requestId }) => requestId === request.requestId);
    await this.postMessage(request);
    return responsePromise;
  }
  async onMessage(predicate) {
    return new Promise((resolve, reject) => {
      const listener = (event) => {
        if (event.origin !== this.url.origin)
          return;
        const message = event.data;
        if (predicate(message)) {
          resolve(message);
          window.removeEventListener("message", listener);
          this.listeners.delete(listener);
        }
      };
      window.addEventListener("message", listener);
      this.listeners.set(listener, { reject });
    });
  }
  onRequestCancelled() {
    closePopup(this.popup ?? void 0);
    this.popup = null;
    this.listeners.forEach(({ reject }, listener) => {
      reject(providerErrors.userRejectedRequest());
      window.removeEventListener("message", listener);
    });
    this.listeners.clear();
  }
  async waitForPopupLoaded() {
    if (this.popup && !this.popup.closed) {
      this.popup.focus();
      return this.popup;
    }
    this.popup = openPopup(this.url);
    this.onMessage(
      ({ event }) => event === "POPUP_UNLOADED"
      /* POPUP_UNLOADED */
    ).then(() => this.onRequestCancelled()).catch(() => {
    });
    this.onMessage(
      ({ event }) => event === "SDK_DISCONNECT"
      /* SDK_DISCONNECT */
    ).then(() => {
      var _a;
      (_a = this.onDisconnectCallback) == null ? void 0 : _a.call(this);
      this.onRequestCancelled();
    }).catch(() => {
    });
    return this.onMessage(
      ({ event }) => event === "POPUP_LOADED"
      /* POPUP_LOADED */
    ).then((message) => {
      this.postMessage({
        chainId: DEFAULT_CHAIN_ID,
        data: {
          appMetadata: this.appMetadata,
          origin: window.location.origin,
          sdkVersion: SDK_VERSION
        },
        event: "POPUP_APP_CONTEXT",
        origin: window.location.origin,
        requestId: message.requestId
      });
      return message;
    }).then(() => {
      if (!this.popup)
        throw rpcErrors.internal();
      return this.popup;
    });
  }
};
var STORAGE_ETH_ACCOUNTS_KEY = "eth-accounts";
var STORAGE_ETH_ACTIVE_CHAIN_KEY = "eth-active-chain";
var memoryStorage = {};
var GeminiStorage = class {
  constructor() {
    __publicField(this, "scope", "@gemini");
    __publicField(this, "module", "wallet");
  }
  scopedKey(key) {
    return `${this.scope}.${this.module}.${key}`;
  }
  async storeObject(key, item) {
    const json = safeJsonStringify(item);
    await this.setItem(key, json);
  }
  async loadObject(key, fallback) {
    const item = await this.getItem(key);
    if (!item) {
      await this.storeObject(key, fallback);
      return fallback;
    }
    try {
      return JSON.parse(item);
    } catch (error) {
      console.error(`Error parsing JSON for key ${key}:`, error);
      return fallback;
    }
  }
  setItem(key, value) {
    const scoped = this.scopedKey(key);
    try {
      localStorage.setItem(scoped, value);
    } catch {
      memoryStorage[scoped] = value;
    }
    return Promise.resolve();
  }
  getItem(key) {
    const scoped = this.scopedKey(key);
    try {
      return Promise.resolve(localStorage.getItem(scoped) ?? void 0);
    } catch {
      return Promise.resolve(memoryStorage[scoped] || void 0);
    }
  }
  removeItem(key) {
    const scoped = this.scopedKey(key);
    try {
      localStorage.removeItem(scoped);
    } catch {
      delete memoryStorage[scoped];
    }
    return Promise.resolve();
  }
};
function isChainSupportedByGeminiSw(chainId) {
  return SUPPORTED_CHAIN_IDS.includes(chainId);
}
var GeminiWallet = class {
  constructor({
    appMetadata,
    chain,
    onDisconnectCallback,
    storage
  }) {
    __publicField(this, "communicator");
    __publicField(this, "storage");
    __publicField(this, "initPromise");
    __publicField(this, "accounts", []);
    __publicField(this, "chain", { id: DEFAULT_CHAIN_ID });
    this.communicator = new Communicator({
      appMetadata,
      onDisconnectCallback
    });
    this.storage = storage || new GeminiStorage();
    const initialChain = chain || { id: DEFAULT_CHAIN_ID };
    this.initPromise = this.initializeFromStorage(initialChain);
  }
  async initializeFromStorage(defaultChain) {
    const fallbackChain = {
      id: defaultChain.id,
      rpcUrl: defaultChain.rpcUrl || getDefaultRpcUrl(defaultChain.id)
    };
    const [storedChain, storedAccounts] = await Promise.all([
      this.storage.loadObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, fallbackChain),
      this.storage.loadObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts)
    ]);
    this.chain = {
      ...storedChain,
      rpcUrl: storedChain.rpcUrl || getDefaultRpcUrl(storedChain.id)
    };
    this.accounts = storedAccounts;
  }
  async ensureInitialized() {
    await this.initPromise;
  }
  async connect() {
    await this.ensureInitialized();
    const response = await this.sendMessageToPopup({
      chainId: this.chain.id,
      event: "SDK_CONNECT",
      origin: window.location.origin
    });
    this.accounts = [response.data.address];
    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);
    return this.accounts;
  }
  async switchChain({
    id
  }) {
    await this.ensureInitialized();
    if (isChainSupportedByGeminiSw(id)) {
      this.chain = {
        id,
        rpcUrl: getDefaultRpcUrl(id)
      };
      await this.storage.storeObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, this.chain);
      return;
    }
    const response = await this.sendMessageToPopup({
      chainId: this.chain.id,
      data: id,
      event: "SDK_SWITCH_CHAIN",
      origin: window.location.origin
    });
    return response.data.error;
  }
  async sendTransaction(txData) {
    await this.ensureInitialized();
    const response = await this.sendMessageToPopup({
      chainId: this.chain.id,
      data: txData,
      event: "SDK_SEND_TRANSACTION",
      origin: window.location.origin
    });
    return response.data;
  }
  async signData({
    message
  }) {
    await this.ensureInitialized();
    const response = await this.sendMessageToPopup({
      chainId: this.chain.id,
      data: { message },
      event: "SDK_SIGN_DATA",
      origin: window.location.origin
    });
    return response.data;
  }
  async signTypedData({
    message,
    types,
    primaryType,
    domain
  }) {
    await this.ensureInitialized();
    const response = await this.sendMessageToPopup({
      chainId: this.chain.id,
      data: {
        domain,
        message,
        primaryType,
        types
      },
      event: "SDK_SIGN_TYPED_DATA",
      origin: window.location.origin
    });
    return response.data;
  }
  async openSettings() {
    await this.ensureInitialized();
    await this.sendMessageToPopup({
      chainId: this.chain.id,
      data: {},
      event: "SDK_OPEN_SETTINGS",
      origin: window.location.origin
    });
  }
  sendMessageToPopup(request) {
    var _a;
    return this.communicator.postRequestAndWaitForResponse({
      ...request,
      requestId: (_a = window == null ? void 0 : window.crypto) == null ? void 0 : _a.randomUUID()
    });
  }
};
var fetchRpcRequest = async (request, rpcUrl) => {
  var _a;
  const requestBody = {
    ...request,
    id: (_a = window == null ? void 0 : window.crypto) == null ? void 0 : _a.randomUUID(),
    jsonrpc: "2.0"
  };
  const res = await window.fetch(rpcUrl, {
    body: JSON.stringify(requestBody),
    headers: {
      "Content-Type": "application/json"
    },
    method: "POST",
    mode: "cors"
  });
  const { result, error } = await res.json();
  if (error) {
    throw error;
  }
  return result;
};
function validateRpcRequestArgs(args) {
  if (!args || typeof args !== "object" || Array.isArray(args)) {
    throw rpcErrors.invalidParams({
      message: "Expected a single, non-array, object argument."
    });
  }
  const { method, params } = args;
  if (typeof method !== "string" || method.length === 0) {
    throw rpcErrors.invalidParams({
      message: "'args.method' must be a non-empty string."
    });
  }
  if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
    throw rpcErrors.invalidParams({
      message: "'args.params' must be an object or array if provided."
    });
  }
}
function convertSendValuesToBigInt(tx) {
  const FIELDS_TO_NORMALIZE = ["value", "gas", "gasPrice", "maxPriorityFeePerGas", "maxFeePerGas"];
  const normalized = { ...tx };
  for (const field of FIELDS_TO_NORMALIZE) {
    if (!(field in tx)) {
      continue;
    }
    const value = tx[field];
    if (typeof value === "bigint") {
      continue;
    }
    if (isHex(value)) {
      normalized[field] = BigInt(value);
    }
  }
  return normalized;
}
var GeminiWalletProvider = class extends ProviderEventEmitter {
  constructor(providerConfig) {
    super();
    __publicField(this, "config");
    __publicField(this, "wallet");
    this.config = providerConfig;
    const userDisconnectCallback = providerConfig.onDisconnectCallback;
    this.wallet = new GeminiWallet({
      ...providerConfig,
      onDisconnectCallback: () => {
        userDisconnectCallback == null ? void 0 : userDisconnectCallback();
        this.disconnect();
      }
    });
  }
  async request(args) {
    var _a, _b, _c;
    try {
      validateRpcRequestArgs(args);
      if (!((_b = (_a = this.wallet) == null ? void 0 : _a.accounts) == null ? void 0 : _b.length)) {
        switch (args.method) {
          case "eth_requestAccounts": {
            if (!this.wallet) {
              const userDisconnectCallback = this.config.onDisconnectCallback;
              this.wallet = new GeminiWallet({
                ...this.config,
                onDisconnectCallback: () => {
                  userDisconnectCallback == null ? void 0 : userDisconnectCallback();
                  this.disconnect();
                }
              });
            }
            await this.wallet.connect();
            this.emit("accountsChanged", this.wallet.accounts);
            break;
          }
          case "net_version":
            return DEFAULT_CHAIN_ID;
          case "eth_chainId":
            return hexStringFromNumber(DEFAULT_CHAIN_ID);
          default: {
            throw providerErrors.unauthorized();
          }
        }
      }
      let response;
      let requestParams;
      switch (args.method) {
        case "eth_requestAccounts":
        case "eth_accounts":
          response = this.wallet.accounts;
          break;
        case "net_version":
          response = this.wallet.chain.id;
          break;
        case "eth_chainId":
          response = hexStringFromNumber(this.wallet.chain.id);
          break;
        case "personal_sign":
        case "wallet_sign":
          requestParams = args.params;
          response = await this.wallet.signData({
            account: requestParams[1],
            message: requestParams[0]
          });
          if (response.error) {
            throw rpcErrors.transactionRejected(response.error);
          } else {
            response = response.hash;
          }
          break;
        case "eth_sendTransaction":
        case "wallet_sendTransaction":
          requestParams = args.params;
          requestParams = convertSendValuesToBigInt(requestParams[0]);
          response = await this.wallet.sendTransaction(requestParams);
          if (response.error) {
            throw rpcErrors.transactionRejected(response.error);
          } else {
            response = response.hash;
          }
          break;
        case "wallet_switchEthereumChain": {
          const rawParams = args.params;
          let chainId;
          if (Array.isArray(rawParams) && ((_c = rawParams[0]) == null ? void 0 : _c.chainId)) {
            chainId = parseInt(rawParams[0].chainId, 16);
          } else if (rawParams && typeof rawParams === "object" && "id" in rawParams && Number.isInteger(rawParams.id)) {
            chainId = rawParams.id;
          } else {
            throw rpcErrors.invalidParams("Invalid chain id argument. Expected [{ chainId: hex_string }] or { id: number }.");
          }
          response = await this.wallet.switchChain({ id: chainId });
          if (response) {
            throw providerErrors.custom({ code: 4902, message: response });
          }
          await this.emit("chainChanged", hexStringFromNumber(chainId));
          break;
        }
        case "eth_signTypedData_v1":
        case "eth_signTypedData_v2":
        case "eth_signTypedData_v3":
        case "eth_signTypedData_v4":
        case "eth_signTypedData": {
          requestParams = args.params;
          const signedTypedDataParams = JSON.parse(requestParams[1]);
          response = await this.wallet.signTypedData({
            account: requestParams[0],
            domain: signedTypedDataParams.domain,
            message: signedTypedDataParams.message,
            primaryType: signedTypedDataParams.primaryType,
            types: signedTypedDataParams.types
          });
          if (response.error) {
            throw rpcErrors.transactionRejected(response.error);
          } else {
            response = response.hash;
          }
          break;
        }
        case "eth_ecRecover":
        case "eth_subscribe":
        case "eth_unsubscribe":
        case "personal_ecRecover":
        case "eth_signTransaction":
        case "wallet_watchAsset":
        case "wallet_sendCalls":
        case "wallet_getCallsStatus":
        case "wallet_getCapabilities":
        case "wallet_showCallsStatus":
        case "wallet_grantPermissions":
          throw rpcErrors.methodNotSupported("Not yet implemented.");
        case "eth_sign":
        case "eth_coinbase":
        case "wallet_addEthereumChain":
          throw rpcErrors.methodNotSupported();
        default:
          if (!this.wallet.chain.rpcUrl) {
            throw rpcErrors.internal(`RPC URL missing for current chain (${this.wallet.chain.id})`);
          }
          return fetchRpcRequest(args, this.wallet.chain.rpcUrl);
      }
      return response;
    } catch (error) {
      const { code } = error;
      if (code === errorCodes.provider.unauthorized) {
        this.disconnect();
      }
      return Promise.reject(serializeError(error));
    }
  }
  async openSettings() {
    var _a;
    await ((_a = this.wallet) == null ? void 0 : _a.openSettings());
  }
  async reverseResolveEns(address) {
    return await reverseResolveEns(address);
  }
  async disconnect() {
    if (this.wallet) {
      const storage = this.config.storage || new GeminiStorage();
      await storage.removeItem(STORAGE_ETH_ACCOUNTS_KEY);
      await storage.removeItem(STORAGE_ETH_ACTIVE_CHAIN_KEY);
    }
    this.wallet = void 0;
    await this.emit("disconnect", "User initiated disconnection");
  }
};

// node_modules/@wagmi/connectors/dist/esm/gemini.js
gemini.type = "gemini";
function gemini(parameters = {}) {
  let walletProvider;
  let onAccountsChanged;
  let onChainChanged;
  let onDisconnect;
  return createConnector((config) => ({
    id: "gemini",
    name: "Gemini Wallet",
    type: gemini.type,
    icon: "https://keys.gemini.com/images/gemini-wallet-logo.svg",
    async connect({ chainId, withCapabilities } = {}) {
      try {
        const provider = await this.getProvider();
        const accounts = await provider.request({
          method: "eth_requestAccounts"
        });
        if (!onAccountsChanged) {
          onAccountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", onAccountsChanged);
        }
        if (!onChainChanged) {
          onChainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", onChainChanged);
        }
        if (!onDisconnect) {
          onDisconnect = this.onDisconnect.bind(this);
          provider.on("disconnect", onDisconnect);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        return {
          // TODO(v3): Make `withCapabilities: true` default behavior
          accounts: withCapabilities ? accounts.map((address) => ({ address, capabilities: {} })) : accounts,
          chainId: currentChainId
        };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (onAccountsChanged) {
        provider.removeListener("accountsChanged", onAccountsChanged);
        onAccountsChanged = void 0;
      }
      if (onChainChanged) {
        provider.removeListener("chainChanged", onChainChanged);
        onChainChanged = void 0;
      }
      if (onDisconnect) {
        provider.removeListener("disconnect", onDisconnect);
        onDisconnect = void 0;
      }
      await provider.disconnect();
    },
    async getAccounts() {
      const provider = await this.getProvider();
      const accounts = await provider.request({
        method: "eth_accounts"
      });
      return accounts.map((x) => getAddress(x));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      var _a, _b, _c, _d;
      if (!walletProvider) {
        walletProvider = new GeminiWalletProvider({
          appMetadata: parameters.appMetadata ?? {},
          chain: {
            id: ((_a = config.chains[0]) == null ? void 0 : _a.id) ?? 1,
            rpcUrl: (_d = (_c = (_b = config.chains[0]) == null ? void 0 : _b.rpcUrls) == null ? void 0 : _c.default) == null ? void 0 : _d.http[0]
          }
        });
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return Boolean(accounts.length);
      } catch {
        return false;
      }
    },
    async switchChain({ chainId }) {
      const chain = config.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chainId) }]
        });
        return chain;
      } catch (error) {
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect() {
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (onAccountsChanged) {
        provider.removeListener("accountsChanged", onAccountsChanged);
        onAccountsChanged = void 0;
      }
      if (onChainChanged) {
        provider.removeListener("chainChanged", onChainChanged);
        onChainChanged = void 0;
      }
      if (onDisconnect) {
        provider.removeListener("disconnect", onDisconnect);
        onDisconnect = void 0;
      }
    }
  }));
}

// node_modules/@wagmi/connectors/dist/esm/metaMask.js
metaMask.type = "metaMask";
function metaMask(parameters = {}) {
  let sdk;
  let provider;
  let providerPromise;
  let accountsChanged;
  let chainChanged;
  let connect;
  let displayUri;
  let disconnect;
  return createConnector((config) => ({
    id: "metaMaskSDK",
    name: "MetaMask",
    rdns: ["io.metamask", "io.metamask.mobile"],
    type: metaMask.type,
    async setup() {
      const provider2 = await this.getProvider();
      if (provider2 == null ? void 0 : provider2.on) {
        if (!connect) {
          connect = this.onConnect.bind(this);
          provider2.on("connect", connect);
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
      }
    },
    async connect({ chainId, isReconnecting, withCapabilities } = {}) {
      const provider2 = await this.getProvider();
      if (!displayUri) {
        displayUri = this.onDisplayUri;
        provider2.on("display_uri", displayUri);
      }
      let accounts = [];
      if (isReconnecting)
        accounts = await this.getAccounts().catch(() => []);
      try {
        let signResponse;
        let connectWithResponse;
        if (!(accounts == null ? void 0 : accounts.length)) {
          if (parameters.connectAndSign || parameters.connectWith) {
            if (parameters.connectAndSign)
              signResponse = await sdk.connectAndSign({
                msg: parameters.connectAndSign
              });
            else if (parameters.connectWith)
              connectWithResponse = await sdk.connectWith({
                method: parameters.connectWith.method,
                params: parameters.connectWith.params
              });
            accounts = await this.getAccounts();
          } else {
            const requestedAccounts = await sdk.connect();
            accounts = requestedAccounts.map((x) => getAddress(x));
          }
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        if (displayUri) {
          provider2.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (signResponse)
          provider2.emit("connectAndSign", {
            accounts,
            chainId: currentChainId,
            signResponse
          });
        else if (connectWithResponse)
          provider2.emit("connectWith", {
            accounts,
            chainId: currentChainId,
            connectWithResponse
          });
        if (connect) {
          provider2.removeListener("connect", connect);
          connect = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect);
        }
        return {
          // TODO(v3): Make `withCapabilities: true` default behavior
          accounts: withCapabilities ? accounts.map((address) => ({ address, capabilities: {} })) : accounts,
          chainId: currentChainId
        };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider2 = await this.getProvider();
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider2.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
      if (!connect) {
        connect = this.onConnect.bind(this);
        provider2.on("connect", connect);
      }
      await sdk.terminate();
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      const accounts = await provider2.request({
        method: "eth_accounts"
      });
      return accounts.map((x) => getAddress(x));
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      const chainId = provider2.getChainId() || await (provider2 == null ? void 0 : provider2.request({ method: "eth_chainId" }));
      return Number(chainId);
    },
    async getProvider() {
      async function initProvider() {
        var _a, _b, _c, _d, _e;
        const MetaMaskSDK = await (async () => {
          const { default: SDK } = await import("./metamask-sdk-JZOARQGG.js");
          if (typeof SDK !== "function" && typeof SDK.default === "function")
            return SDK.default;
          return SDK;
        })();
        const readonlyRPCMap = {};
        for (const chain of config.chains)
          readonlyRPCMap[numberToHex(chain.id)] = (_a = extractRpcUrls({
            chain,
            transports: config.transports
          })) == null ? void 0 : _a[0];
        sdk = new MetaMaskSDK({
          _source: "wagmi",
          forceDeleteProvider: false,
          forceInjectProvider: false,
          injectProvider: false,
          // Workaround cast since MetaMask SDK does not support `'exactOptionalPropertyTypes'`
          ...parameters,
          readonlyRPCMap,
          dappMetadata: {
            ...parameters.dappMetadata,
            // Test if name and url are set AND not empty
            name: ((_b = parameters.dappMetadata) == null ? void 0 : _b.name) ? (_c = parameters.dappMetadata) == null ? void 0 : _c.name : "wagmi",
            url: ((_d = parameters.dappMetadata) == null ? void 0 : _d.url) ? (_e = parameters.dappMetadata) == null ? void 0 : _e.url : typeof window !== "undefined" ? window.location.origin : "https://wagmi.sh"
          },
          useDeeplink: parameters.useDeeplink ?? true
        });
        const result = await sdk.init();
        const provider2 = (() => {
          if (result == null ? void 0 : result.activeProvider)
            return result.activeProvider;
          return sdk.getProvider();
        })();
        if (!provider2)
          throw new ProviderNotFoundError();
        return provider2;
      }
      if (!provider) {
        if (!providerPromise)
          providerPromise = initProvider();
        provider = await providerPromise;
      }
      return provider;
    },
    async isAuthorized() {
      try {
        const timeout = 200;
        const accounts = await withRetry(() => withTimeout(() => this.getAccounts(), { timeout }), {
          delay: timeout + 1,
          retryCount: 3
        });
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a, _b;
      const provider2 = await this.getProvider();
      const chain = config.chains.find((x) => x.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        await provider2.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chainId) }]
        });
        await waitForChainIdToSync();
        await sendAndWaitForChangeEvent(chainId);
        return chain;
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((_b = (_a = error == null ? void 0 : error.data) == null ? void 0 : _a.originalError) == null ? void 0 : _b.code) === 4902) {
          try {
            await provider2.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  blockExplorerUrls: (() => {
                    const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
                    if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
                      return addEthereumChainParameter.blockExplorerUrls;
                    if (blockExplorer)
                      return [
                        blockExplorer.url,
                        ...Object.values(blockExplorers).map((x) => x.url)
                      ];
                    return;
                  })(),
                  chainId: numberToHex(chainId),
                  chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
                  iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
                  nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
                  rpcUrls: (() => {
                    var _a2, _b2;
                    if ((_a2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _a2.length)
                      return addEthereumChainParameter.rpcUrls;
                    return [((_b2 = chain.rpcUrls.default) == null ? void 0 : _b2.http[0]) ?? ""];
                  })()
                }
              ]
            });
            await waitForChainIdToSync();
            await sendAndWaitForChangeEvent(chainId);
            return chain;
          } catch (err2) {
            const error2 = err2;
            if (error2.code === UserRejectedRequestError.code)
              throw new UserRejectedRequestError(error2);
            throw new SwitchChainError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
      async function waitForChainIdToSync() {
        await withRetry(async () => {
          const value = hexToNumber(
            // `'eth_chainId'` is cached by the MetaMask SDK side to avoid unnecessary deeplinks
            await provider2.request({ method: "eth_chainId" })
          );
          if (value !== chainId)
            throw new Error("User rejected switch after adding network.");
          return value;
        }, {
          delay: 50,
          retryCount: 20
          // android device encryption is slower
        });
      }
      async function sendAndWaitForChangeEvent(chainId2) {
        await new Promise((resolve) => {
          const listener = (data) => {
            if ("chainId" in data && data.chainId === chainId2) {
              config.emitter.off("change", listener);
              resolve();
            }
          };
          config.emitter.on("change", listener);
          config.emitter.emit("change", { chainId: chainId2 });
        });
      }
    },
    async onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        if (sdk.isExtensionActive())
          this.onDisconnect();
        else
          return;
      } else if (config.emitter.listenerCount("connect")) {
        const chainId = (await this.getChainId()).toString();
        this.onConnect({ chainId });
      } else
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const accounts = await this.getAccounts();
      if (accounts.length === 0)
        return;
      const chainId = Number(connectInfo.chainId);
      config.emitter.emit("connect", { accounts, chainId });
      const provider2 = await this.getProvider();
      if (connect) {
        provider2.removeListener("connect", connect);
        connect = void 0;
      }
      if (!accountsChanged) {
        accountsChanged = this.onAccountsChanged.bind(this);
        provider2.on("accountsChanged", accountsChanged);
      }
      if (!chainChanged) {
        chainChanged = this.onChainChanged.bind(this);
        provider2.on("chainChanged", chainChanged);
      }
      if (!disconnect) {
        disconnect = this.onDisconnect.bind(this);
        provider2.on("disconnect", disconnect);
      }
    },
    async onDisconnect(error) {
      const provider2 = await this.getProvider();
      if (error && error.code === 1013) {
        if (provider2 && !!(await this.getAccounts()).length)
          return;
      }
      config.emitter.emit("disconnect");
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider2.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
      if (!connect) {
        connect = this.onConnect.bind(this);
        provider2.on("connect", connect);
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit("message", { type: "display_uri", data: uri });
    }
  }));
}

// node_modules/porto/_dist/trusted-hosts.js
var trusted_hosts_exports = {};
__export(trusted_hosts_exports, {
  hostnames: () => hostnames
});
var hostnames = [
  "anvil.localhost",
  "app.ens.domains",
  "app.uniswap.org",
  "bluestake.vercel.app",
  "bungee.exchange",
  "cartel.sh",
  "cctp.exchange",
  "cut-v2.mattlovan.dev",
  "daimo.ngrok.app",
  "eco.com",
  "happypath.enso.build",
  "id.porto.sh",
  "jumper.exchange",
  "localhost",
  "paper.ink",
  "pay.daimo.com",
  "playground.li.fi",
  "playground.porto.sh",
  "portal.eco.com",
  "porto.sh",
  "preview.porto.sh",
  "rath.fi",
  "relay.link",
  "sponsor-porto.vercel.app",
  "stg.localhost",
  "swap.defillama.com",
  "uniswap.org",
  "www.bungee.exchange"
];

// node_modules/@wagmi/connectors/dist/esm/safe.js
safe.type = "safe";
function safe(parameters = {}) {
  const { shimDisconnect = false } = parameters;
  let provider_;
  let disconnect;
  return createConnector((config) => ({
    id: "safe",
    name: "Safe",
    type: safe.type,
    async connect({ withCapabilities } = {}) {
      var _a;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const accounts = await this.getAccounts();
      const chainId = await this.getChainId();
      if (!disconnect) {
        disconnect = this.onDisconnect.bind(this);
        provider.on("disconnect", disconnect);
      }
      if (shimDisconnect)
        await ((_a = config.storage) == null ? void 0 : _a.removeItem("safe.disconnected"));
      return {
        // TODO(v3): Make `withCapabilities: true` default behavior
        accounts: withCapabilities ? accounts.map((address) => ({ address, capabilities: {} })) : accounts,
        chainId
      };
    },
    async disconnect() {
      var _a;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
      if (shimDisconnect)
        await ((_a = config.storage) == null ? void 0 : _a.setItem("safe.disconnected", true));
    },
    async getAccounts() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      return (await provider.request({ method: "eth_accounts" })).map(getAddress);
    },
    async getProvider() {
      const isIframe = typeof window !== "undefined" && (window == null ? void 0 : window.parent) !== window;
      if (!isIframe)
        return;
      if (!provider_) {
        const { default: SDK } = await import("./esm-5WYRFLQZ.js");
        const sdk = new SDK(parameters);
        const safe2 = await withTimeout(() => sdk.safe.getInfo(), {
          timeout: parameters.unstable_getInfoTimeout ?? 10
        });
        if (!safe2)
          throw new Error("Could not load Safe information");
        const SafeAppProvider = await (async () => {
          const Provider = await import("./dist-2IVB4U2X.js");
          if (typeof Provider.SafeAppProvider !== "function" && typeof Provider.default.SafeAppProvider === "function")
            return Provider.default.SafeAppProvider;
          return Provider.SafeAppProvider;
        })();
        provider_ = new SafeAppProvider(safe2, sdk);
      }
      return provider_;
    },
    async getChainId() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      return Number(provider.chainId);
    },
    async isAuthorized() {
      var _a;
      try {
        const isDisconnected = shimDisconnect && // If shim exists in storage, connector is disconnected
        await ((_a = config.storage) == null ? void 0 : _a.getItem("safe.disconnected"));
        if (isDisconnected)
          return false;
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    onAccountsChanged() {
    },
    onChainChanged() {
    },
    onDisconnect() {
      config.emitter.emit("disconnect");
    }
  }));
}

// node_modules/@wagmi/connectors/dist/esm/walletConnect.js
walletConnect.type = "walletConnect";
function walletConnect(parameters) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let providerPromise;
  const NAMESPACE = "eip155";
  let accountsChanged;
  let chainChanged;
  let connect;
  let displayUri;
  let sessionDelete;
  let disconnect;
  return createConnector((config) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect.type,
    async setup() {
      const provider = await this.getProvider().catch(() => null);
      if (!provider)
        return;
      if (!connect) {
        connect = this.onConnect.bind(this);
        provider.on("connect", connect);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider.on("session_delete", sessionDelete);
      }
    },
    async connect({ chainId, withCapabilities, ...rest } = {}) {
      var _a, _b;
      try {
        const provider = await this.getProvider();
        if (!provider)
          throw new ProviderNotFoundError();
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider.on("display_uri", displayUri);
        }
        let targetChainId = chainId;
        if (!targetChainId) {
          const state = await ((_a = config.storage) == null ? void 0 : _a.getItem("state")) ?? {};
          const isChainSupported = config.chains.some((x) => x.id === state.chainId);
          if (isChainSupported)
            targetChainId = state.chainId;
          else
            targetChainId = (_b = config.chains[0]) == null ? void 0 : _b.id;
        }
        if (!targetChainId)
          throw new Error("No chains found on connector.");
        const isChainsStale = await this.isChainsStale();
        if (provider.session && isChainsStale)
          await provider.disconnect();
        if (!provider.session || isChainsStale) {
          const optionalChains = config.chains.filter((chain) => chain.id !== targetChainId).map((optionalChain) => optionalChain.id);
          await provider.connect({
            optionalChains: [targetChainId, ...optionalChains],
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(config.chains.map((x) => x.id));
        }
        const accounts = (await provider.enable()).map((x) => getAddress(x));
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            var _a2;
            if (error.code === UserRejectedRequestError.code && ((_a2 = error.cause) == null ? void 0 : _a2.message) !== "Missing or invalid. request() method: wallet_addEthereumChain")
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        if (displayUri) {
          provider.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect) {
          provider.removeListener("connect", connect);
          connect = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect) {
          disconnect = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider.on("session_delete", sessionDelete);
        }
        return {
          accounts: withCapabilities ? accounts.map((address) => ({ address, capabilities: {} })) : accounts,
          chainId: currentChainId
        };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error == null ? void 0 : error.message)) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      try {
        await (provider == null ? void 0 : provider.disconnect());
      } catch (error) {
        if (!/No matching key/i.test(error.message))
          throw error;
      } finally {
        if (chainChanged) {
          provider == null ? void 0 : provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect) {
          provider == null ? void 0 : provider.removeListener("disconnect", disconnect);
          disconnect = void 0;
        }
        if (!connect) {
          connect = this.onConnect.bind(this);
          provider == null ? void 0 : provider.on("connect", connect);
        }
        if (accountsChanged) {
          provider == null ? void 0 : provider.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider == null ? void 0 : provider.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return provider.accounts.map((x) => getAddress(x));
    },
    async getProvider({ chainId } = {}) {
      var _a;
      async function initProvider() {
        const optionalChains = config.chains.map((x) => x.id);
        if (!optionalChains.length)
          return;
        const { EthereumProvider } = await import("./index.es-ZJDKQQYA.js");
        return await EthereumProvider.init({
          ...parameters,
          disableProviderPing: true,
          optionalChains,
          projectId: parameters.projectId,
          rpcMap: Object.fromEntries(config.chains.map((chain) => {
            const [url] = extractRpcUrls({
              chain,
              transports: config.transports
            });
            return [chain.id, url];
          })),
          showQrModal: parameters.showQrModal ?? true
        });
      }
      if (!provider_) {
        if (!providerPromise)
          providerPromise = initProvider();
        provider_ = await providerPromise;
        provider_ == null ? void 0 : provider_.events.setMaxListeners(Number.POSITIVE_INFINITY);
      }
      if (chainId)
        await ((_a = this.switchChain) == null ? void 0 : _a.call(this, { chainId }));
      return provider_;
    },
    async getChainId() {
      const provider = await this.getProvider();
      return provider.chainId;
    },
    async isAuthorized() {
      try {
        const [accounts, provider] = await Promise.all([
          this.getAccounts(),
          this.getProvider()
        ]);
        if (!accounts.length)
          return false;
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider.session) {
          await provider.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a, _b, _c;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const chain = config.chains.find((x) => x.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        await Promise.all([
          new Promise((resolve) => {
            const listener = ({ chainId: currentChainId }) => {
              if (currentChainId === chainId) {
                config.emitter.off("change", listener);
                resolve();
              }
            };
            config.emitter.on("change", listener);
          }),
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          })
        ]);
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return chain;
      } catch (err) {
        const error = err;
        if (/(user rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          else
            blockExplorerUrls = ((_a = chain.blockExplorers) == null ? void 0 : _a.default.url) ? [(_b = chain.blockExplorers) == null ? void 0 : _b.default.url] : [];
          let rpcUrls;
          if ((_c = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c.length)
            rpcUrls = addEthereumChainParameter.rpcUrls;
          else
            rpcUrls = [...chain.rpcUrls.default.http];
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
            iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
            nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
            rpcUrls
          };
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return chain;
        } catch (error2) {
          throw new UserRejectedRequestError(error2);
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const chainId = Number(connectInfo.chainId);
      const accounts = await this.getAccounts();
      config.emitter.emit("connect", { accounts, chainId });
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([]);
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
      if (sessionDelete) {
        provider.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect) {
        connect = this.onConnect.bind(this);
        provider.on("connect", connect);
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var _a, _b, _c;
      if (!provider_)
        return [];
      const chainIds = (_c = (_b = (_a = provider_.session) == null ? void 0 : _a.namespaces[NAMESPACE]) == null ? void 0 : _b.accounts) == null ? void 0 : _c.map((account) => Number.parseInt(account.split(":")[1] || "", 10));
      return chainIds ?? [];
    },
    async getRequestedChainsIds() {
      var _a;
      return await ((_a = config.storage) == null ? void 0 : _a.getItem(this.requestedChainsStorageKey)) ?? [];
    },
    /**
     * Checks if the target chains match the chains that were
     * initially requested by the connector for the WalletConnect session.
     * If there is a mismatch, this means that the chains on the connector
     * are considered stale, and need to be revalidated at a later point (via
     * connection).
     *
     * There may be a scenario where a dapp adds a chain to the
     * connector later on, however, this chain will not have been approved or rejected
     * by the wallet. In this case, the chain is considered stale.
     */
    async isChainsStale() {
      if (!isNewChainsStale)
        return false;
      const connectorChains = config.chains.map((x) => x.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id) => connectorChains.includes(id)))
        return false;
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id) => requestedChains.includes(id));
    },
    async setRequestedChainsIds(chains) {
      var _a;
      await ((_a = config.storage) == null ? void 0 : _a.setItem(this.requestedChainsStorageKey, chains));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}

// node_modules/@rainbow-me/rainbowkit/dist/index.js
var import_react79 = __toESM(require_react());
var largeScreenMinWidth = 768;
var mapResponsiveValue = createMapValueFn({ conditions: { defaultCondition: "smallScreen", conditionNames: ["smallScreen", "largeScreen"], responsiveArray: void 0 } });
var normalizeResponsiveValue = createNormalizeValueFn({ conditions: { defaultCondition: "smallScreen", conditionNames: ["smallScreen", "largeScreen"], responsiveArray: void 0 } });
var sprinkles = createSprinkles2({ conditions: { defaultCondition: "base", conditionNames: ["base", "hover", "active"], responsiveArray: void 0 }, styles: { background: { values: { accentColor: { conditions: { base: "ju367v9i", hover: "ju367v9j", active: "ju367v9k" }, defaultClass: "ju367v9i" }, accentColorForeground: { conditions: { base: "ju367v9l", hover: "ju367v9m", active: "ju367v9n" }, defaultClass: "ju367v9l" }, actionButtonBorder: { conditions: { base: "ju367v9o", hover: "ju367v9p", active: "ju367v9q" }, defaultClass: "ju367v9o" }, actionButtonBorderMobile: { conditions: { base: "ju367v9r", hover: "ju367v9s", active: "ju367v9t" }, defaultClass: "ju367v9r" }, actionButtonSecondaryBackground: { conditions: { base: "ju367v9u", hover: "ju367v9v", active: "ju367v9w" }, defaultClass: "ju367v9u" }, closeButton: { conditions: { base: "ju367v9x", hover: "ju367v9y", active: "ju367v9z" }, defaultClass: "ju367v9x" }, closeButtonBackground: { conditions: { base: "ju367va0", hover: "ju367va1", active: "ju367va2" }, defaultClass: "ju367va0" }, connectButtonBackground: { conditions: { base: "ju367va3", hover: "ju367va4", active: "ju367va5" }, defaultClass: "ju367va3" }, connectButtonBackgroundError: { conditions: { base: "ju367va6", hover: "ju367va7", active: "ju367va8" }, defaultClass: "ju367va6" }, connectButtonInnerBackground: { conditions: { base: "ju367va9", hover: "ju367vaa", active: "ju367vab" }, defaultClass: "ju367va9" }, connectButtonText: { conditions: { base: "ju367vac", hover: "ju367vad", active: "ju367vae" }, defaultClass: "ju367vac" }, connectButtonTextError: { conditions: { base: "ju367vaf", hover: "ju367vag", active: "ju367vah" }, defaultClass: "ju367vaf" }, connectionIndicator: { conditions: { base: "ju367vai", hover: "ju367vaj", active: "ju367vak" }, defaultClass: "ju367vai" }, downloadBottomCardBackground: { conditions: { base: "ju367val", hover: "ju367vam", active: "ju367van" }, defaultClass: "ju367val" }, downloadTopCardBackground: { conditions: { base: "ju367vao", hover: "ju367vap", active: "ju367vaq" }, defaultClass: "ju367vao" }, error: { conditions: { base: "ju367var", hover: "ju367vas", active: "ju367vat" }, defaultClass: "ju367var" }, generalBorder: { conditions: { base: "ju367vau", hover: "ju367vav", active: "ju367vaw" }, defaultClass: "ju367vau" }, generalBorderDim: { conditions: { base: "ju367vax", hover: "ju367vay", active: "ju367vaz" }, defaultClass: "ju367vax" }, menuItemBackground: { conditions: { base: "ju367vb0", hover: "ju367vb1", active: "ju367vb2" }, defaultClass: "ju367vb0" }, modalBackdrop: { conditions: { base: "ju367vb3", hover: "ju367vb4", active: "ju367vb5" }, defaultClass: "ju367vb3" }, modalBackground: { conditions: { base: "ju367vb6", hover: "ju367vb7", active: "ju367vb8" }, defaultClass: "ju367vb6" }, modalBorder: { conditions: { base: "ju367vb9", hover: "ju367vba", active: "ju367vbb" }, defaultClass: "ju367vb9" }, modalText: { conditions: { base: "ju367vbc", hover: "ju367vbd", active: "ju367vbe" }, defaultClass: "ju367vbc" }, modalTextDim: { conditions: { base: "ju367vbf", hover: "ju367vbg", active: "ju367vbh" }, defaultClass: "ju367vbf" }, modalTextSecondary: { conditions: { base: "ju367vbi", hover: "ju367vbj", active: "ju367vbk" }, defaultClass: "ju367vbi" }, profileAction: { conditions: { base: "ju367vbl", hover: "ju367vbm", active: "ju367vbn" }, defaultClass: "ju367vbl" }, profileActionHover: { conditions: { base: "ju367vbo", hover: "ju367vbp", active: "ju367vbq" }, defaultClass: "ju367vbo" }, profileForeground: { conditions: { base: "ju367vbr", hover: "ju367vbs", active: "ju367vbt" }, defaultClass: "ju367vbr" }, selectedOptionBorder: { conditions: { base: "ju367vbu", hover: "ju367vbv", active: "ju367vbw" }, defaultClass: "ju367vbu" }, standby: { conditions: { base: "ju367vbx", hover: "ju367vby", active: "ju367vbz" }, defaultClass: "ju367vbx" } } }, borderColor: { values: { accentColor: { conditions: { base: "ju367vc0", hover: "ju367vc1", active: "ju367vc2" }, defaultClass: "ju367vc0" }, accentColorForeground: { conditions: { base: "ju367vc3", hover: "ju367vc4", active: "ju367vc5" }, defaultClass: "ju367vc3" }, actionButtonBorder: { conditions: { base: "ju367vc6", hover: "ju367vc7", active: "ju367vc8" }, defaultClass: "ju367vc6" }, actionButtonBorderMobile: { conditions: { base: "ju367vc9", hover: "ju367vca", active: "ju367vcb" }, defaultClass: "ju367vc9" }, actionButtonSecondaryBackground: { conditions: { base: "ju367vcc", hover: "ju367vcd", active: "ju367vce" }, defaultClass: "ju367vcc" }, closeButton: { conditions: { base: "ju367vcf", hover: "ju367vcg", active: "ju367vch" }, defaultClass: "ju367vcf" }, closeButtonBackground: { conditions: { base: "ju367vci", hover: "ju367vcj", active: "ju367vck" }, defaultClass: "ju367vci" }, connectButtonBackground: { conditions: { base: "ju367vcl", hover: "ju367vcm", active: "ju367vcn" }, defaultClass: "ju367vcl" }, connectButtonBackgroundError: { conditions: { base: "ju367vco", hover: "ju367vcp", active: "ju367vcq" }, defaultClass: "ju367vco" }, connectButtonInnerBackground: { conditions: { base: "ju367vcr", hover: "ju367vcs", active: "ju367vct" }, defaultClass: "ju367vcr" }, connectButtonText: { conditions: { base: "ju367vcu", hover: "ju367vcv", active: "ju367vcw" }, defaultClass: "ju367vcu" }, connectButtonTextError: { conditions: { base: "ju367vcx", hover: "ju367vcy", active: "ju367vcz" }, defaultClass: "ju367vcx" }, connectionIndicator: { conditions: { base: "ju367vd0", hover: "ju367vd1", active: "ju367vd2" }, defaultClass: "ju367vd0" }, downloadBottomCardBackground: { conditions: { base: "ju367vd3", hover: "ju367vd4", active: "ju367vd5" }, defaultClass: "ju367vd3" }, downloadTopCardBackground: { conditions: { base: "ju367vd6", hover: "ju367vd7", active: "ju367vd8" }, defaultClass: "ju367vd6" }, error: { conditions: { base: "ju367vd9", hover: "ju367vda", active: "ju367vdb" }, defaultClass: "ju367vd9" }, generalBorder: { conditions: { base: "ju367vdc", hover: "ju367vdd", active: "ju367vde" }, defaultClass: "ju367vdc" }, generalBorderDim: { conditions: { base: "ju367vdf", hover: "ju367vdg", active: "ju367vdh" }, defaultClass: "ju367vdf" }, menuItemBackground: { conditions: { base: "ju367vdi", hover: "ju367vdj", active: "ju367vdk" }, defaultClass: "ju367vdi" }, modalBackdrop: { conditions: { base: "ju367vdl", hover: "ju367vdm", active: "ju367vdn" }, defaultClass: "ju367vdl" }, modalBackground: { conditions: { base: "ju367vdo", hover: "ju367vdp", active: "ju367vdq" }, defaultClass: "ju367vdo" }, modalBorder: { conditions: { base: "ju367vdr", hover: "ju367vds", active: "ju367vdt" }, defaultClass: "ju367vdr" }, modalText: { conditions: { base: "ju367vdu", hover: "ju367vdv", active: "ju367vdw" }, defaultClass: "ju367vdu" }, modalTextDim: { conditions: { base: "ju367vdx", hover: "ju367vdy", active: "ju367vdz" }, defaultClass: "ju367vdx" }, modalTextSecondary: { conditions: { base: "ju367ve0", hover: "ju367ve1", active: "ju367ve2" }, defaultClass: "ju367ve0" }, profileAction: { conditions: { base: "ju367ve3", hover: "ju367ve4", active: "ju367ve5" }, defaultClass: "ju367ve3" }, profileActionHover: { conditions: { base: "ju367ve6", hover: "ju367ve7", active: "ju367ve8" }, defaultClass: "ju367ve6" }, profileForeground: { conditions: { base: "ju367ve9", hover: "ju367vea", active: "ju367veb" }, defaultClass: "ju367ve9" }, selectedOptionBorder: { conditions: { base: "ju367vec", hover: "ju367ved", active: "ju367vee" }, defaultClass: "ju367vec" }, standby: { conditions: { base: "ju367vef", hover: "ju367veg", active: "ju367veh" }, defaultClass: "ju367vef" } } }, boxShadow: { values: { connectButton: { conditions: { base: "ju367vei", hover: "ju367vej", active: "ju367vek" }, defaultClass: "ju367vei" }, dialog: { conditions: { base: "ju367vel", hover: "ju367vem", active: "ju367ven" }, defaultClass: "ju367vel" }, profileDetailsAction: { conditions: { base: "ju367veo", hover: "ju367vep", active: "ju367veq" }, defaultClass: "ju367veo" }, selectedOption: { conditions: { base: "ju367ver", hover: "ju367ves", active: "ju367vet" }, defaultClass: "ju367ver" }, selectedWallet: { conditions: { base: "ju367veu", hover: "ju367vev", active: "ju367vew" }, defaultClass: "ju367veu" }, walletLogo: { conditions: { base: "ju367vex", hover: "ju367vey", active: "ju367vez" }, defaultClass: "ju367vex" } } }, color: { values: { accentColor: { conditions: { base: "ju367vf0", hover: "ju367vf1", active: "ju367vf2" }, defaultClass: "ju367vf0" }, accentColorForeground: { conditions: { base: "ju367vf3", hover: "ju367vf4", active: "ju367vf5" }, defaultClass: "ju367vf3" }, actionButtonBorder: { conditions: { base: "ju367vf6", hover: "ju367vf7", active: "ju367vf8" }, defaultClass: "ju367vf6" }, actionButtonBorderMobile: { conditions: { base: "ju367vf9", hover: "ju367vfa", active: "ju367vfb" }, defaultClass: "ju367vf9" }, actionButtonSecondaryBackground: { conditions: { base: "ju367vfc", hover: "ju367vfd", active: "ju367vfe" }, defaultClass: "ju367vfc" }, closeButton: { conditions: { base: "ju367vff", hover: "ju367vfg", active: "ju367vfh" }, defaultClass: "ju367vff" }, closeButtonBackground: { conditions: { base: "ju367vfi", hover: "ju367vfj", active: "ju367vfk" }, defaultClass: "ju367vfi" }, connectButtonBackground: { conditions: { base: "ju367vfl", hover: "ju367vfm", active: "ju367vfn" }, defaultClass: "ju367vfl" }, connectButtonBackgroundError: { conditions: { base: "ju367vfo", hover: "ju367vfp", active: "ju367vfq" }, defaultClass: "ju367vfo" }, connectButtonInnerBackground: { conditions: { base: "ju367vfr", hover: "ju367vfs", active: "ju367vft" }, defaultClass: "ju367vfr" }, connectButtonText: { conditions: { base: "ju367vfu", hover: "ju367vfv", active: "ju367vfw" }, defaultClass: "ju367vfu" }, connectButtonTextError: { conditions: { base: "ju367vfx", hover: "ju367vfy", active: "ju367vfz" }, defaultClass: "ju367vfx" }, connectionIndicator: { conditions: { base: "ju367vg0", hover: "ju367vg1", active: "ju367vg2" }, defaultClass: "ju367vg0" }, downloadBottomCardBackground: { conditions: { base: "ju367vg3", hover: "ju367vg4", active: "ju367vg5" }, defaultClass: "ju367vg3" }, downloadTopCardBackground: { conditions: { base: "ju367vg6", hover: "ju367vg7", active: "ju367vg8" }, defaultClass: "ju367vg6" }, error: { conditions: { base: "ju367vg9", hover: "ju367vga", active: "ju367vgb" }, defaultClass: "ju367vg9" }, generalBorder: { conditions: { base: "ju367vgc", hover: "ju367vgd", active: "ju367vge" }, defaultClass: "ju367vgc" }, generalBorderDim: { conditions: { base: "ju367vgf", hover: "ju367vgg", active: "ju367vgh" }, defaultClass: "ju367vgf" }, menuItemBackground: { conditions: { base: "ju367vgi", hover: "ju367vgj", active: "ju367vgk" }, defaultClass: "ju367vgi" }, modalBackdrop: { conditions: { base: "ju367vgl", hover: "ju367vgm", active: "ju367vgn" }, defaultClass: "ju367vgl" }, modalBackground: { conditions: { base: "ju367vgo", hover: "ju367vgp", active: "ju367vgq" }, defaultClass: "ju367vgo" }, modalBorder: { conditions: { base: "ju367vgr", hover: "ju367vgs", active: "ju367vgt" }, defaultClass: "ju367vgr" }, modalText: { conditions: { base: "ju367vgu", hover: "ju367vgv", active: "ju367vgw" }, defaultClass: "ju367vgu" }, modalTextDim: { conditions: { base: "ju367vgx", hover: "ju367vgy", active: "ju367vgz" }, defaultClass: "ju367vgx" }, modalTextSecondary: { conditions: { base: "ju367vh0", hover: "ju367vh1", active: "ju367vh2" }, defaultClass: "ju367vh0" }, profileAction: { conditions: { base: "ju367vh3", hover: "ju367vh4", active: "ju367vh5" }, defaultClass: "ju367vh3" }, profileActionHover: { conditions: { base: "ju367vh6", hover: "ju367vh7", active: "ju367vh8" }, defaultClass: "ju367vh6" }, profileForeground: { conditions: { base: "ju367vh9", hover: "ju367vha", active: "ju367vhb" }, defaultClass: "ju367vh9" }, selectedOptionBorder: { conditions: { base: "ju367vhc", hover: "ju367vhd", active: "ju367vhe" }, defaultClass: "ju367vhc" }, standby: { conditions: { base: "ju367vhf", hover: "ju367vhg", active: "ju367vhh" }, defaultClass: "ju367vhf" } } } } }, { conditions: { defaultCondition: "smallScreen", conditionNames: ["smallScreen", "largeScreen"], responsiveArray: void 0 }, styles: { alignItems: { values: { "flex-start": { conditions: { smallScreen: "ju367v0", largeScreen: "ju367v1" }, defaultClass: "ju367v0" }, "flex-end": { conditions: { smallScreen: "ju367v2", largeScreen: "ju367v3" }, defaultClass: "ju367v2" }, center: { conditions: { smallScreen: "ju367v4", largeScreen: "ju367v5" }, defaultClass: "ju367v4" } } }, display: { values: { none: { conditions: { smallScreen: "ju367v6", largeScreen: "ju367v7" }, defaultClass: "ju367v6" }, block: { conditions: { smallScreen: "ju367v8", largeScreen: "ju367v9" }, defaultClass: "ju367v8" }, flex: { conditions: { smallScreen: "ju367va", largeScreen: "ju367vb" }, defaultClass: "ju367va" }, inline: { conditions: { smallScreen: "ju367vc", largeScreen: "ju367vd" }, defaultClass: "ju367vc" } } } } }, { conditions: void 0, styles: { margin: { mappings: ["marginTop", "marginBottom", "marginLeft", "marginRight"] }, marginX: { mappings: ["marginLeft", "marginRight"] }, marginY: { mappings: ["marginTop", "marginBottom"] }, padding: { mappings: ["paddingTop", "paddingBottom", "paddingLeft", "paddingRight"] }, paddingX: { mappings: ["paddingLeft", "paddingRight"] }, paddingY: { mappings: ["paddingTop", "paddingBottom"] }, alignSelf: { values: { "flex-start": { defaultClass: "ju367ve" }, "flex-end": { defaultClass: "ju367vf" }, center: { defaultClass: "ju367vg" } } }, backgroundSize: { values: { cover: { defaultClass: "ju367vh" } } }, borderRadius: { values: { "1": { defaultClass: "ju367vi" }, "6": { defaultClass: "ju367vj" }, "10": { defaultClass: "ju367vk" }, "13": { defaultClass: "ju367vl" }, actionButton: { defaultClass: "ju367vm" }, connectButton: { defaultClass: "ju367vn" }, menuButton: { defaultClass: "ju367vo" }, modal: { defaultClass: "ju367vp" }, modalMobile: { defaultClass: "ju367vq" }, "25%": { defaultClass: "ju367vr" }, full: { defaultClass: "ju367vs" } } }, borderStyle: { values: { solid: { defaultClass: "ju367vt" } } }, borderWidth: { values: { "0": { defaultClass: "ju367vu" }, "1": { defaultClass: "ju367vv" }, "2": { defaultClass: "ju367vw" }, "4": { defaultClass: "ju367vx" } } }, cursor: { values: { pointer: { defaultClass: "ju367vy" }, none: { defaultClass: "ju367vz" } } }, pointerEvents: { values: { none: { defaultClass: "ju367v10" }, all: { defaultClass: "ju367v11" } } }, minHeight: { values: { "8": { defaultClass: "ju367v12" }, "44": { defaultClass: "ju367v13" } } }, flexDirection: { values: { row: { defaultClass: "ju367v14" }, column: { defaultClass: "ju367v15" } } }, fontFamily: { values: { body: { defaultClass: "ju367v16" } } }, fontSize: { values: { "12": { defaultClass: "ju367v17" }, "13": { defaultClass: "ju367v18" }, "14": { defaultClass: "ju367v19" }, "16": { defaultClass: "ju367v1a" }, "18": { defaultClass: "ju367v1b" }, "20": { defaultClass: "ju367v1c" }, "23": { defaultClass: "ju367v1d" } } }, fontWeight: { values: { regular: { defaultClass: "ju367v1e" }, medium: { defaultClass: "ju367v1f" }, semibold: { defaultClass: "ju367v1g" }, bold: { defaultClass: "ju367v1h" }, heavy: { defaultClass: "ju367v1i" } } }, gap: { values: { "0": { defaultClass: "ju367v1j" }, "1": { defaultClass: "ju367v1k" }, "2": { defaultClass: "ju367v1l" }, "3": { defaultClass: "ju367v1m" }, "4": { defaultClass: "ju367v1n" }, "5": { defaultClass: "ju367v1o" }, "6": { defaultClass: "ju367v1p" }, "8": { defaultClass: "ju367v1q" }, "10": { defaultClass: "ju367v1r" }, "12": { defaultClass: "ju367v1s" }, "14": { defaultClass: "ju367v1t" }, "16": { defaultClass: "ju367v1u" }, "18": { defaultClass: "ju367v1v" }, "20": { defaultClass: "ju367v1w" }, "24": { defaultClass: "ju367v1x" }, "28": { defaultClass: "ju367v1y" }, "32": { defaultClass: "ju367v1z" }, "36": { defaultClass: "ju367v20" }, "44": { defaultClass: "ju367v21" }, "64": { defaultClass: "ju367v22" }, "-1": { defaultClass: "ju367v23" } } }, height: { values: { "1": { defaultClass: "ju367v24" }, "2": { defaultClass: "ju367v25" }, "4": { defaultClass: "ju367v26" }, "8": { defaultClass: "ju367v27" }, "12": { defaultClass: "ju367v28" }, "20": { defaultClass: "ju367v29" }, "24": { defaultClass: "ju367v2a" }, "28": { defaultClass: "ju367v2b" }, "30": { defaultClass: "ju367v2c" }, "32": { defaultClass: "ju367v2d" }, "34": { defaultClass: "ju367v2e" }, "36": { defaultClass: "ju367v2f" }, "40": { defaultClass: "ju367v2g" }, "44": { defaultClass: "ju367v2h" }, "48": { defaultClass: "ju367v2i" }, "54": { defaultClass: "ju367v2j" }, "60": { defaultClass: "ju367v2k" }, "200": { defaultClass: "ju367v2l" }, full: { defaultClass: "ju367v2m" }, max: { defaultClass: "ju367v2n" } } }, justifyContent: { values: { "flex-start": { defaultClass: "ju367v2o" }, "flex-end": { defaultClass: "ju367v2p" }, center: { defaultClass: "ju367v2q" }, "space-between": { defaultClass: "ju367v2r" }, "space-around": { defaultClass: "ju367v2s" } } }, textAlign: { values: { left: { defaultClass: "ju367v2t" }, center: { defaultClass: "ju367v2u" }, inherit: { defaultClass: "ju367v2v" } } }, marginBottom: { values: { "0": { defaultClass: "ju367v2w" }, "1": { defaultClass: "ju367v2x" }, "2": { defaultClass: "ju367v2y" }, "3": { defaultClass: "ju367v2z" }, "4": { defaultClass: "ju367v30" }, "5": { defaultClass: "ju367v31" }, "6": { defaultClass: "ju367v32" }, "8": { defaultClass: "ju367v33" }, "10": { defaultClass: "ju367v34" }, "12": { defaultClass: "ju367v35" }, "14": { defaultClass: "ju367v36" }, "16": { defaultClass: "ju367v37" }, "18": { defaultClass: "ju367v38" }, "20": { defaultClass: "ju367v39" }, "24": { defaultClass: "ju367v3a" }, "28": { defaultClass: "ju367v3b" }, "32": { defaultClass: "ju367v3c" }, "36": { defaultClass: "ju367v3d" }, "44": { defaultClass: "ju367v3e" }, "64": { defaultClass: "ju367v3f" }, "-1": { defaultClass: "ju367v3g" } } }, marginLeft: { values: { "0": { defaultClass: "ju367v3h" }, "1": { defaultClass: "ju367v3i" }, "2": { defaultClass: "ju367v3j" }, "3": { defaultClass: "ju367v3k" }, "4": { defaultClass: "ju367v3l" }, "5": { defaultClass: "ju367v3m" }, "6": { defaultClass: "ju367v3n" }, "8": { defaultClass: "ju367v3o" }, "10": { defaultClass: "ju367v3p" }, "12": { defaultClass: "ju367v3q" }, "14": { defaultClass: "ju367v3r" }, "16": { defaultClass: "ju367v3s" }, "18": { defaultClass: "ju367v3t" }, "20": { defaultClass: "ju367v3u" }, "24": { defaultClass: "ju367v3v" }, "28": { defaultClass: "ju367v3w" }, "32": { defaultClass: "ju367v3x" }, "36": { defaultClass: "ju367v3y" }, "44": { defaultClass: "ju367v3z" }, "64": { defaultClass: "ju367v40" }, "-1": { defaultClass: "ju367v41" } } }, marginRight: { values: { "0": { defaultClass: "ju367v42" }, "1": { defaultClass: "ju367v43" }, "2": { defaultClass: "ju367v44" }, "3": { defaultClass: "ju367v45" }, "4": { defaultClass: "ju367v46" }, "5": { defaultClass: "ju367v47" }, "6": { defaultClass: "ju367v48" }, "8": { defaultClass: "ju367v49" }, "10": { defaultClass: "ju367v4a" }, "12": { defaultClass: "ju367v4b" }, "14": { defaultClass: "ju367v4c" }, "16": { defaultClass: "ju367v4d" }, "18": { defaultClass: "ju367v4e" }, "20": { defaultClass: "ju367v4f" }, "24": { defaultClass: "ju367v4g" }, "28": { defaultClass: "ju367v4h" }, "32": { defaultClass: "ju367v4i" }, "36": { defaultClass: "ju367v4j" }, "44": { defaultClass: "ju367v4k" }, "64": { defaultClass: "ju367v4l" }, "-1": { defaultClass: "ju367v4m" } } }, marginTop: { values: { "0": { defaultClass: "ju367v4n" }, "1": { defaultClass: "ju367v4o" }, "2": { defaultClass: "ju367v4p" }, "3": { defaultClass: "ju367v4q" }, "4": { defaultClass: "ju367v4r" }, "5": { defaultClass: "ju367v4s" }, "6": { defaultClass: "ju367v4t" }, "8": { defaultClass: "ju367v4u" }, "10": { defaultClass: "ju367v4v" }, "12": { defaultClass: "ju367v4w" }, "14": { defaultClass: "ju367v4x" }, "16": { defaultClass: "ju367v4y" }, "18": { defaultClass: "ju367v4z" }, "20": { defaultClass: "ju367v50" }, "24": { defaultClass: "ju367v51" }, "28": { defaultClass: "ju367v52" }, "32": { defaultClass: "ju367v53" }, "36": { defaultClass: "ju367v54" }, "44": { defaultClass: "ju367v55" }, "64": { defaultClass: "ju367v56" }, "-1": { defaultClass: "ju367v57" } } }, maxWidth: { values: { "1": { defaultClass: "ju367v58" }, "2": { defaultClass: "ju367v59" }, "4": { defaultClass: "ju367v5a" }, "8": { defaultClass: "ju367v5b" }, "12": { defaultClass: "ju367v5c" }, "20": { defaultClass: "ju367v5d" }, "24": { defaultClass: "ju367v5e" }, "28": { defaultClass: "ju367v5f" }, "30": { defaultClass: "ju367v5g" }, "32": { defaultClass: "ju367v5h" }, "34": { defaultClass: "ju367v5i" }, "36": { defaultClass: "ju367v5j" }, "40": { defaultClass: "ju367v5k" }, "44": { defaultClass: "ju367v5l" }, "48": { defaultClass: "ju367v5m" }, "54": { defaultClass: "ju367v5n" }, "60": { defaultClass: "ju367v5o" }, "200": { defaultClass: "ju367v5p" }, full: { defaultClass: "ju367v5q" }, max: { defaultClass: "ju367v5r" } } }, minWidth: { values: { "1": { defaultClass: "ju367v5s" }, "2": { defaultClass: "ju367v5t" }, "4": { defaultClass: "ju367v5u" }, "8": { defaultClass: "ju367v5v" }, "12": { defaultClass: "ju367v5w" }, "20": { defaultClass: "ju367v5x" }, "24": { defaultClass: "ju367v5y" }, "28": { defaultClass: "ju367v5z" }, "30": { defaultClass: "ju367v60" }, "32": { defaultClass: "ju367v61" }, "34": { defaultClass: "ju367v62" }, "36": { defaultClass: "ju367v63" }, "40": { defaultClass: "ju367v64" }, "44": { defaultClass: "ju367v65" }, "48": { defaultClass: "ju367v66" }, "54": { defaultClass: "ju367v67" }, "60": { defaultClass: "ju367v68" }, "200": { defaultClass: "ju367v69" }, full: { defaultClass: "ju367v6a" }, max: { defaultClass: "ju367v6b" } } }, overflow: { values: { hidden: { defaultClass: "ju367v6c" } } }, paddingBottom: { values: { "0": { defaultClass: "ju367v6d" }, "1": { defaultClass: "ju367v6e" }, "2": { defaultClass: "ju367v6f" }, "3": { defaultClass: "ju367v6g" }, "4": { defaultClass: "ju367v6h" }, "5": { defaultClass: "ju367v6i" }, "6": { defaultClass: "ju367v6j" }, "8": { defaultClass: "ju367v6k" }, "10": { defaultClass: "ju367v6l" }, "12": { defaultClass: "ju367v6m" }, "14": { defaultClass: "ju367v6n" }, "16": { defaultClass: "ju367v6o" }, "18": { defaultClass: "ju367v6p" }, "20": { defaultClass: "ju367v6q" }, "24": { defaultClass: "ju367v6r" }, "28": { defaultClass: "ju367v6s" }, "32": { defaultClass: "ju367v6t" }, "36": { defaultClass: "ju367v6u" }, "44": { defaultClass: "ju367v6v" }, "64": { defaultClass: "ju367v6w" }, "-1": { defaultClass: "ju367v6x" } } }, paddingLeft: { values: { "0": { defaultClass: "ju367v6y" }, "1": { defaultClass: "ju367v6z" }, "2": { defaultClass: "ju367v70" }, "3": { defaultClass: "ju367v71" }, "4": { defaultClass: "ju367v72" }, "5": { defaultClass: "ju367v73" }, "6": { defaultClass: "ju367v74" }, "8": { defaultClass: "ju367v75" }, "10": { defaultClass: "ju367v76" }, "12": { defaultClass: "ju367v77" }, "14": { defaultClass: "ju367v78" }, "16": { defaultClass: "ju367v79" }, "18": { defaultClass: "ju367v7a" }, "20": { defaultClass: "ju367v7b" }, "24": { defaultClass: "ju367v7c" }, "28": { defaultClass: "ju367v7d" }, "32": { defaultClass: "ju367v7e" }, "36": { defaultClass: "ju367v7f" }, "44": { defaultClass: "ju367v7g" }, "64": { defaultClass: "ju367v7h" }, "-1": { defaultClass: "ju367v7i" } } }, paddingRight: { values: { "0": { defaultClass: "ju367v7j" }, "1": { defaultClass: "ju367v7k" }, "2": { defaultClass: "ju367v7l" }, "3": { defaultClass: "ju367v7m" }, "4": { defaultClass: "ju367v7n" }, "5": { defaultClass: "ju367v7o" }, "6": { defaultClass: "ju367v7p" }, "8": { defaultClass: "ju367v7q" }, "10": { defaultClass: "ju367v7r" }, "12": { defaultClass: "ju367v7s" }, "14": { defaultClass: "ju367v7t" }, "16": { defaultClass: "ju367v7u" }, "18": { defaultClass: "ju367v7v" }, "20": { defaultClass: "ju367v7w" }, "24": { defaultClass: "ju367v7x" }, "28": { defaultClass: "ju367v7y" }, "32": { defaultClass: "ju367v7z" }, "36": { defaultClass: "ju367v80" }, "44": { defaultClass: "ju367v81" }, "64": { defaultClass: "ju367v82" }, "-1": { defaultClass: "ju367v83" } } }, paddingTop: { values: { "0": { defaultClass: "ju367v84" }, "1": { defaultClass: "ju367v85" }, "2": { defaultClass: "ju367v86" }, "3": { defaultClass: "ju367v87" }, "4": { defaultClass: "ju367v88" }, "5": { defaultClass: "ju367v89" }, "6": { defaultClass: "ju367v8a" }, "8": { defaultClass: "ju367v8b" }, "10": { defaultClass: "ju367v8c" }, "12": { defaultClass: "ju367v8d" }, "14": { defaultClass: "ju367v8e" }, "16": { defaultClass: "ju367v8f" }, "18": { defaultClass: "ju367v8g" }, "20": { defaultClass: "ju367v8h" }, "24": { defaultClass: "ju367v8i" }, "28": { defaultClass: "ju367v8j" }, "32": { defaultClass: "ju367v8k" }, "36": { defaultClass: "ju367v8l" }, "44": { defaultClass: "ju367v8m" }, "64": { defaultClass: "ju367v8n" }, "-1": { defaultClass: "ju367v8o" } } }, position: { values: { absolute: { defaultClass: "ju367v8p" }, fixed: { defaultClass: "ju367v8q" }, relative: { defaultClass: "ju367v8r" } } }, WebkitUserSelect: { values: { none: { defaultClass: "ju367v8s" } } }, right: { values: { "0": { defaultClass: "ju367v8t" } } }, transition: { values: { "default": { defaultClass: "ju367v8u" }, transform: { defaultClass: "ju367v8v" } } }, userSelect: { values: { none: { defaultClass: "ju367v8w" } } }, width: { values: { "1": { defaultClass: "ju367v8x" }, "2": { defaultClass: "ju367v8y" }, "4": { defaultClass: "ju367v8z" }, "8": { defaultClass: "ju367v90" }, "12": { defaultClass: "ju367v91" }, "20": { defaultClass: "ju367v92" }, "24": { defaultClass: "ju367v93" }, "28": { defaultClass: "ju367v94" }, "30": { defaultClass: "ju367v95" }, "32": { defaultClass: "ju367v96" }, "34": { defaultClass: "ju367v97" }, "36": { defaultClass: "ju367v98" }, "40": { defaultClass: "ju367v99" }, "44": { defaultClass: "ju367v9a" }, "48": { defaultClass: "ju367v9b" }, "54": { defaultClass: "ju367v9c" }, "60": { defaultClass: "ju367v9d" }, "200": { defaultClass: "ju367v9e" }, full: { defaultClass: "ju367v9f" }, max: { defaultClass: "ju367v9g" } } }, backdropFilter: { values: { modalOverlay: { defaultClass: "ju367v9h" } } } } });
var themeVars = { colors: { accentColor: "var(--rk-colors-accentColor)", accentColorForeground: "var(--rk-colors-accentColorForeground)", actionButtonBorder: "var(--rk-colors-actionButtonBorder)", actionButtonBorderMobile: "var(--rk-colors-actionButtonBorderMobile)", actionButtonSecondaryBackground: "var(--rk-colors-actionButtonSecondaryBackground)", closeButton: "var(--rk-colors-closeButton)", closeButtonBackground: "var(--rk-colors-closeButtonBackground)", connectButtonBackground: "var(--rk-colors-connectButtonBackground)", connectButtonBackgroundError: "var(--rk-colors-connectButtonBackgroundError)", connectButtonInnerBackground: "var(--rk-colors-connectButtonInnerBackground)", connectButtonText: "var(--rk-colors-connectButtonText)", connectButtonTextError: "var(--rk-colors-connectButtonTextError)", connectionIndicator: "var(--rk-colors-connectionIndicator)", downloadBottomCardBackground: "var(--rk-colors-downloadBottomCardBackground)", downloadTopCardBackground: "var(--rk-colors-downloadTopCardBackground)", error: "var(--rk-colors-error)", generalBorder: "var(--rk-colors-generalBorder)", generalBorderDim: "var(--rk-colors-generalBorderDim)", menuItemBackground: "var(--rk-colors-menuItemBackground)", modalBackdrop: "var(--rk-colors-modalBackdrop)", modalBackground: "var(--rk-colors-modalBackground)", modalBorder: "var(--rk-colors-modalBorder)", modalText: "var(--rk-colors-modalText)", modalTextDim: "var(--rk-colors-modalTextDim)", modalTextSecondary: "var(--rk-colors-modalTextSecondary)", profileAction: "var(--rk-colors-profileAction)", profileActionHover: "var(--rk-colors-profileActionHover)", profileForeground: "var(--rk-colors-profileForeground)", selectedOptionBorder: "var(--rk-colors-selectedOptionBorder)", standby: "var(--rk-colors-standby)" }, fonts: { body: "var(--rk-fonts-body)" }, radii: { actionButton: "var(--rk-radii-actionButton)", connectButton: "var(--rk-radii-connectButton)", menuButton: "var(--rk-radii-menuButton)", modal: "var(--rk-radii-modal)", modalMobile: "var(--rk-radii-modalMobile)" }, shadows: { connectButton: "var(--rk-shadows-connectButton)", dialog: "var(--rk-shadows-dialog)", profileDetailsAction: "var(--rk-shadows-profileDetailsAction)", selectedOption: "var(--rk-shadows-selectedOption)", selectedWallet: "var(--rk-shadows-selectedWallet)", walletLogo: "var(--rk-shadows-walletLogo)" }, blurs: { modalOverlay: "var(--rk-blurs-modalOverlay)" } };
var active = { shrink: "_12cbo8i6", shrinkSm: "_12cbo8i7" };
var base2 = "_12cbo8i3 ju367v8r";
var hover = { grow: "_12cbo8i4", growLg: "_12cbo8i5" };
function touchableStyles({ active: active2, hover: hover2 }) {
  return [base2, hover2 && hover[hover2], active[active2]];
}
function createAuthenticationAdapter(adapter) {
  return adapter;
}
var AuthenticationContext = (0, import_react5.createContext)(
  null
);
function RainbowKitAuthenticationProvider({
  adapter,
  children,
  enabled = true,
  status
}) {
  const { connector } = useAccount();
  const [currentConnectorUid, setCurrentConnectorUid] = (0, import_react5.useState)();
  useAccountEffect({
    onDisconnect: () => {
      adapter.signOut();
      setCurrentConnectorUid(void 0);
    }
  });
  const handleChangedAccount = (data) => {
    if (data.accounts) {
      setCurrentConnectorUid(void 0);
      adapter.signOut();
    }
  };
  (0, import_react5.useEffect)(() => {
    var _a;
    if (typeof ((_a = connector == null ? void 0 : connector.emitter) == null ? void 0 : _a.on) === "function" && status === "authenticated") {
      setCurrentConnectorUid(connector == null ? void 0 : connector.uid);
      connector.emitter.on("change", handleChangedAccount);
      return () => {
        connector.emitter.off("change", handleChangedAccount);
      };
    }
  }, [connector == null ? void 0 : connector.emitter, status]);
  (0, import_react5.useEffect)(() => {
    var _a;
    if (currentConnectorUid && typeof ((_a = connector == null ? void 0 : connector.emitter) == null ? void 0 : _a.on) === "function" && status === "authenticated") {
      if ((connector == null ? void 0 : connector.uid) !== currentConnectorUid) {
        setCurrentConnectorUid(void 0);
        adapter.signOut();
      }
    }
  }, [connector == null ? void 0 : connector.emitter, currentConnectorUid, status]);
  return import_react5.default.createElement(
    AuthenticationContext.Provider,
    {
      value: (0, import_react5.useMemo)(
        () => enabled ? { adapter, status } : null,
        [enabled, adapter, status]
      )
    },
    children
  );
}
function useAuthenticationAdapter() {
  const { adapter } = (0, import_react5.useContext)(AuthenticationContext) ?? {};
  if (!adapter) {
    throw new Error("No authentication adapter found");
  }
  return adapter;
}
function useAuthenticationStatus() {
  const contextValue = (0, import_react5.useContext)(AuthenticationContext);
  return (contextValue == null ? void 0 : contextValue.status) ?? null;
}
function useConnectionStatus() {
  const authenticationStatus = useAuthenticationStatus();
  const { isConnected } = useAccount();
  if (!isConnected) {
    return "disconnected";
  }
  if (!authenticationStatus) {
    return "connected";
  }
  if (authenticationStatus === "loading" || authenticationStatus === "unauthenticated") {
    return authenticationStatus;
  }
  return "connected";
}
function isAndroid() {
  return typeof navigator !== "undefined" && /android/i.test(navigator.userAgent);
}
function isSmallIOS() {
  return typeof navigator !== "undefined" && /iPhone|iPod/.test(navigator.userAgent);
}
function isLargeIOS() {
  return typeof navigator !== "undefined" && (/iPad/.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
}
function isIOS() {
  return isSmallIOS() || isLargeIOS();
}
function isMobile() {
  return isAndroid() || isIOS();
}
var base22 = "iekbcc0";
var element = { a: "iekbcca", blockquote: "iekbcc2", button: "iekbcc9", input: "iekbcc8 iekbcc5 iekbcc4", mark: "iekbcc6", ol: "iekbcc1", q: "iekbcc2", select: "iekbcc7 iekbcc5 iekbcc4", table: "iekbcc3", textarea: "iekbcc5 iekbcc4", ul: "iekbcc1" };
var atoms = ({ reset, ...rest }) => {
  if (!reset) return sprinkles(rest);
  const elementReset = element[reset];
  const sprinklesClasses = sprinkles(rest);
  return clsx_default(base22, elementReset, sprinklesClasses);
};
var Box = import_react7.default.forwardRef(
  ({ as = "div", className, testId, ...props }, ref) => {
    const atomProps = {};
    const nativeProps = {};
    for (const key in props) {
      if (sprinkles.properties.has(key)) {
        atomProps[key] = props[key];
      } else {
        nativeProps[key] = props[key];
      }
    }
    const atomicClasses = atoms({
      reset: typeof as === "string" ? as : "div",
      ...atomProps
    });
    return import_react7.default.createElement(as, {
      className: clsx_default(atomicClasses, className),
      ...nativeProps,
      "data-testid": testId ? `rk-${testId.replace(/^rk-/, "")}` : void 0,
      ref
    });
  }
);
Box.displayName = "Box";
var cachedUrls = /* @__PURE__ */ new Map();
var cachedRequestPromises = /* @__PURE__ */ new Map();
async function loadAsyncImage(asyncImage) {
  const cachedRequestPromise = cachedRequestPromises.get(asyncImage);
  if (cachedRequestPromise) {
    return cachedRequestPromise;
  }
  const load = async () => asyncImage().then(async (url) => {
    cachedUrls.set(asyncImage, url);
    return url;
  });
  const requestPromise = load().catch((_err) => {
    return load().catch((_err2) => {
      cachedRequestPromises.delete(asyncImage);
    });
  });
  cachedRequestPromises.set(asyncImage, requestPromise);
  return requestPromise;
}
async function loadImages(...urls) {
  return await Promise.all(
    urls.map((url) => typeof url === "function" ? loadAsyncImage(url) : url)
  );
}
function useForceUpdate() {
  const [, forceUpdate] = (0, import_react8.useReducer)((x) => x + 1, 0);
  return forceUpdate;
}
function useAsyncImage(url) {
  const cachedUrl = typeof url === "function" ? cachedUrls.get(url) : void 0;
  const forceUpdate = useForceUpdate();
  (0, import_react8.useEffect)(() => {
    if (typeof url === "function" && !cachedUrl) {
      loadAsyncImage(url).then(forceUpdate);
    }
  }, [url, cachedUrl, forceUpdate]);
  return typeof url === "function" ? cachedUrl : url;
}
function AsyncImage({
  alt,
  background,
  borderColor,
  borderRadius,
  useAsImage,
  boxShadow,
  height,
  src: srcProp,
  width,
  testId
}) {
  const ios = isIOS();
  const src7 = useAsyncImage(srcProp);
  const isRemoteImage = src7 && /^http/.test(src7);
  const [isRemoteImageLoaded, setRemoteImageLoaded] = (0, import_react6.useReducer)(
    () => true,
    false
  );
  return import_react6.default.createElement(
    Box,
    {
      "aria-label": alt,
      borderRadius,
      boxShadow,
      height: typeof height === "string" ? height : void 0,
      overflow: "hidden",
      position: "relative",
      role: "img",
      style: {
        background,
        height: typeof height === "number" ? height : void 0,
        width: typeof width === "number" ? width : void 0
      },
      width: typeof width === "string" ? width : void 0,
      testId
    },
    import_react6.default.createElement(
      Box,
      {
        ...isRemoteImage ? (
          // biome-ignore format: design system keys
          {
            "aria-hidden": true,
            as: "img",
            onLoad: setRemoteImageLoaded,
            src: src7
          }
        ) : { "aria-hidden": true, as: "img", src: src7 },
        height: "full",
        position: "absolute",
        ...ios ? { WebkitUserSelect: "none" } : {},
        style: {
          WebkitTouchCallout: "none",
          transition: "opacity .15s linear",
          userSelect: "none",
          ...!useAsImage && isRemoteImage ? {
            opacity: isRemoteImageLoaded ? 1 : 0
          } : {}
        },
        width: "full"
      }
    ),
    borderColor ? import_react6.default.createElement(
      Box,
      {
        ...typeof borderColor === "object" && "custom" in borderColor ? { style: { borderColor: borderColor.custom } } : { borderColor },
        borderRadius,
        borderStyle: "solid",
        borderWidth: "1",
        height: "full",
        position: "relative",
        width: "full"
      }
    ) : null
  );
}
var SpinnerIconClassName = "_1luule42";
var SpinnerIconPathClassName = "_1luule43";
var useRandomId = (prefix) => (0, import_react10.useMemo)(
  () => `${prefix}_${Math.round(Math.random() * 1e9)}`,
  [prefix]
);
var SpinnerIcon = ({
  height = 21,
  width = 21
}) => {
  const id = useRandomId("spinner");
  return import_react10.default.createElement(
    "svg",
    {
      className: SpinnerIconClassName,
      fill: "none",
      height,
      viewBox: "0 0 21 21",
      width,
      xmlns: "http://www.w3.org/2000/svg"
    },
    import_react10.default.createElement("title", null, "Loading"),
    import_react10.default.createElement("clipPath", { id }, import_react10.default.createElement("path", { d: "M10.5 3C6.35786 3 3 6.35786 3 10.5C3 14.6421 6.35786 18 10.5 18C11.3284 18 12 18.6716 12 19.5C12 20.3284 11.3284 21 10.5 21C4.70101 21 0 16.299 0 10.5C0 4.70101 4.70101 0 10.5 0C16.299 0 21 4.70101 21 10.5C21 11.3284 20.3284 12 19.5 12C18.6716 12 18 11.3284 18 10.5C18 6.35786 14.6421 3 10.5 3Z" })),
    import_react10.default.createElement(
      "foreignObject",
      {
        clipPath: `url(#${id})`,
        height: "21",
        width: "21",
        x: "0",
        y: "0"
      },
      import_react10.default.createElement("div", { className: SpinnerIconPathClassName })
    )
  );
};
var colors = [
  "#FC5C54",
  "#FFD95A",
  "#E95D72",
  "#6A87C8",
  "#5FD0F3",
  "#75C06B",
  "#FFDD86",
  "#5FC6D4",
  "#FF949A",
  "#FF8024",
  "#9BA1A4",
  "#EC66FF",
  "#FF8CBC",
  "#FF9A23",
  "#C5DADB",
  "#A8CE63",
  "#71ABFF",
  "#FFE279",
  "#B6B1B6",
  "#FF6780",
  "#A575FF",
  "#4D82FF",
  "#FFB35A"
];
var avatars = [
  { color: colors[0], emoji: "🌶" },
  { color: colors[1], emoji: "🤑" },
  { color: colors[2], emoji: "🐙" },
  { color: colors[3], emoji: "🫐" },
  { color: colors[4], emoji: "🐳" },
  { color: colors[0], emoji: "🤶" },
  { color: colors[5], emoji: "🌲" },
  { color: colors[6], emoji: "🌞" },
  { color: colors[7], emoji: "🐒" },
  { color: colors[8], emoji: "🐵" },
  { color: colors[9], emoji: "🦊" },
  { color: colors[10], emoji: "🐼" },
  { color: colors[11], emoji: "🦄" },
  { color: colors[12], emoji: "🐷" },
  { color: colors[13], emoji: "🐧" },
  { color: colors[8], emoji: "🦩" },
  { color: colors[14], emoji: "👽" },
  { color: colors[0], emoji: "🎈" },
  { color: colors[8], emoji: "🍉" },
  { color: colors[1], emoji: "🎉" },
  { color: colors[15], emoji: "🐲" },
  { color: colors[16], emoji: "🌎" },
  { color: colors[17], emoji: "🍊" },
  { color: colors[18], emoji: "🐭" },
  { color: colors[19], emoji: "🍣" },
  { color: colors[1], emoji: "🐥" },
  { color: colors[20], emoji: "👾" },
  { color: colors[15], emoji: "🥦" },
  { color: colors[0], emoji: "👹" },
  { color: colors[17], emoji: "🙀" },
  { color: colors[4], emoji: "⛱" },
  { color: colors[21], emoji: "⛵️" },
  { color: colors[17], emoji: "🥳" },
  { color: colors[8], emoji: "🤯" },
  { color: colors[22], emoji: "🤠" }
];
function hashCode(text) {
  let hash8 = 0;
  if (text.length === 0) return hash8;
  for (let i = 0; i < text.length; i++) {
    const chr = text.charCodeAt(i);
    hash8 = (hash8 << 5) - hash8 + chr;
    hash8 |= 0;
  }
  return hash8;
}
function emojiAvatarForAddress(address) {
  const resolvedAddress = typeof address === "string" ? address : "";
  const avatarIndex = Math.abs(
    hashCode(resolvedAddress.toLowerCase()) % avatars.length
  );
  return avatars[avatarIndex ?? 0];
}
var EmojiAvatar = ({ address, ensImage, size: size5 }) => {
  const [loaded, setLoaded] = (0, import_react12.useState)(false);
  (0, import_react12.useEffect)(() => {
    if (ensImage) {
      const img = new Image();
      img.src = ensImage;
      img.onload = () => setLoaded(true);
    }
  }, [ensImage]);
  const { color: backgroundColor, emoji } = (0, import_react12.useMemo)(
    () => emojiAvatarForAddress(address),
    [address]
  );
  return ensImage ? loaded ? import_react12.default.createElement(
    Box,
    {
      backgroundSize: "cover",
      borderRadius: "full",
      position: "absolute",
      style: {
        backgroundImage: `url(${ensImage})`,
        backgroundPosition: "center",
        height: size5,
        width: size5
      }
    }
  ) : import_react12.default.createElement(
    Box,
    {
      alignItems: "center",
      backgroundSize: "cover",
      borderRadius: "full",
      color: "modalText",
      display: "flex",
      justifyContent: "center",
      position: "absolute",
      style: {
        height: size5,
        width: size5
      }
    },
    import_react12.default.createElement(SpinnerIcon, null)
  ) : import_react12.default.createElement(
    Box,
    {
      alignItems: "center",
      display: "flex",
      justifyContent: "center",
      overflow: "hidden",
      style: {
        ...!ensImage && { backgroundColor },
        height: size5,
        width: size5
      }
    },
    emoji
  );
};
var defaultAvatar = EmojiAvatar;
var AvatarContext = (0, import_react11.createContext)(defaultAvatar);
function Avatar({ address, imageUrl, loading, size: size5 }) {
  const AvatarComponent = (0, import_react9.useContext)(AvatarContext);
  return import_react9.default.createElement(
    Box,
    {
      "aria-hidden": true,
      borderRadius: "full",
      overflow: "hidden",
      position: "relative",
      style: {
        height: `${size5}px`,
        width: `${size5}px`
      },
      userSelect: "none"
    },
    import_react9.default.createElement(
      Box,
      {
        alignItems: "center",
        borderRadius: "full",
        display: "flex",
        justifyContent: "center",
        overflow: "hidden",
        position: "absolute",
        style: {
          fontSize: `${Math.round(size5 * 0.55)}px`,
          height: `${size5}px`,
          transform: loading ? "scale(0.72)" : void 0,
          transition: ".25s ease",
          transitionDelay: loading ? void 0 : ".1s",
          width: `${size5}px`,
          willChange: "transform"
        },
        userSelect: "none"
      },
      import_react9.default.createElement(AvatarComponent, { address, ensImage: imageUrl, size: size5 })
    ),
    loading && import_react9.default.createElement(
      Box,
      {
        color: "accentColor",
        display: "flex",
        height: "full",
        position: "absolute",
        width: "full"
      },
      import_react9.default.createElement(SpinnerIcon, { height: "100%", width: "100%" })
    )
  );
}
var DropdownIcon = () => import_react13.default.createElement("svg", { fill: "none", height: "7", width: "14", xmlns: "http://www.w3.org/2000/svg" }, import_react13.default.createElement("title", null, "Dropdown"), import_react13.default.createElement(
  "path",
  {
    d: "M12.75 1.54001L8.51647 5.0038C7.77974 5.60658 6.72026 5.60658 5.98352 5.0038L1.75 1.54001",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "2.5",
    xmlns: "http://www.w3.org/2000/svg"
  }
));
var defaultOptions = {
  defaultLocale: "en",
  locale: "en"
};
var I18n = class {
  constructor(localeTranslations) {
    this.listeners = /* @__PURE__ */ new Set();
    this.defaultLocale = defaultOptions.defaultLocale;
    this.enableFallback = false;
    this.locale = defaultOptions.locale;
    this.cachedLocales = [];
    this.translations = {};
    for (const [locale, translation] of Object.entries(localeTranslations)) {
      this.cachedLocales = [...this.cachedLocales, locale];
      this.translations = {
        ...this.translations,
        ...this.flattenTranslation(translation, locale)
      };
    }
  }
  missingMessage(key) {
    return `[missing: "${this.locale}.${key}" translation]`;
  }
  flattenTranslation(translationObject, locale) {
    const result = {};
    const flatten = (currentTranslationObj, parentKey) => {
      for (const key of Object.keys(currentTranslationObj)) {
        const newKey = `${parentKey}.${key}`;
        const currentValue = currentTranslationObj[key];
        if (typeof currentValue === "object" && currentValue !== null) {
          flatten(currentValue, newKey);
        } else {
          result[newKey] = currentValue;
        }
      }
    };
    flatten(translationObject, locale);
    return result;
  }
  translateWithReplacements(translation, replacements = {}) {
    let translatedString = translation;
    for (const placeholder in replacements) {
      const replacementValue = replacements[placeholder];
      translatedString = translatedString.replace(
        `%{${placeholder}}`,
        replacementValue
      );
    }
    return translatedString;
  }
  t(key, replacements, options) {
    const translationKey = `${this.locale}.${key}`;
    const translation = this.translations[translationKey];
    if (!translation) {
      if (this.enableFallback) {
        const fallbackTranslationKey = `${this.defaultLocale}.${key}`;
        const fallbackTranslation = this.translations[fallbackTranslationKey];
        if (fallbackTranslation) {
          return this.translateWithReplacements(
            fallbackTranslation,
            replacements
          );
        }
      }
      if (options == null ? void 0 : options.rawKeyIfTranslationMissing) return key;
      return this.missingMessage(key);
    }
    return this.translateWithReplacements(translation, replacements);
  }
  isLocaleCached(locale) {
    return this.cachedLocales.includes(locale);
  }
  updateLocale(locale) {
    this.locale = locale;
    this.notifyListeners();
  }
  setTranslations(locale, translations) {
    const cachedLocale = this.isLocaleCached(locale);
    if (!cachedLocale) {
      this.cachedLocales = [...this.cachedLocales, locale];
      this.translations = {
        ...this.translations,
        ...this.flattenTranslation(translations, locale)
      };
    }
    this.locale = locale;
    this.notifyListeners();
  }
  notifyListeners() {
    for (const listener of this.listeners) {
      listener();
    }
  }
  onChange(fn) {
    this.listeners.add(fn);
    return () => {
      this.listeners.delete(fn);
    };
  }
};
var i18n = new I18n({
  en: JSON.parse(en_US_default),
  "en-US": JSON.parse(en_US_default)
});
i18n.defaultLocale = "en-US";
i18n.locale = "en-US";
i18n.enableFallback = true;
var fetchTranslations = async (locale) => {
  switch (locale) {
    case "ar":
    case "ar-AR":
      return (await import("./ar_AR-CTNWGWSS-VXGI2YL7.js")).default;
    case "de":
    case "de-DE":
      return (await import("./de_DE-P43L3PR7-HGDUMSPQ.js")).default;
    case "en":
    case "en-US":
      return (await import("./en_US-KAK2ZBDO-LACFAFVR.js")).default;
    case "es":
    case "es-419":
      return (await import("./es_419-JBX5FS3Q-Y4DI4W2W.js")).default;
    case "fr":
    case "fr-FR":
      return (await import("./fr_FR-CM2EDAQC-KY43ETGP.js")).default;
    case "hi":
    case "hi-IN":
      return (await import("./hi_IN-GYVCUYRD-MUSSWFMS.js")).default;
    case "id":
    case "id-ID":
      return (await import("./id_ID-7ZWSMOOE-EFBROAJU.js")).default;
    case "ja":
    case "ja-JP":
      return (await import("./ja_JP-CGMP6VLZ-7U4S4MOD.js")).default;
    case "ko":
    case "ko-KR":
      return (await import("./ko_KR-YCZDTF7X-QCUTBT4I.js")).default;
    case "ms":
    case "ms-MY":
      return (await import("./ms_MY-5LHAYMS7-QL5FPM4K.js")).default;
    case "pt":
    case "pt-BR":
      return (await import("./pt_BR-3JTS4PSK-FIAAVCYA.js")).default;
    case "ru":
    case "ru-RU":
      return (await import("./ru_RU-6J6XERHI-IMWZBTZN.js")).default;
    case "th":
    case "th-TH":
      return (await import("./th_TH-STXOD4CR-JTBUSDAH.js")).default;
    case "tr":
    case "tr-TR":
      return (await import("./tr_TR-P7QAUUZU-PT5DWHJR.js")).default;
    case "ua":
    case "uk-UA":
      return (await import("./uk_UA-JTTBGJGQ-FINXBTN4.js")).default;
    case "vi":
    case "vi-VN":
      return (await import("./vi_VN-5XUUAVWW-MQDIKPRV.js")).default;
    case "zh":
    case "zh-CN":
    case "zh-Hans":
      return (await import("./zh_CN-RGMLPFEP-DDDFLWW5.js")).default;
    case "zh-HK":
      return (await import("./zh_HK-YM3T6EI5-4ZHV64VL.js")).default;
    case "zh-Hant":
    case "zh-TW":
      return (await import("./zh_TW-HAEH6VE5-AOYEIVZT.js")).default;
    default:
      return (await import("./en_US-KAK2ZBDO-LACFAFVR.js")).default;
  }
};
async function setLocale(locale) {
  const isCached = i18n.isLocaleCached(locale);
  if (isCached) {
    i18n.updateLocale(locale);
    return;
  }
  const translations = await fetchTranslations(locale);
  i18n.setTranslations(locale, JSON.parse(translations));
}
var detectedBrowserLocale = () => {
  var _a;
  if (typeof window !== "undefined" && typeof navigator !== "undefined") {
    if ((_a = navigator.languages) == null ? void 0 : _a.length) {
      return navigator.languages[0];
    }
    if (navigator.language) {
      return navigator.language;
    }
  }
};
var I18nContext = (0, import_react14.createContext)({ i18n });
var I18nProvider = ({ children, locale }) => {
  const [updateCount, setUpdateCount] = (0, import_react14.useState)(0);
  const browserLocale = (0, import_react14.useMemo)(
    () => detectedBrowserLocale(),
    []
  );
  (0, import_react14.useEffect)(() => {
    const unsubscribe = i18n.onChange(() => {
      setUpdateCount((count) => count + 1);
    });
    return unsubscribe;
  }, []);
  (0, import_react14.useEffect)(() => {
    if (locale && locale !== i18n.locale) {
      setLocale(locale);
    } else if (!locale && browserLocale && browserLocale !== i18n.locale) {
      setLocale(browserLocale);
    }
  }, [locale, browserLocale]);
  const memoizedValue = (0, import_react14.useMemo)(() => {
    const t = (key, options) => i18n.t(key, options);
    return { t, i18n };
  }, [updateCount]);
  return import_react14.default.createElement(I18nContext.Provider, { value: memoizedValue }, children);
};
function isNotNullish(value) {
  return value != null;
}
var apeChainIcon = {
  iconBackground: "#7290CC",
  iconUrl: async () => (await import("./apechain-SX5YFU6N-FQLDN4VD.js")).default
};
var arbitrumIcon = {
  iconBackground: "#96bedc",
  iconUrl: async () => (await import("./arbitrum-WURIBY6W-KNPUHTGH.js")).default
};
var avalancheIcon = {
  iconBackground: "#e84141",
  iconUrl: async () => (await import("./avalanche-KOMJD3XY-KGMWV5A3.js")).default
};
var baseIcon = {
  iconBackground: "#0052ff",
  iconUrl: async () => (await import("./base-OAXLRA4F-XA4ALC64.js")).default
};
var berachainIcon = {
  iconBackground: "#814625",
  iconUrl: async () => (await import("./berachain-NJECWIVC-TYXS4KQ5.js")).default
};
var blastIcon = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./blast-V555OVXZ-LMJH6PT4.js")).default
};
var bscIcon = {
  iconBackground: "#ebac0e",
  iconUrl: async () => (await import("./bsc-N647EYR2-6RDT7NGZ.js")).default
};
var celoIcon = {
  iconBackground: "#FCFF52",
  iconUrl: async () => (await import("./celo-GEP4TUHG-PXGRSVLT.js")).default
};
var cronosIcon = {
  iconBackground: "#002D74",
  iconUrl: async () => (await import("./cronos-HJPAQTAE-XT3YCYOU.js")).default
};
var degenIcon = {
  iconBackground: "#A36EFD",
  iconUrl: async () => (await import("./degen-FQQ4XGHB-N4FSHITQ.js")).default
};
var ethereumIcon = {
  iconBackground: "#484c50",
  iconUrl: async () => (await import("./ethereum-RGGVA4PY-VLF2LOBC.js")).default
};
var flowIcon = {
  iconBackground: "transparent",
  iconUrl: async () => (await import("./flow-5FQJFCTK-GOU2KVEE.js")).default
};
var gnosisIcon = {
  iconBackground: "#04795c",
  iconUrl: async () => (await import("./gnosis-37ZC4RBL-OLCKBUAU.js")).default
};
var gravityIcon = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./gravity-J5YQHTYH-SOVC5S6Z.js")).default
};
var hardhatIcon = {
  iconBackground: "#f9f7ec",
  iconUrl: async () => (await import("./hardhat-TX56IT5N-TIN6VUIQ.js")).default
};
var hyperevmIcon = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./hyperevm-VKPAA4SA-JQ63TX2V.js")).default
};
var inkIcon = {
  iconBackground: "#7132F5",
  iconUrl: async () => (await import("./ink-FZMYZWHG-QLDLGK2M.js")).default
};
var kaiaIcon = {
  iconBackground: "transparent",
  iconUrl: async () => (await import("./kaia-65D2U3PU-57GJPCMI.js")).default
};
var lineaIcon = {
  iconBackground: "#ffffff",
  iconUrl: async () => (await import("./linea-QRMVQ5DY-ROPXMDGI.js")).default
};
var mantaIcon = {
  iconBackground: "#ffffff",
  iconUrl: async () => (await import("./manta-SI27YFEJ-TU752DLD.js")).default
};
var mantleIcon = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./mantle-CKIUT334-SYGYKUNF.js")).default
};
var monadTestnetIcon = {
  iconBackground: "transparent",
  iconUrl: async () => (await import("./monad-4KWC6TSS-KJMRKSZT.js")).default
};
var optimismIcon = {
  iconBackground: "#ff5a57",
  iconUrl: async () => (await import("./optimism-HAF2GUT7-S7JK373J.js")).default
};
var polygonIcon = {
  iconBackground: "#9f71ec",
  iconUrl: async () => (await import("./polygon-WW6ZI7PM-32UOB4PN.js")).default
};
var roninIcon = {
  iconBackground: "#1273EA",
  iconUrl: async () => (await import("./ronin-EMCPYXZT-H6IYNKRQ.js")).default
};
var sankoIcon = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./sanko-RHQYXGM5-VYVIB5WR.js")).default
};
var superpositionIcon = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./superposition-HG6MMR2Y-5AM377Z2.js")).default
};
var scrollIcon = {
  iconBackground: "#FFEEDA",
  iconUrl: async () => (await import("./scroll-5OBGQVOV-6DYHIZAN.js")).default
};
var unichainIcon = {
  iconBackground: "#F50DB4",
  iconUrl: async () => (await import("./unichain-C5BWO2ZY-Y3IQLDJC.js")).default
};
var xdcIcon = {
  iconBackground: "#f9f7ec",
  iconUrl: async () => (await import("./xdc-KJ3TDBYO-AHRDGVVX.js")).default
};
var zetachainIcon = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./zetachain-TLDS5IPW-7SQ3D2XT.js")).default
};
var zkSyncIcon = {
  iconBackground: "#f9f7ec",
  iconUrl: async () => (await import("./zksync-DH7HK5U4-XK3UP3CG.js")).default
};
var zoraIcon = {
  iconBackground: "#000000",
  iconUrl: async () => (await import("./zora-FYL5H3IO-KD6K2L2X.js")).default
};
var chainMetadataByName = {
  apechain: { chainId: 33139, name: "ApeChain", ...apeChainIcon },
  apechainCurtis: { chainId: 33111, name: "ApeChain Curtis", ...apeChainIcon },
  arbitrum: { chainId: 42161, name: "Arbitrum", ...arbitrumIcon },
  arbitrumGoerli: { chainId: 421613, ...arbitrumIcon },
  arbitrumSepolia: { chainId: 421614, ...arbitrumIcon },
  avalanche: { chainId: 43114, ...avalancheIcon },
  avalancheFuji: { chainId: 43113, ...avalancheIcon },
  base: { chainId: 8453, name: "Base", ...baseIcon },
  baseGoerli: { chainId: 84531, ...baseIcon },
  baseSepolia: { chainId: 84532, ...baseIcon },
  berachain: { chainId: 80094, name: "Berachain", ...berachainIcon },
  berachainArtio: { chainId: 80085, name: "Berachain Artio", ...berachainIcon },
  berachainBArtio: {
    chainId: 80084,
    name: "Berachain bArtio",
    ...berachainIcon
  },
  blast: { chainId: 81457, name: "Blast", ...blastIcon },
  blastSepolia: { chainId: 168587773, ...blastIcon },
  bsc: { chainId: 56, name: "BSC", ...bscIcon },
  bscTestnet: { chainId: 97, ...bscIcon },
  celo: { chainId: 42220, name: "Celo", ...celoIcon },
  celoAlfajores: { chainId: 44787, name: "Celo Alfajores", ...celoIcon },
  cronos: { chainId: 25, ...cronosIcon },
  cronosTestnet: { chainId: 338, ...cronosIcon },
  degen: { chainId: 666666666, name: "Degen", ...degenIcon },
  flow: { chainId: 747, ...flowIcon },
  flowTestnet: { chainId: 545, ...flowIcon },
  gnosis: { chainId: 100, name: "Gnosis", ...gnosisIcon },
  goerli: { chainId: 5, ...ethereumIcon },
  gravity: { chainId: 1625, name: "Gravity", ...gravityIcon },
  gravitySepolia: { chainId: 13505, name: "Gravity Sepolia", ...gravityIcon },
  hardhat: { chainId: 31337, ...hardhatIcon },
  holesky: { chainId: 17e3, ...ethereumIcon },
  hyperevm: { chainId: 999, ...hyperevmIcon },
  ink: { chainId: 57073, ...inkIcon },
  inkSepolia: { chainId: 763373, ...inkIcon },
  kaia: { chainId: 8217, name: "Kaia", ...kaiaIcon },
  kairos: { chainId: 1001, name: "Kairos", ...kaiaIcon },
  kovan: { chainId: 42, ...ethereumIcon },
  linea: { chainId: 59144, name: "Linea", ...lineaIcon },
  lineaGoerli: { chainId: 59140, name: "Linea Goerli", ...lineaIcon },
  lineaSepolia: { chainId: 59141, name: "Linea Sepolia", ...lineaIcon },
  localhost: { chainId: 1337, ...ethereumIcon },
  mainnet: { chainId: 1, name: "Ethereum", ...ethereumIcon },
  manta: { chainId: 169, name: "Manta", ...mantaIcon },
  mantaSepolia: { chainId: 3441006, ...mantaIcon },
  mantaTestnet: { chainId: 3441005, ...mantaIcon },
  mantle: { chainId: 5e3, ...mantleIcon },
  mantleTestnet: { chainId: 5001, ...mantleIcon },
  monadTestnet: { chainId: 10143, name: "Monad Testnet", ...monadTestnetIcon },
  optimism: { chainId: 10, name: "Optimism", ...optimismIcon },
  optimismGoerli: { chainId: 420, ...optimismIcon },
  optimismKovan: { chainId: 69, ...optimismIcon },
  optimismSepolia: { chainId: 11155420, ...optimismIcon },
  polygon: { chainId: 137, name: "Polygon", ...polygonIcon },
  polygonAmoy: { chainId: 80002, ...polygonIcon },
  polygonMumbai: { chainId: 80001, ...polygonIcon },
  rinkeby: { chainId: 4, ...ethereumIcon },
  ronin: { chainId: 2020, ...roninIcon },
  ropsten: { chainId: 3, ...ethereumIcon },
  sanko: { chainId: 1996, name: "Sanko", ...sankoIcon },
  scroll: { chainId: 534352, ...scrollIcon },
  scrollSepolia: { chainId: 534351, ...scrollIcon },
  sepolia: { chainId: 11155111, ...ethereumIcon },
  superposition: {
    chainId: 55244,
    name: "Superposition",
    ...superpositionIcon
  },
  unichain: { chainId: 130, ...unichainIcon },
  unichainSepolia: { chainId: 1301, ...unichainIcon },
  xdc: { chainId: 50, name: "XDC", ...xdcIcon },
  xdcTestnet: { chainId: 51, ...xdcIcon },
  zetachain: { chainId: 7e3, name: "ZetaChain", ...zetachainIcon },
  zetachainAthensTestnet: {
    chainId: 7001,
    name: "Zeta Athens",
    ...zetachainIcon
  },
  zkSync: { chainId: 324, name: "zkSync", ...zkSyncIcon },
  zkSyncTestnet: { chainId: 280, ...zkSyncIcon },
  zora: { chainId: 7777777, name: "Zora", ...zoraIcon },
  zoraSepolia: { chainId: 999999999, ...zoraIcon },
  zoraTestnet: { chainId: 999, ...zoraIcon }
};
var chainMetadataById = Object.fromEntries(
  Object.values(chainMetadataByName).filter(isNotNullish).map(({ chainId, ...metadata }) => [chainId, metadata])
);
var provideRainbowKitChains = (chains) => chains.map((chain) => {
  const defaultMetadata = chainMetadataById[chain.id] ?? {};
  return {
    ...chain,
    name: defaultMetadata.name ?? chain.name,
    // favor colloquial names
    iconUrl: chain.iconUrl ?? defaultMetadata.iconUrl,
    iconBackground: chain.iconBackground ?? defaultMetadata.iconBackground
  };
});
var RainbowKitChainContext = (0, import_react15.createContext)({
  chains: []
});
function RainbowKitChainProvider({
  children,
  initialChain
}) {
  const { chains } = useConfig();
  return import_react15.default.createElement(
    RainbowKitChainContext.Provider,
    {
      value: (0, import_react15.useMemo)(
        () => ({
          chains: provideRainbowKitChains(chains),
          initialChainId: typeof initialChain === "number" ? initialChain : initialChain == null ? void 0 : initialChain.id
        }),
        [chains, initialChain]
      )
    },
    children
  );
}
var useRainbowKitChains = () => (0, import_react15.useContext)(RainbowKitChainContext).chains;
var useInitialChainId = () => (0, import_react15.useContext)(RainbowKitChainContext).initialChainId;
var useRainbowKitChainsById = () => {
  const rainbowkitChains = useRainbowKitChains();
  return (0, import_react15.useMemo)(() => {
    const rainbowkitChainsById = {};
    for (const rkChain of rainbowkitChains) {
      rainbowkitChainsById[rkChain.id] = rkChain;
    }
    return rainbowkitChainsById;
  }, [rainbowkitChains]);
};
var ShowBalanceContext = (0, import_react16.createContext)({
  showBalance: void 0,
  setShowBalance: () => {
  }
});
function ShowBalanceProvider({ children }) {
  const [showBalance, setShowBalance] = (0, import_react16.useState)();
  return import_react16.default.createElement(ShowBalanceContext.Provider, { value: { showBalance, setShowBalance } }, children);
}
var useShowBalance = () => (0, import_react16.useContext)(ShowBalanceContext);
function useIsMounted() {
  const [isMounted, setIsMounted] = (0, import_react18.useState)(false);
  (0, import_react18.useEffect)(() => {
    setIsMounted(true);
    return () => {
      setIsMounted(false);
    };
  }, []);
  return (0, import_react18.useCallback)(() => isMounted, [isMounted]);
}
function useIsMainnetConfigured() {
  const rainbowKitChains = useRainbowKitChains();
  const chainId = mainnet.id;
  const configured = rainbowKitChains.some(
    (rainbowKitChain) => rainbowKitChain.id === chainId
  );
  return configured;
}
function useMainnetEnsAvatar(name) {
  const mainnetConfigured = useIsMainnetConfigured();
  const safeNormalize = (ensName) => {
    try {
      return normalize2(ensName);
    } catch {
    }
  };
  const { data: ensAvatar } = useEnsAvatar({
    chainId: mainnet.id,
    name: name ? safeNormalize(name) : void 0,
    query: {
      enabled: mainnetConfigured
    }
  });
  return ensAvatar;
}
async function rainbowFetch(url, opts) {
  opts = {
    headers: {},
    method: "get",
    ...opts,
    // Any other fetch options
    timeout: opts.timeout ?? 1e4
    // 10 secs
  };
  if (!url) throw new Error("rainbowFetch: Missing url argument");
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), opts.timeout);
  const { body, params, headers, ...otherOpts } = opts;
  const requestBody = body && typeof body === "object" ? JSON.stringify(opts.body) : opts.body;
  const response = await fetch(`${url}${createParams(params)}`, {
    ...otherOpts,
    body: requestBody,
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json",
      ...headers
    },
    signal: controller.signal
  });
  clearTimeout(id);
  const responseBody = await getBody(response);
  if (response.ok) {
    const { headers: headers2, status } = response;
    return { data: responseBody, headers: headers2, status };
  }
  const errorResponseBody = typeof responseBody === "string" ? { error: responseBody } : responseBody;
  const error = generateError({
    requestBody: body,
    response,
    responseBody: errorResponseBody
  });
  throw error;
}
function getBody(response) {
  const contentType = response.headers.get("Content-Type");
  if (contentType == null ? void 0 : contentType.startsWith("application/json")) {
    return response.json();
  }
  return response.text();
}
function createParams(params) {
  return params && Object.keys(params).length ? `?${new URLSearchParams(params)}` : "";
}
function generateError({
  requestBody,
  response,
  responseBody
}) {
  const message = (responseBody == null ? void 0 : responseBody.error) || (response == null ? void 0 : response.statusText) || "There was an error with the request.";
  const error = new Error(message);
  error.response = response;
  error.responseBody = responseBody;
  error.requestBody = requestBody;
  return error;
}
var RainbowFetchClient = class {
  constructor(opts = {}) {
    const { baseUrl = "", ...otherOpts } = opts;
    this.baseUrl = baseUrl;
    this.opts = otherOpts;
  }
  /**
   * Perform a GET request with the RainbowFetchClient.
   */
  get(url, opts) {
    return rainbowFetch(`${this.baseUrl}${url}`, {
      ...this.opts,
      ...opts || {},
      method: "get"
    });
  }
  /**
   * Perform a DELETE request with the RainbowFetchClient.
   */
  delete(url, opts) {
    return rainbowFetch(`${this.baseUrl}${url}`, {
      ...this.opts,
      ...opts || {},
      method: "delete"
    });
  }
  /**
   * Perform a HEAD request with the RainbowFetchClient.
   */
  head(url, opts) {
    return rainbowFetch(`${this.baseUrl}${url}`, {
      ...this.opts,
      ...opts || {},
      method: "head"
    });
  }
  /**
   * Perform a OPTIONS request with the RainbowFetchClient.
   */
  options(url, opts) {
    return rainbowFetch(`${this.baseUrl}${url}`, {
      ...this.opts,
      ...opts || {},
      method: "options"
    });
  }
  /**
   * Perform a POST request with the RainbowFetchClient.
   */
  post(url, body, opts) {
    return rainbowFetch(`${this.baseUrl}${url}`, {
      ...this.opts,
      ...opts || {},
      body,
      method: "post"
    });
  }
  /**
   * Perform a PUT request with the RainbowFetchClient.
   */
  put(url, body, opts) {
    return rainbowFetch(`${this.baseUrl}${url}`, {
      ...this.opts,
      ...opts || {},
      body,
      method: "put"
    });
  }
  /**
   * Perform a PATCH request with the RainbowFetchClient.
   */
  patch(url, body, opts) {
    return rainbowFetch(`${this.baseUrl}${url}`, {
      ...this.opts,
      ...opts || {},
      body,
      method: "patch"
    });
  }
};
function createHttpClient({
  baseUrl,
  headers,
  params,
  timeout
}) {
  return new RainbowFetchClient({ baseUrl, headers, params, timeout });
}
var ENHANCED_PROVIDER_ENABLED = Boolean(
  typeof process !== "undefined" && typeof process.env !== "undefined" && process.env.RAINBOW_PROVIDER_API_KEY
);
var enhancedProviderHttp = createHttpClient({
  baseUrl: "https://enhanced-provider.rainbow.me",
  headers: {
    "x-api-key": typeof process !== "undefined" && typeof process.env !== "undefined" && process.env.RAINBOW_PROVIDER_API_KEY || "LzbasoBiLqltex3VkcQ7LRmL4PtfiiZ1EMJrizrgfonWN6byJReu/l6yrUoo3zLW"
  }
});
function createQueryKey(key, args, config = {}) {
  return [key, args, config];
}
function getStorageEnsNameKey(address) {
  return `rk-ens-name-${address}`;
}
function safeParseJsonData(string2) {
  try {
    const value = string2 ? JSON.parse(string2) : null;
    return typeof value === "object" ? value : null;
  } catch {
    return null;
  }
}
function addEnsName(address, ensName) {
  if (!isAddress(address)) return;
  const now = /* @__PURE__ */ new Date();
  const expiry = new Date(now.getTime() + 180 * 6e4);
  localStorage.setItem(
    getStorageEnsNameKey(address),
    JSON.stringify({
      ensName,
      expires: expiry.getTime()
    })
  );
}
function getEnsName2(address) {
  const data = safeParseJsonData(
    localStorage.getItem(getStorageEnsNameKey(address))
  );
  if (!data) return null;
  const { ensName, expires } = data;
  if (typeof ensName !== "string" || Number.isNaN(Number(expires))) {
    localStorage.removeItem(getStorageEnsNameKey(address));
    return null;
  }
  const now = /* @__PURE__ */ new Date();
  if (now.getTime() > Number(expires)) {
    localStorage.removeItem(getStorageEnsNameKey(address));
    return null;
  }
  return ensName;
}
async function getEnhancedProviderEnsName({ address }) {
  const ensName = getEnsName2(address);
  if (ensName) return ensName;
  const response = await enhancedProviderHttp.get("/v1/resolve-ens", { params: { address } });
  const enhancedProviderEnsName = response.data.data;
  if (enhancedProviderEnsName) {
    addEnsName(address, enhancedProviderEnsName);
  }
  return enhancedProviderEnsName;
}
function useMainnetEnsName(address) {
  const mainnetConfigured = useIsMainnetConfigured();
  const { data: ensName } = useEnsName({
    chainId: mainnet.id,
    address,
    query: {
      enabled: mainnetConfigured
    }
  });
  const { data: enhancedProviderEnsName } = useQuery({
    queryKey: createQueryKey("address", address),
    queryFn: () => getEnhancedProviderEnsName({ address }),
    enabled: !mainnetConfigured && !!address && ENHANCED_PROVIDER_ENABLED,
    staleTime: 10 * (60 * 1e3),
    // 10 minutes
    retry: 1
    // Retry once before returning undefined if the request fails
  });
  return ensName || enhancedProviderEnsName;
}
function useProfile({ address, includeBalance }) {
  const ensName = useMainnetEnsName(address);
  const ensAvatar = useMainnetEnsAvatar(ensName);
  const { data: balance } = useBalance({
    address: includeBalance ? address : void 0
  });
  return { ensName, ensAvatar, balance };
}
function useChainId() {
  const { chain: activeChain } = useAccount();
  return (activeChain == null ? void 0 : activeChain.id) ?? null;
}
var storageKey = "rk-transactions";
function safeParseJsonData2(string2) {
  try {
    const value = string2 ? JSON.parse(string2) : {};
    return typeof value === "object" ? value : {};
  } catch {
    return {};
  }
}
function loadData() {
  return safeParseJsonData2(
    typeof localStorage !== "undefined" ? localStorage.getItem(storageKey) : null
  );
}
var transactionHashRegex = /^0x([A-Fa-f0-9]{64})$/;
function validateTransaction(transaction) {
  const errors = [];
  if (!transactionHashRegex.test(transaction.hash)) {
    errors.push("Invalid transaction hash");
  }
  if (typeof transaction.description !== "string") {
    errors.push("Transaction must have a description");
  }
  if (typeof transaction.confirmations !== "undefined" && (!Number.isInteger(transaction.confirmations) || transaction.confirmations < 1)) {
    errors.push("Transaction confirmations must be a positiver integer");
  }
  return errors;
}
function createTransactionStore({
  provider: initialProvider
}) {
  let data = loadData();
  let provider = initialProvider;
  const listeners = /* @__PURE__ */ new Set();
  const transactionListeners = /* @__PURE__ */ new Set();
  const transactionRequestCache = /* @__PURE__ */ new Map();
  function setProvider(newProvider) {
    provider = newProvider;
  }
  function getTransactions(account, chainId) {
    var _a;
    return ((_a = data[account]) == null ? void 0 : _a[chainId]) ?? [];
  }
  function addTransaction(account, chainId, transaction) {
    const errors = validateTransaction(transaction);
    if (errors.length > 0) {
      throw new Error(["Unable to add transaction", ...errors].join("\n"));
    }
    updateTransactions(account, chainId, (transactions) => {
      return [
        { ...transaction, status: "pending" },
        ...transactions.filter(({ hash: hash8 }) => {
          return hash8 !== transaction.hash;
        })
      ];
    });
  }
  function clearTransactions(account, chainId) {
    updateTransactions(account, chainId, () => {
      return [];
    });
  }
  function setTransactionStatus(account, chainId, hash8, status) {
    updateTransactions(account, chainId, (transactions) => {
      return transactions.map(
        (transaction) => transaction.hash === hash8 ? { ...transaction, status } : transaction
      );
    });
  }
  async function waitForPendingTransactions(account, chainId) {
    await Promise.all(
      getTransactions(account, chainId).filter((transaction) => transaction.status === "pending").map(async (transaction) => {
        const { confirmations, hash: hash8 } = transaction;
        const existingRequest = transactionRequestCache.get(hash8);
        if (existingRequest) {
          return await existingRequest;
        }
        const requestPromise = provider.waitForTransactionReceipt({
          confirmations,
          hash: hash8,
          timeout: 3e5
          // 5 minutes
        }).then(({ status }) => {
          transactionRequestCache.delete(hash8);
          if (status === void 0) {
            return;
          }
          setTransactionStatus(
            account,
            chainId,
            hash8,
            // @ts-ignore - types changed with viem@1.1.0
            status === 0 || status === "reverted" ? "failed" : "confirmed"
          );
          notifyTransactionListeners(status);
        }).catch(() => {
          setTransactionStatus(account, chainId, hash8, "failed");
        });
        transactionRequestCache.set(hash8, requestPromise);
        return await requestPromise;
      })
    );
  }
  function updateTransactions(account, chainId, updateFn) {
    data = loadData();
    data[account] = data[account] ?? {};
    let completedTransactionCount = 0;
    const MAX_COMPLETED_TRANSACTIONS = 10;
    const transactions = updateFn(data[account][chainId] ?? []).filter(({ status }) => {
      return status === "pending" ? true : completedTransactionCount++ <= MAX_COMPLETED_TRANSACTIONS;
    });
    data[account][chainId] = transactions.length > 0 ? transactions : void 0;
    persistData();
    notifyListeners();
    waitForPendingTransactions(account, chainId);
  }
  function persistData() {
    localStorage.setItem(storageKey, JSON.stringify(data));
  }
  function notifyListeners() {
    for (const listener of listeners) {
      listener();
    }
  }
  function notifyTransactionListeners(txStatus) {
    for (const transactionListener of transactionListeners) {
      transactionListener(txStatus);
    }
  }
  function onChange(fn) {
    listeners.add(fn);
    return () => {
      listeners.delete(fn);
    };
  }
  function onTransactionStatus(fn) {
    transactionListeners.add(fn);
    return () => {
      transactionListeners.delete(fn);
    };
  }
  return {
    addTransaction,
    clearTransactions,
    getTransactions,
    onTransactionStatus,
    onChange,
    setProvider,
    waitForPendingTransactions
  };
}
var storeSingleton;
var TransactionStoreContext = import_react20.default.createContext(
  null
);
function TransactionStoreProvider({
  children
}) {
  const provider = usePublicClient();
  const { address } = useAccount();
  const chainId = useChainId();
  const { refetch } = useBalance({
    address,
    query: {
      enabled: false
    }
  });
  const [store] = import_react20.default.useState(
    () => storeSingleton ?? (storeSingleton = createTransactionStore({ provider }))
  );
  const onTransactionStatus = import_react20.default.useCallback(
    (txStatus) => {
      if (txStatus === "success") refetch();
    },
    [refetch]
  );
  import_react20.default.useEffect(() => {
    store.setProvider(provider);
  }, [store, provider]);
  import_react20.default.useEffect(() => {
    if (address && chainId) {
      store.waitForPendingTransactions(address, chainId);
    }
  }, [store, address, chainId]);
  import_react20.default.useEffect(() => {
    if (store && address && chainId) {
      return store.onTransactionStatus(onTransactionStatus);
    }
  }, [store, address, chainId, onTransactionStatus]);
  return import_react20.default.createElement(TransactionStoreContext.Provider, { value: store }, children);
}
function useTransactionStore() {
  const store = import_react20.default.useContext(TransactionStoreContext);
  if (!store) {
    throw new Error("Transaction hooks must be used within RainbowKitProvider");
  }
  return store;
}
function useRecentTransactions() {
  const store = useTransactionStore();
  const { address } = useAccount();
  const chainId = useChainId();
  const [transactions, setTransactions] = (0, import_react19.useState)(
    () => store && address && chainId ? store.getTransactions(address, chainId) : []
  );
  (0, import_react19.useEffect)(() => {
    if (store && address && chainId) {
      setTransactions(store.getTransactions(address, chainId));
      return store.onChange(() => {
        setTransactions(store.getTransactions(address, chainId));
      });
    }
  }, [store, address, chainId]);
  return transactions;
}
var resolveThemeVars = (theme) => typeof theme === "function" ? theme() : theme;
function cssObjectFromTheme(theme, { extends: baseTheme2 } = {}) {
  const resolvedThemeVars = {
    // We use an object spread here to ensure it's a plain object since vanilla-extract's
    // var objects have a custom 'toString' method that returns a CSS string, but we don't
    // want to leak this to our consumers since they're unaware we're using vanilla-extract.
    // Instead, we want them to handle this explicitly via our 'cssStringFromTheme' function.
    ...assignInlineVars(themeVars, resolveThemeVars(theme))
  };
  if (!baseTheme2) {
    return resolvedThemeVars;
  }
  const resolvedBaseThemeVars = assignInlineVars(
    themeVars,
    resolveThemeVars(baseTheme2)
  );
  const filteredVars = Object.fromEntries(
    Object.entries(resolvedThemeVars).filter(
      ([varName, value]) => value !== resolvedBaseThemeVars[varName]
    )
  );
  return filteredVars;
}
function cssStringFromTheme(theme, options = {}) {
  return Object.entries(cssObjectFromTheme(theme, options)).map(([key, value]) => `${key}:${value.replace(/[:;{}</>]/g, "")};`).join("");
}
var defaultAppInfo = {
  appName: void 0,
  disclaimer: void 0,
  learnMoreUrl: "https://learn.rainbow.me/understanding-web3?utm_source=rainbowkit&utm_campaign=learnmore"
};
var AppContext = (0, import_react25.createContext)(defaultAppInfo);
var CoolModeContext = (0, import_react26.createContext)(false);
function debounce(fn, ms) {
  let timer;
  return () => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      timer = null;
      fn();
    }, ms);
  };
}
var useWindowSize = () => {
  const [windowSize, setWindowSize] = (0, import_react28.useState)({
    height: void 0,
    width: void 0
  });
  (0, import_react28.useEffect)(() => {
    const handleResize = debounce(() => {
      setWindowSize({
        height: window.innerHeight,
        width: window.innerWidth
      });
    }, 500);
    window.addEventListener("resize", handleResize);
    handleResize();
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return windowSize;
};
var WalletButtonContext = (0, import_react29.createContext)({
  connector: null,
  setConnector: () => {
  }
});
function WalletButtonProvider({ children }) {
  const [connector, setConnector] = (0, import_react29.useState)(null);
  return import_react29.default.createElement(
    WalletButtonContext.Provider,
    {
      value: (0, import_react29.useMemo)(
        () => ({
          connector,
          setConnector
        }),
        [connector]
      )
    },
    children
  );
}
var ModalSizeOptions = {
  COMPACT: "compact",
  WIDE: "wide"
};
var ModalSizeContext = (0, import_react27.createContext)(
  ModalSizeOptions.WIDE
);
function ModalSizeProvider({
  children,
  modalSize
}) {
  const { width } = useWindowSize();
  const isSmallScreen = width && width < largeScreenMinWidth;
  const { connector } = (0, import_react27.useContext)(WalletButtonContext);
  return import_react27.default.createElement(
    ModalSizeContext.Provider,
    {
      value: isSmallScreen || connector ? ModalSizeOptions.COMPACT : modalSize
    },
    children
  );
}
var ShowRecentTransactionsContext = (0, import_react30.createContext)(false);
var storageKey2 = "rk-version";
function setRainbowKitVersion({ version: version5 }) {
  localStorage.setItem(storageKey2, version5);
}
function useFingerprint() {
  const fingerprint = (0, import_react31.useCallback)(() => {
    setRainbowKitVersion({ version: "2.2.9" });
  }, []);
  (0, import_react31.useEffect)(() => {
    fingerprint();
  }, [fingerprint]);
}
function indexBy(items, getKey2) {
  const indexedItems = {};
  for (const item of items) {
    const key = getKey2(item);
    if (!key) {
      continue;
    }
    indexedItems[key] = item;
  }
  return indexedItems;
}
function isSafari() {
  return typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" && /Version\/([0-9._]+).*Safari/.test(navigator.userAgent);
}
function isArc() {
  return typeof document !== "undefined" && getComputedStyle(document.body).getPropertyValue("--arc-palette-focus") !== "";
}
function getBrowser() {
  var _a, _b;
  if (typeof navigator === "undefined") return "Browser";
  const ua2 = (_a = navigator.userAgent) == null ? void 0 : _a.toLowerCase();
  if ((_b = navigator.brave) == null ? void 0 : _b.isBrave) return "Brave";
  if ((ua2 == null ? void 0 : ua2.indexOf("edg/")) > -1) return "Edge";
  if ((ua2 == null ? void 0 : ua2.indexOf("op")) > -1) return "Opera";
  if (isArc()) return "Arc";
  if ((ua2 == null ? void 0 : ua2.indexOf("chrome")) > -1) return "Chrome";
  if ((ua2 == null ? void 0 : ua2.indexOf("firefox")) > -1) return "Firefox";
  if (isSafari()) return "Safari";
  return "Browser";
}
var ua = (0, import_ua_parser_js.UAParser)();
var { os } = ua;
function isWindows() {
  return os.name === "Windows";
}
function isMacOS() {
  return os.name === "Mac OS";
}
function isLinux() {
  return ["Ubuntu", "Mint", "Fedora", "Debian", "Arch", "Linux"].includes(
    os.name
  );
}
function getPlatform() {
  if (isWindows()) return "Windows";
  if (isMacOS()) return "macOS";
  if (isLinux()) return "Linux";
  return "Desktop";
}
var getExtensionDownloadUrl = (wallet) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const browser = getBrowser();
  return {
    [
      "Arc"
      /* Arc */
    ]: (_a = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _a.chrome,
    [
      "Brave"
      /* Brave */
    ]: (_b = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _b.chrome,
    [
      "Chrome"
      /* Chrome */
    ]: (_c = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _c.chrome,
    [
      "Edge"
      /* Edge */
    ]: ((_d = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _d.edge) || ((_e = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _e.chrome),
    [
      "Firefox"
      /* Firefox */
    ]: (_f = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _f.firefox,
    [
      "Opera"
      /* Opera */
    ]: ((_g = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _g.opera) || ((_h = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _h.chrome),
    [
      "Safari"
      /* Safari */
    ]: (_i = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _i.safari,
    [
      "Browser"
      /* Browser */
    ]: (_j = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _j.browserExtension
  }[browser] ?? ((_k = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _k.browserExtension);
};
var getMobileDownloadUrl = (wallet) => {
  var _a, _b, _c;
  const ios = isIOS();
  return (ios ? (_a = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _a.ios : (_b = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _b.android) ?? ((_c = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _c.mobile);
};
var getDesktopDownloadUrl = (wallet) => {
  var _a, _b, _c, _d, _e;
  const platform = getPlatform();
  return {
    [
      "Windows"
      /* Windows */
    ]: (_a = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _a.windows,
    [
      "macOS"
      /* MacOS */
    ]: (_b = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _b.macos,
    [
      "Linux"
      /* Linux */
    ]: (_c = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _c.linux,
    [
      "Desktop"
      /* Desktop */
    ]: (_d = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _d.desktop
  }[platform] ?? ((_e = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _e.desktop);
};
var isRecentWallet = (recentWallets, walletId) => {
  return recentWallets.some((recentWallet) => recentWallet.id === walletId);
};
var isRainbowKitConnector = (wallet) => {
  return !!wallet.isRainbowKitConnector;
};
var isEIP6963Connector = (wallet) => {
  var _a;
  return !!(!wallet.isRainbowKitConnector && ((_a = wallet.icon) == null ? void 0 : _a.replace(/\n/g, "").startsWith("data:image")) && wallet.uid && wallet.name);
};
var rainbowKitConnectorWithWalletConnect = (wallet, walletConnectModalConnector) => {
  const shouldUseWalletConnectModal = wallet.id === "walletConnect" && walletConnectModalConnector;
  return shouldUseWalletConnectModal ? { ...wallet, walletConnectModalConnector } : wallet;
};
var connectorsWithRecentWallets = ({
  wallets,
  recentWallets
}) => {
  return [
    ...recentWallets,
    ...wallets.filter((wallet) => !isRecentWallet(recentWallets, wallet.id))
  ];
};
var storageKey3 = "rk-recent";
function safeParseJsonArray(string2) {
  try {
    const value = string2 ? JSON.parse(string2) : [];
    return Array.isArray(value) ? value : [];
  } catch {
    return [];
  }
}
function getRecentWalletIds() {
  return typeof localStorage !== "undefined" ? safeParseJsonArray(localStorage.getItem(storageKey3)) : [];
}
function dedupe(array2) {
  return [...new Set(array2)];
}
function addRecentWalletId(walletId) {
  const newValue = dedupe([walletId, ...getRecentWalletIds()]);
  localStorage.setItem(storageKey3, JSON.stringify(newValue));
}
function useWalletConnectors(mergeEIP6963WithRkConnectors = false) {
  var _a, _b, _c;
  const rainbowKitChains = useRainbowKitChains();
  const intialChainId = useInitialChainId();
  const { connectAsync, connectors: defaultConnectors_untyped } = useConnect();
  const defaultCreatedConnectors = defaultConnectors_untyped;
  const { setIsWalletConnectModalOpen } = useWalletConnectOpenState();
  const defaultConnectors = defaultCreatedConnectors.map((connector) => ({
    ...connector,
    // rkDetails is optional it does not exist in eip6963 connectors.
    // We only inject `rkDetails` in `connectorsForWallets` when we
    // want to have additional information in the connector.
    ...connector.rkDetails || {}
  }));
  async function connectWallet(connector, parameters) {
    var _a2, _b2;
    const walletChainId = await connector.getChainId();
    const result = await connectAsync({
      ...parameters,
      chainId: (parameters == null ? void 0 : parameters.chainId) ?? // The goal here is to ensure users are always on a supported chain when connecting.
      // If an `initialChain` prop was provided to RainbowKitProvider, use that.
      intialChainId ?? // Otherwise, if the wallet is already on a supported chain, use that to avoid a chain switch prompt.
      ((_a2 = rainbowKitChains.find(({ id }) => id === walletChainId)) == null ? void 0 : _a2.id) ?? // Finally, fall back to the first chain provided to RainbowKitProvider.
      ((_b2 = rainbowKitChains[0]) == null ? void 0 : _b2.id),
      connector
    });
    if (result) {
      addRecentWalletId(connector.id);
    }
    return result;
  }
  async function connectToWalletConnectModal(walletConnectModalConnector2) {
    try {
      setIsWalletConnectModalOpen(true);
      await connectWallet(walletConnectModalConnector2);
      setIsWalletConnectModalOpen(false);
    } catch (err) {
      const isUserRejection = (
        // @ts-expect-error - Web3Modal v1 error name
        err.name === "UserRejectedRequestError" || // @ts-expect-error - Web3Modal v2 error message on desktop
        err.message === "Connection request reset. Please try again."
      );
      setIsWalletConnectModalOpen(false);
      if (!isUserRejection) {
        throw err;
      }
    }
  }
  const getWalletConnectUri = async (connector, uriConverter) => {
    const provider = await connector.getProvider();
    if (connector.id === "coinbase") {
      return provider.qrUrl;
    }
    return new Promise(
      (resolve) => (
        // Wagmi v2 doesn't have a return type for provider yet
        // @ts-expect-error
        provider.once("display_uri", (uri) => {
          resolve(uriConverter(uri));
        })
      )
    );
  };
  const walletConnectModalConnector = defaultConnectors.find(
    (connector) => connector.id === "walletConnect" && connector.isWalletConnectModalConnector
  );
  const eip6963Connectors = defaultConnectors.filter(isEIP6963Connector).map((connector) => {
    return {
      ...connector,
      groupIndex: 0
    };
  });
  const rainbowKitConnectors = defaultConnectors.filter(isRainbowKitConnector).filter((wallet) => !wallet.isWalletConnectModalConnector).filter((wallet) => {
    if (!mergeEIP6963WithRkConnectors) return true;
    const existsInEIP6963Connectors = eip6963Connectors.some(
      (eip6963) => eip6963.id === wallet.rdns
    );
    return !existsInEIP6963Connectors;
  }).map(
    (wallet) => rainbowKitConnectorWithWalletConnect(
      wallet,
      walletConnectModalConnector
    )
  );
  const combinedConnectors = [...eip6963Connectors, ...rainbowKitConnectors];
  const walletInstanceById = indexBy(
    combinedConnectors,
    (walletInstance) => walletInstance.id
  );
  const MAX_RECENT_WALLETS = 3;
  const recentWallets = getRecentWalletIds().map((walletId) => walletInstanceById[walletId]).filter(Boolean).slice(0, MAX_RECENT_WALLETS);
  const walletConnectors = [];
  const combinedConnectorsWithRecentWallets = connectorsWithRecentWallets({
    wallets: combinedConnectors,
    recentWallets
  });
  for (const wallet of combinedConnectorsWithRecentWallets) {
    if (!wallet) continue;
    const eip6963 = isEIP6963Connector(wallet);
    const recent = isRecentWallet(recentWallets, wallet.id);
    if (eip6963) {
      walletConnectors.push({
        ...wallet,
        iconUrl: wallet.icon,
        ready: true,
        connect: connectWallet.bind(null, wallet),
        groupName: "Installed",
        recent
      });
      continue;
    }
    walletConnectors.push({
      ...wallet,
      ready: wallet.installed ?? true,
      connect: connectWallet.bind(null, wallet),
      desktopDownloadUrl: getDesktopDownloadUrl(wallet),
      extensionDownloadUrl: getExtensionDownloadUrl(wallet),
      groupName: wallet.groupName,
      mobileDownloadUrl: getMobileDownloadUrl(wallet),
      getQrCodeUri: ((_a = wallet.qrCode) == null ? void 0 : _a.getUri) ? () => getWalletConnectUri(wallet, wallet.qrCode.getUri) : void 0,
      getDesktopUri: ((_b = wallet.desktop) == null ? void 0 : _b.getUri) ? () => getWalletConnectUri(wallet, wallet.desktop.getUri) : void 0,
      getMobileUri: ((_c = wallet.mobile) == null ? void 0 : _c.getUri) ? () => {
        var _a2;
        return getWalletConnectUri(wallet, (_a2 = wallet.mobile) == null ? void 0 : _a2.getUri);
      } : void 0,
      recent,
      showWalletConnectModal: wallet.walletConnectModalConnector ? () => connectToWalletConnectModal(wallet.walletConnectModalConnector) : void 0
    });
  }
  return walletConnectors;
}
var src = async () => (await import("./assets-Q6ZU7ZJ5-K4Q22N6N.js")).default;
var preloadAssetsIcon = () => loadImages(src);
var AssetsIcon = () => import_react33.default.createElement(
  AsyncImage,
  {
    background: "#d0d5de",
    borderRadius: "10",
    height: "48",
    src,
    width: "48"
  }
);
var src2 = async () => (await import("./login-UP3DZBGS-L3LQ2MQT.js")).default;
var preloadLoginIcon = () => loadImages(src2);
var LoginIcon = () => import_react34.default.createElement(
  AsyncImage,
  {
    background: "#d0d5de",
    borderRadius: "10",
    height: "48",
    src: src2,
    width: "48"
  }
);
var Text = import_react37.default.forwardRef(
  ({
    as = "div",
    children,
    className,
    color,
    display,
    font = "body",
    id,
    size: size5 = "16",
    style,
    tabIndex,
    textAlign = "inherit",
    weight = "regular",
    testId
  }, ref) => {
    return import_react37.default.createElement(
      Box,
      {
        as,
        className,
        color,
        display,
        fontFamily: font,
        fontSize: size5,
        fontWeight: weight,
        id,
        ref,
        style,
        tabIndex,
        textAlign,
        testId
      },
      children
    );
  }
);
Text.displayName = "Text";
var sizeVariants = {
  large: {
    fontSize: "16",
    paddingX: "24",
    paddingY: "10"
  },
  medium: {
    fontSize: "14",
    height: "28",
    paddingX: "12",
    paddingY: "4"
  },
  small: {
    fontSize: "14",
    paddingX: "10",
    paddingY: "5"
  }
};
function ActionButton({
  disabled = false,
  href,
  label,
  onClick,
  rel = "noreferrer noopener",
  size: size5 = "medium",
  target = "_blank",
  testId,
  type: type6 = "primary"
}) {
  const isPrimary = type6 === "primary";
  const isNotLarge = size5 !== "large";
  const mobile = isMobile();
  const background = !disabled ? isPrimary ? "accentColor" : isNotLarge ? "actionButtonSecondaryBackground" : null : "actionButtonSecondaryBackground";
  const { fontSize, height, paddingX, paddingY } = sizeVariants[size5];
  const hasBorder = !mobile || !isNotLarge;
  return import_react36.default.createElement(
    Box,
    {
      ...href ? !disabled ? { as: "a", href, rel, target } : {} : { as: "button", type: "button" },
      onClick: !disabled ? onClick : void 0,
      ...hasBorder ? {
        borderColor: mobile && !isNotLarge && !isPrimary ? "actionButtonBorderMobile" : "actionButtonBorder",
        borderStyle: "solid",
        borderWidth: "1"
      } : {},
      borderRadius: "actionButton",
      className: !disabled && touchableStyles({ active: "shrinkSm", hover: "grow" }),
      display: "block",
      paddingX,
      paddingY,
      style: { willChange: "transform" },
      testId,
      textAlign: "center",
      transition: "transform",
      ...background ? { background } : {},
      ...height ? { height } : {}
    },
    import_react36.default.createElement(
      Text,
      {
        color: !disabled ? isPrimary ? "accentColorForeground" : "accentColor" : "modalTextSecondary",
        size: fontSize,
        weight: "bold"
      },
      label
    )
  );
}
var CloseIcon = () => {
  return isMobile() ? import_react39.default.createElement(
    "svg",
    {
      "aria-hidden": true,
      fill: "none",
      height: "11.5",
      viewBox: "0 0 11.5 11.5",
      width: "11.5",
      xmlns: "http://www.w3.org/2000/svg"
    },
    import_react39.default.createElement("title", null, "Close"),
    import_react39.default.createElement(
      "path",
      {
        d: "M2.13388 0.366117C1.64573 -0.122039 0.854272 -0.122039 0.366117 0.366117C-0.122039 0.854272 -0.122039 1.64573 0.366117 2.13388L3.98223 5.75L0.366117 9.36612C-0.122039 9.85427 -0.122039 10.6457 0.366117 11.1339C0.854272 11.622 1.64573 11.622 2.13388 11.1339L5.75 7.51777L9.36612 11.1339C9.85427 11.622 10.6457 11.622 11.1339 11.1339C11.622 10.6457 11.622 9.85427 11.1339 9.36612L7.51777 5.75L11.1339 2.13388C11.622 1.64573 11.622 0.854272 11.1339 0.366117C10.6457 -0.122039 9.85427 -0.122039 9.36612 0.366117L5.75 3.98223L2.13388 0.366117Z",
        fill: "currentColor"
      }
    )
  ) : import_react39.default.createElement(
    "svg",
    {
      "aria-hidden": true,
      fill: "none",
      height: "10",
      viewBox: "0 0 10 10",
      width: "10",
      xmlns: "http://www.w3.org/2000/svg"
    },
    import_react39.default.createElement("title", null, "Close"),
    import_react39.default.createElement(
      "path",
      {
        d: "M1.70711 0.292893C1.31658 -0.0976311 0.683417 -0.0976311 0.292893 0.292893C-0.0976311 0.683417 -0.0976311 1.31658 0.292893 1.70711L3.58579 5L0.292893 8.29289C-0.0976311 8.68342 -0.0976311 9.31658 0.292893 9.70711C0.683417 10.0976 1.31658 10.0976 1.70711 9.70711L5 6.41421L8.29289 9.70711C8.68342 10.0976 9.31658 10.0976 9.70711 9.70711C10.0976 9.31658 10.0976 8.68342 9.70711 8.29289L6.41421 5L9.70711 1.70711C10.0976 1.31658 10.0976 0.683417 9.70711 0.292893C9.31658 -0.0976311 8.68342 -0.0976311 8.29289 0.292893L5 3.58579L1.70711 0.292893Z",
        fill: "currentColor"
      }
    )
  );
};
var CloseButton = ({
  "aria-label": ariaLabel = "Close",
  onClose
}) => {
  const mobile = isMobile();
  return import_react38.default.createElement(
    Box,
    {
      alignItems: "center",
      "aria-label": ariaLabel,
      as: "button",
      background: "closeButtonBackground",
      borderColor: "actionButtonBorder",
      borderRadius: "full",
      borderStyle: "solid",
      borderWidth: mobile ? "0" : "1",
      className: touchableStyles({ active: "shrinkSm", hover: "growLg" }),
      color: "closeButton",
      display: "flex",
      height: mobile ? "30" : "28",
      justifyContent: "center",
      onClick: onClose,
      style: { willChange: "transform" },
      transition: "default",
      type: "button",
      width: mobile ? "30" : "28"
    },
    import_react38.default.createElement(CloseIcon, null)
  );
};
var signInIcon = async () => (await import("./sign-A7IJEUT5-R57O3MYN.js")).default;
function SignIn({
  onClose,
  onCloseModal
}) {
  const { i18n: i18n2 } = (0, import_react35.useContext)(I18nContext);
  const [{ status, ...state }, setState] = import_react35.default.useState({ status: "idle" });
  const authAdapter = useAuthenticationAdapter();
  const getNonce2 = (0, import_react35.useCallback)(async () => {
    try {
      const nonce = await authAdapter.getNonce();
      setState((x) => ({ ...x, nonce }));
    } catch {
      setState((x) => ({
        ...x,
        errorMessage: i18n2.t("sign_in.message.preparing_error"),
        status: "idle"
      }));
    }
  }, [authAdapter, i18n2.t]);
  const onceRef = (0, import_react35.useRef)(false);
  import_react35.default.useEffect(() => {
    if (onceRef.current) return;
    onceRef.current = true;
    getNonce2();
  }, [getNonce2]);
  const mobile = isMobile();
  const { address, chain: activeChain } = useAccount();
  const { signMessageAsync } = useSignMessage();
  const signIn = async () => {
    try {
      const chainId = activeChain == null ? void 0 : activeChain.id;
      const { nonce } = state;
      if (!address || !chainId || !nonce) {
        return;
      }
      setState((x) => ({
        ...x,
        errorMessage: void 0,
        status: "signing"
      }));
      const message = authAdapter.createMessage({ address, chainId, nonce });
      let signature;
      try {
        signature = await signMessageAsync({
          message
        });
      } catch (error) {
        if (error instanceof UserRejectedRequestError) {
          return setState((x) => ({
            ...x,
            status: "idle"
          }));
        }
        return setState((x) => ({
          ...x,
          errorMessage: i18n2.t("sign_in.signature.signing_error"),
          status: "idle"
        }));
      }
      setState((x) => ({ ...x, status: "verifying" }));
      try {
        const verified = await authAdapter.verify({ message, signature });
        if (verified) {
          onCloseModal();
          return;
        }
        throw new Error();
      } catch {
        return setState((x) => ({
          ...x,
          errorMessage: i18n2.t("sign_in.signature.verifying_error"),
          status: "idle"
        }));
      }
    } catch {
      setState({
        errorMessage: i18n2.t("sign_in.signature.oops_error"),
        status: "idle"
      });
    }
  };
  return import_react35.default.createElement(Box, { position: "relative" }, import_react35.default.createElement(
    Box,
    {
      display: "flex",
      paddingRight: "16",
      paddingTop: "16",
      position: "absolute",
      right: "0"
    },
    import_react35.default.createElement(CloseButton, { onClose })
  ), import_react35.default.createElement(
    Box,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: mobile ? "32" : "24",
      padding: "24",
      paddingX: "18",
      style: { paddingTop: mobile ? "60px" : "36px" }
    },
    import_react35.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: mobile ? "6" : "4",
        style: { maxWidth: mobile ? 320 : 280 }
      },
      import_react35.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: mobile ? "32" : "16"
        },
        import_react35.default.createElement(AsyncImage, { height: 40, src: signInIcon, width: 40 }),
        import_react35.default.createElement(
          Text,
          {
            color: "modalText",
            size: mobile ? "20" : "18",
            textAlign: "center",
            weight: "heavy"
          },
          i18n2.t("sign_in.label")
        )
      ),
      import_react35.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: mobile ? "16" : "12"
        },
        import_react35.default.createElement(
          Text,
          {
            color: "modalTextSecondary",
            size: mobile ? "16" : "14",
            textAlign: "center"
          },
          i18n2.t("sign_in.description")
        ),
        status === "idle" && state.errorMessage ? import_react35.default.createElement(
          Text,
          {
            color: "error",
            size: mobile ? "16" : "14",
            textAlign: "center",
            weight: "bold"
          },
          state.errorMessage
        ) : null
      )
    ),
    import_react35.default.createElement(
      Box,
      {
        alignItems: !mobile ? "center" : void 0,
        display: "flex",
        flexDirection: "column",
        gap: "8",
        width: "full"
      },
      import_react35.default.createElement(
        ActionButton,
        {
          disabled: !state.nonce || status === "signing" || status === "verifying",
          label: !state.nonce ? i18n2.t("sign_in.message.preparing") : status === "signing" ? i18n2.t("sign_in.signature.waiting") : status === "verifying" ? i18n2.t("sign_in.signature.verifying") : i18n2.t("sign_in.message.send"),
          onClick: signIn,
          size: mobile ? "large" : "medium",
          testId: "auth-message-button"
        }
      ),
      mobile ? import_react35.default.createElement(
        ActionButton,
        {
          label: "Cancel",
          onClick: onClose,
          size: "large",
          type: "secondary"
        }
      ) : import_react35.default.createElement(
        Box,
        {
          as: "button",
          borderRadius: "full",
          className: touchableStyles({ active: "shrink", hover: "grow" }),
          display: "block",
          onClick: onClose,
          paddingX: "10",
          paddingY: "5",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        import_react35.default.createElement(
          Text,
          {
            color: "closeButton",
            size: mobile ? "16" : "14",
            weight: "bold"
          },
          i18n2.t("sign_in.message.cancel")
        )
      )
    )
  ));
}
function usePreloadImages() {
  const rainbowKitChains = useRainbowKitChains();
  const walletConnectors = useWalletConnectors();
  const isUnauthenticated = useAuthenticationStatus() === "unauthenticated";
  const preloadImages = (0, import_react32.useCallback)(() => {
    loadImages(
      ...walletConnectors.map((wallet) => wallet.iconUrl),
      ...rainbowKitChains.map((chain) => chain.iconUrl).filter(isNotNullish)
    );
    if (!isMobile()) {
      preloadAssetsIcon();
      preloadLoginIcon();
    }
    if (isUnauthenticated) {
      loadImages(signInIcon);
    }
  }, [walletConnectors, rainbowKitChains, isUnauthenticated]);
  (0, import_react32.useEffect)(() => {
    preloadImages();
  }, [preloadImages]);
}
var storageKey4 = "WALLETCONNECT_DEEPLINK_CHOICE";
function setWalletConnectDeepLink({
  mobileUri,
  name
}) {
  localStorage.setItem(
    storageKey4,
    JSON.stringify({
      href: mobileUri.split("?")[0],
      name
    })
  );
}
function clearWalletConnectDeepLink() {
  localStorage.removeItem(storageKey4);
}
var ThemeIdContext = (0, import_react24.createContext)(void 0);
var attr = "data-rk";
var createThemeRootProps = (id) => ({ [attr]: id || "" });
var createThemeRootSelector = (id) => {
  if (id && !/^[a-zA-Z0-9_]+$/.test(id)) {
    throw new Error(`Invalid ID: ${id}`);
  }
  return id ? `[${attr}="${id}"]` : `[${attr}]`;
};
var useThemeRootProps = () => {
  const id = (0, import_react24.useContext)(ThemeIdContext);
  return createThemeRootProps(id);
};
var defaultTheme = lightTheme();
function RainbowKitProvider({
  appInfo,
  avatar,
  children,
  coolMode = false,
  id,
  initialChain,
  locale,
  modalSize = ModalSizeOptions.WIDE,
  showRecentTransactions = false,
  theme = defaultTheme
}) {
  usePreloadImages();
  useFingerprint();
  useAccountEffect({ onDisconnect: clearWalletConnectDeepLink });
  if (typeof theme === "function") {
    throw new Error(
      'A theme function was provided to the "theme" prop instead of a theme object. You must execute this function to get the resulting theme object.'
    );
  }
  const selector = createThemeRootSelector(id);
  const appContext = {
    ...defaultAppInfo,
    ...appInfo
  };
  const avatarContext = avatar ?? defaultAvatar;
  return import_react24.default.createElement(RainbowKitChainProvider, { initialChain }, import_react24.default.createElement(WalletButtonProvider, null, import_react24.default.createElement(I18nProvider, { locale }, import_react24.default.createElement(CoolModeContext.Provider, { value: coolMode }, import_react24.default.createElement(ModalSizeProvider, { modalSize }, import_react24.default.createElement(
    ShowRecentTransactionsContext.Provider,
    {
      value: showRecentTransactions
    },
    import_react24.default.createElement(TransactionStoreProvider, null, import_react24.default.createElement(AvatarContext.Provider, { value: avatarContext }, import_react24.default.createElement(AppContext.Provider, { value: appContext }, import_react24.default.createElement(ThemeIdContext.Provider, { value: id }, import_react24.default.createElement(ShowBalanceProvider, null, import_react24.default.createElement(ModalProvider, null, theme ? import_react24.default.createElement("div", { ...createThemeRootProps(id) }, import_react24.default.createElement(
      "style",
      {
        dangerouslySetInnerHTML: {
          // Selectors are sanitized to only contain alphanumeric
          // and underscore characters. Theme values generated by
          // cssStringFromTheme are sanitized, removing
          // characters that terminate values / HTML tags.
          __html: [
            `${selector}{${cssStringFromTheme(
              "lightMode" in theme ? theme.lightMode : theme
            )}}`,
            "darkMode" in theme ? `@media(prefers-color-scheme:dark){${selector}{${cssStringFromTheme(
              theme.darkMode,
              { extends: theme.lightMode }
            )}}}` : null
          ].join("")
        }
      }
    ), children) : children))))))
  ))))));
}
var content = "_9pm4ki5 ju367va ju367v15 ju367v8r";
var overlay = "_9pm4ki3 ju367v9h ju367vb3 ju367va ju367v2q ju367v8q";
var moveFocusWithin = (element2, position) => {
  const focusableElements = element2.querySelectorAll(
    "button:not(:disabled), a[href]"
  );
  if (focusableElements.length === 0) return;
  focusableElements[position === "end" ? focusableElements.length - 1 : 0].focus();
};
function FocusTrap(props) {
  const contentRef = (0, import_react41.useRef)(null);
  (0, import_react41.useEffect)(() => {
    const previouslyActiveElement = document.activeElement;
    return () => {
      var _a;
      (_a = previouslyActiveElement.focus) == null ? void 0 : _a.call(previouslyActiveElement);
    };
  }, []);
  (0, import_react41.useEffect)(() => {
    if (contentRef.current) {
      const elementToFocus = contentRef.current.querySelector("[data-auto-focus]");
      if (elementToFocus) {
        elementToFocus.focus();
      } else {
        contentRef.current.focus();
      }
    }
  }, []);
  return import_react40.default.createElement(import_react40.default.Fragment, null, import_react40.default.createElement(
    "div",
    {
      onFocus: (0, import_react41.useCallback)(
        () => contentRef.current && moveFocusWithin(contentRef.current, "end"),
        []
      ),
      tabIndex: 0
    }
  ), import_react40.default.createElement(
    "div",
    {
      ref: contentRef,
      style: { outline: "none" },
      tabIndex: -1,
      ...props
    }
  ), import_react40.default.createElement(
    "div",
    {
      onFocus: (0, import_react41.useCallback)(
        () => contentRef.current && moveFocusWithin(contentRef.current, "start"),
        []
      ),
      tabIndex: 0
    }
  ));
}
var stopPropagation = (event) => event.stopPropagation();
function Dialog({ children, onClose, open, titleId }) {
  (0, import_react23.useEffect)(() => {
    const handleEscape = (event) => open && event.key === "Escape" && onClose();
    document.addEventListener("keydown", handleEscape);
    return () => document.removeEventListener("keydown", handleEscape);
  }, [open, onClose]);
  const [bodyScrollable, setBodyScrollable] = (0, import_react23.useState)(true);
  (0, import_react23.useEffect)(() => {
    setBodyScrollable(
      getComputedStyle(window.document.body).overflow !== "hidden"
    );
  }, []);
  const handleBackdropClick = (0, import_react23.useCallback)(() => onClose(), [onClose]);
  const themeRootProps = useThemeRootProps();
  const mobile = isMobile();
  return import_react23.default.createElement(import_react23.default.Fragment, null, open ? (0, import_react_dom.createPortal)(
    import_react23.default.createElement(Combination_default, { enabled: bodyScrollable }, import_react23.default.createElement(Box, { ...themeRootProps }, import_react23.default.createElement(
      Box,
      {
        ...themeRootProps,
        alignItems: mobile ? "flex-end" : "center",
        "aria-labelledby": titleId,
        "aria-modal": true,
        className: overlay,
        onClick: handleBackdropClick,
        position: "fixed",
        role: "dialog"
      },
      import_react23.default.createElement(
        FocusTrap,
        {
          className: content,
          onClick: stopPropagation,
          role: "document"
        },
        children
      )
    ))),
    document.body
  ) : null);
}
var bottomSheetOverrides = "_1ckjpok7";
var dialogContent = "_1ckjpok1 ju367vb6 ju367vdr ju367vp ju367vt ju367vv ju367vel ju367va ju367v15 ju367v6c ju367v8r";
var dialogContentCompactMode = "_1ckjpok4 _1ckjpok1 ju367vb6 ju367vdr ju367vp ju367vt ju367vv ju367vel ju367va ju367v15 ju367v6c ju367v8r";
var dialogContentMobile = "_1ckjpok6 ju367vq";
var dialogContentWideDesktop = "_1ckjpok3 _1ckjpok1 ju367vb6 ju367vdr ju367vp ju367vt ju367vv ju367vel ju367va ju367v15 ju367v6c ju367v8r";
var dialogContentWideMobile = "_1ckjpok2 _1ckjpok1 ju367vb6 ju367vdr ju367vp ju367vt ju367vv ju367vel ju367va ju367v15 ju367v6c ju367v8r";
function DialogContent({
  bottomSheetOnMobile = false,
  children,
  marginTop,
  padding = "16",
  paddingBottom,
  wide = false
}) {
  const mobile = isMobile();
  const modalSize = (0, import_react42.useContext)(ModalSizeContext);
  const compactModeEnabled = modalSize === ModalSizeOptions.COMPACT;
  return import_react42.default.createElement(Box, { marginTop }, import_react42.default.createElement(
    Box,
    {
      className: [
        wide ? mobile ? dialogContentWideMobile : compactModeEnabled ? dialogContentCompactMode : dialogContentWideDesktop : dialogContent,
        mobile ? dialogContentMobile : null,
        mobile && bottomSheetOnMobile ? bottomSheetOverrides : null
      ].join(" ")
    },
    import_react42.default.createElement(Box, { padding, paddingBottom: paddingBottom ?? padding }, children)
  ));
}
var units = ["k", "m", "b", "t"];
function toPrecision(number2, precision = 1) {
  return number2.toString().replace(new RegExp(`(.+\\.\\d{${precision}})\\d+`), "$1").replace(/(\.[1-9]*)0+$/, "$1").replace(/\.$/, "");
}
function abbreviateETHBalance(number2) {
  if (number2 < 1) return toPrecision(number2, 3);
  if (number2 < 10 ** 2) return toPrecision(number2, 2);
  if (number2 < 10 ** 4)
    return new Intl.NumberFormat().format(
      Number.parseFloat(toPrecision(number2, 1))
    );
  const decimalsDivisor = 10 ** 1;
  let result = String(number2);
  for (let i = units.length - 1; i >= 0; i--) {
    const size5 = 10 ** ((i + 1) * 3);
    if (size5 <= number2) {
      number2 = number2 * decimalsDivisor / size5 / decimalsDivisor;
      result = toPrecision(number2, 1) + units[i];
      break;
    }
  }
  return result;
}
function formatAddress(address) {
  const leadingChars = 4;
  const trailingChars = 4;
  return address.length < leadingChars + trailingChars ? address : `${address.substring(0, leadingChars)}…${address.substring(
    address.length - trailingChars
  )}`;
}
function formatENS(name) {
  if (!name) return "";
  const parts = name.split(".");
  const last = parts.pop();
  if (parts.join(".").length > 24) {
    return `${parts.join(".").substring(0, 24)}...`;
  }
  return `${parts.join(".")}.${last}`;
}
var CopiedIcon = () => import_react44.default.createElement(
  "svg",
  {
    fill: "none",
    height: "13",
    viewBox: "0 0 13 13",
    width: "13",
    xmlns: "http://www.w3.org/2000/svg"
  },
  import_react44.default.createElement("title", null, "Copied"),
  import_react44.default.createElement(
    "path",
    {
      d: "M4.94568 12.2646C5.41052 12.2646 5.77283 12.0869 6.01892 11.7109L12.39 1.96973C12.5677 1.69629 12.6429 1.44336 12.6429 1.2041C12.6429 0.561523 12.1644 0.0966797 11.5082 0.0966797C11.057 0.0966797 10.7767 0.260742 10.5033 0.691406L4.9115 9.50977L2.07458 5.98926C1.82166 5.68848 1.54822 5.55176 1.16541 5.55176C0.502319 5.55176 0.0238037 6.02344 0.0238037 6.66602C0.0238037 6.95312 0.112671 7.20605 0.358765 7.48633L3.88611 11.7588C4.18005 12.1074 4.50818 12.2646 4.94568 12.2646Z",
      fill: "currentColor"
    }
  )
);
var CopyIcon = () => import_react45.default.createElement(
  "svg",
  {
    fill: "none",
    height: "16",
    viewBox: "0 0 17 16",
    width: "17",
    xmlns: "http://www.w3.org/2000/svg"
  },
  import_react45.default.createElement("title", null, "Copy"),
  import_react45.default.createElement(
    "path",
    {
      d: "M3.04236 12.3027H4.18396V13.3008C4.18396 14.8525 5.03845 15.7002 6.59705 15.7002H13.6244C15.183 15.7002 16.0375 14.8525 16.0375 13.3008V6.24609C16.0375 4.69434 15.183 3.84668 13.6244 3.84668H12.4828V2.8418C12.4828 1.29688 11.6283 0.442383 10.0697 0.442383H3.04236C1.48376 0.442383 0.629272 1.29004 0.629272 2.8418V9.90332C0.629272 11.4551 1.48376 12.3027 3.04236 12.3027ZM3.23376 10.5391C2.68689 10.5391 2.39294 10.2656 2.39294 9.68457V3.06055C2.39294 2.47949 2.68689 2.21289 3.23376 2.21289H9.8783C10.4252 2.21289 10.7191 2.47949 10.7191 3.06055V3.84668H6.59705C5.03845 3.84668 4.18396 4.69434 4.18396 6.24609V10.5391H3.23376ZM6.78845 13.9365C6.24158 13.9365 5.94763 13.6699 5.94763 13.0889V6.45801C5.94763 5.87695 6.24158 5.61035 6.78845 5.61035H13.433C13.9799 5.61035 14.2738 5.87695 14.2738 6.45801V13.0889C14.2738 13.6699 13.9799 13.9365 13.433 13.9365H6.78845Z",
      fill: "currentColor"
    }
  )
);
var DisconnectIcon = () => import_react46.default.createElement(
  "svg",
  {
    fill: "none",
    height: "16",
    viewBox: "0 0 18 16",
    width: "18",
    xmlns: "http://www.w3.org/2000/svg"
  },
  import_react46.default.createElement("title", null, "Disconnect"),
  import_react46.default.createElement(
    "path",
    {
      d: "M2.67834 15.5908H9.99963C11.5514 15.5908 12.399 14.7432 12.399 13.1777V10.2656H10.6354V12.9863C10.6354 13.5332 10.3688 13.8271 9.78772 13.8271H2.89026C2.3092 13.8271 2.0426 13.5332 2.0426 12.9863V3.15625C2.0426 2.60254 2.3092 2.30859 2.89026 2.30859H9.78772C10.3688 2.30859 10.6354 2.60254 10.6354 3.15625V5.89746H12.399V2.95801C12.399 1.39941 11.5514 0.544922 9.99963 0.544922H2.67834C1.12659 0.544922 0.278931 1.39941 0.278931 2.95801V13.1777C0.278931 14.7432 1.12659 15.5908 2.67834 15.5908ZM7.43616 8.85059H14.0875L15.0924 8.78906L14.566 9.14453L13.6842 9.96484C13.5406 10.1016 13.4586 10.2861 13.4586 10.4844C13.4586 10.8398 13.7321 11.168 14.1217 11.168C14.3199 11.168 14.4635 11.0928 14.6002 10.9561L16.7809 8.68652C16.986 8.48145 17.0543 8.27637 17.0543 8.06445C17.0543 7.85254 16.986 7.64746 16.7809 7.43555L14.6002 5.17285C14.4635 5.03613 14.3199 4.9541 14.1217 4.9541C13.7321 4.9541 13.4586 5.27539 13.4586 5.6377C13.4586 5.83594 13.5406 6.02734 13.6842 6.15723L14.566 6.98438L15.0924 7.33984L14.0875 7.27148H7.43616C7.01917 7.27148 6.65686 7.62012 6.65686 8.06445C6.65686 8.50195 7.01917 8.85059 7.43616 8.85059Z",
      fill: "currentColor"
    }
  )
);
function useClearRecentTransactions() {
  const store = useTransactionStore();
  const { address } = useAccount();
  const chainId = useChainId();
  return (0, import_react48.useCallback)(() => {
    if (!address || !chainId) {
      throw new Error("No address or chain ID found");
    }
    store.clearTransactions(address, chainId);
  }, [store, address, chainId]);
}
var chainToExplorerUrl = (chain) => {
  var _a, _b;
  return (_b = (_a = chain == null ? void 0 : chain.blockExplorers) == null ? void 0 : _a.default) == null ? void 0 : _b.url;
};
var ExternalLinkIcon = () => import_react49.default.createElement(
  "svg",
  {
    fill: "none",
    height: "19",
    viewBox: "0 0 20 19",
    width: "20",
    xmlns: "http://www.w3.org/2000/svg"
  },
  import_react49.default.createElement("title", null, "Link"),
  import_react49.default.createElement(
    "path",
    {
      d: "M10 18.9443C15.0977 18.9443 19.2812 14.752 19.2812 9.6543C19.2812 4.56543 15.0889 0.373047 10 0.373047C4.90234 0.373047 0.71875 4.56543 0.71875 9.6543C0.71875 14.752 4.91113 18.9443 10 18.9443ZM10 16.6328C6.1416 16.6328 3.03906 13.5215 3.03906 9.6543C3.03906 5.7959 6.13281 2.68457 10 2.68457C13.8584 2.68457 16.9697 5.7959 16.9697 9.6543C16.9785 13.5215 13.8672 16.6328 10 16.6328ZM12.7158 12.1416C13.2432 12.1416 13.5684 11.7549 13.5684 11.1836V7.19336C13.5684 6.44629 13.1377 6.05957 12.417 6.05957H8.40918C7.8291 6.05957 7.45117 6.38477 7.45117 6.91211C7.45117 7.43945 7.8291 7.77344 8.40918 7.77344H9.69238L10.7207 7.63281L9.53418 8.67871L6.73047 11.4912C6.53711 11.6758 6.41406 11.9395 6.41406 12.2031C6.41406 12.7832 6.85352 13.1699 7.39844 13.1699C7.68848 13.1699 7.92578 13.0732 8.1543 12.8623L10.9316 10.0762L11.9775 8.89844L11.8545 9.98828V11.1836C11.8545 11.7725 12.1885 12.1416 12.7158 12.1416Z",
      fill: "currentColor"
    }
  )
);
var CancelIcon = () => import_react51.default.createElement(
  "svg",
  {
    fill: "none",
    height: "19",
    viewBox: "0 0 20 19",
    width: "20",
    xmlns: "http://www.w3.org/2000/svg"
  },
  import_react51.default.createElement("title", null, "Cancel"),
  import_react51.default.createElement(
    "path",
    {
      d: "M10 18.9443C15.0977 18.9443 19.2812 14.752 19.2812 9.6543C19.2812 4.56543 15.0889 0.373047 10 0.373047C4.90234 0.373047 0.71875 4.56543 0.71875 9.6543C0.71875 14.752 4.91113 18.9443 10 18.9443ZM10 16.6328C6.1416 16.6328 3.03906 13.5215 3.03906 9.6543C3.03906 5.7959 6.13281 2.68457 10 2.68457C13.8584 2.68457 16.9697 5.7959 16.9697 9.6543C16.9785 13.5215 13.8672 16.6328 10 16.6328ZM7.29297 13.3018C7.58301 13.3018 7.81152 13.2139 7.99609 13.0205L10 11.0166L12.0127 13.0205C12.1973 13.2051 12.4258 13.3018 12.707 13.3018C13.2432 13.3018 13.6562 12.8887 13.6562 12.3525C13.6562 12.0977 13.5508 11.8691 13.3662 11.6934L11.3535 9.67188L13.375 7.6416C13.5596 7.44824 13.6562 7.22852 13.6562 6.98242C13.6562 6.44629 13.2432 6.0332 12.7158 6.0332C12.4346 6.0332 12.2148 6.12109 12.0215 6.31445L10 8.32715L7.9873 6.32324C7.80273 6.12988 7.58301 6.04199 7.29297 6.04199C6.76562 6.04199 6.35254 6.45508 6.35254 6.99121C6.35254 7.2373 6.44922 7.46582 6.63379 7.6416L8.65527 9.67188L6.63379 11.6934C6.44922 11.8691 6.35254 12.1064 6.35254 12.3525C6.35254 12.8887 6.76562 13.3018 7.29297 13.3018Z",
      fill: "currentColor"
    }
  )
);
var SuccessIcon = () => import_react52.default.createElement(
  "svg",
  {
    fill: "none",
    height: "20",
    viewBox: "0 0 20 20",
    width: "20",
    xmlns: "http://www.w3.org/2000/svg"
  },
  import_react52.default.createElement("title", null, "Success"),
  import_react52.default.createElement(
    "path",
    {
      d: "M10 19.4443C15.0977 19.4443 19.2812 15.252 19.2812 10.1543C19.2812 5.06543 15.0889 0.873047 10 0.873047C4.90234 0.873047 0.71875 5.06543 0.71875 10.1543C0.71875 15.252 4.91113 19.4443 10 19.4443ZM10 17.1328C6.1416 17.1328 3.03906 14.0215 3.03906 10.1543C3.03906 6.2959 6.13281 3.18457 10 3.18457C13.8584 3.18457 16.9697 6.2959 16.9697 10.1543C16.9785 14.0215 13.8672 17.1328 10 17.1328ZM9.07715 14.3379C9.4375 14.3379 9.7627 14.1533 9.97363 13.8369L13.7441 8.00977C13.8848 7.79883 13.9814 7.5791 13.9814 7.36816C13.9814 6.84961 13.5244 6.48926 13.0322 6.48926C12.707 6.48926 12.4258 6.66504 12.2148 7.0166L9.05957 12.0967L7.5918 10.2949C7.37207 10.0225 7.13477 9.9082 6.84473 9.9082C6.33496 9.9082 5.92188 10.3125 5.92188 10.8223C5.92188 11.0684 6.00098 11.2793 6.18555 11.5078L8.1543 13.8545C8.40918 14.1709 8.70801 14.3379 9.07715 14.3379Z",
      fill: "currentColor"
    }
  )
);
var getTxStatusIcon = (status) => {
  switch (status) {
    case "pending":
      return SpinnerIcon;
    case "confirmed":
      return SuccessIcon;
    case "failed":
      return CancelIcon;
    default:
      return SpinnerIcon;
  }
};
function TxItem({ tx }) {
  const mobile = isMobile();
  const Icon = getTxStatusIcon(tx.status);
  const color = tx.status === "failed" ? "error" : "accentColor";
  const { chain: activeChain } = useAccount();
  const confirmationStatus = tx.status === "confirmed" ? "Confirmed" : tx.status === "failed" ? "Failed" : "Pending";
  const explorerLink = chainToExplorerUrl(activeChain);
  return import_react50.default.createElement(import_react50.default.Fragment, null, import_react50.default.createElement(
    Box,
    {
      ...explorerLink ? {
        as: "a",
        background: { hover: "profileForeground" },
        borderRadius: "menuButton",
        className: touchableStyles({ active: "shrink" }),
        href: `${explorerLink}/tx/${tx.hash}`,
        rel: "noreferrer noopener",
        target: "_blank",
        transition: "default"
      } : {},
      color: "modalText",
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between",
      padding: "8",
      width: "full"
    },
    import_react50.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "row",
        gap: mobile ? "16" : "14"
      },
      import_react50.default.createElement(Box, { color }, import_react50.default.createElement(Icon, null)),
      import_react50.default.createElement(Box, { display: "flex", flexDirection: "column", gap: mobile ? "3" : "1" }, import_react50.default.createElement(Box, null, import_react50.default.createElement(
        Text,
        {
          color: "modalText",
          font: "body",
          size: mobile ? "16" : "14",
          weight: "bold"
        },
        tx == null ? void 0 : tx.description
      )), import_react50.default.createElement(Box, null, import_react50.default.createElement(
        Text,
        {
          color: tx.status === "pending" ? "modalTextSecondary" : color,
          font: "body",
          size: "14",
          weight: mobile ? "medium" : "regular"
        },
        confirmationStatus
      )))
    ),
    explorerLink && import_react50.default.createElement(Box, { alignItems: "center", color: "modalTextDim", display: "flex" }, import_react50.default.createElement(ExternalLinkIcon, null))
  ));
}
var NUMBER_OF_VISIBLE_TXS = 3;
function TxList({ address }) {
  const recentTransactions = useRecentTransactions();
  const clearRecentTransactions = useClearRecentTransactions();
  const { chain: activeChain } = useAccount();
  const explorerLink = chainToExplorerUrl(activeChain);
  const visibleTxs = recentTransactions.slice(0, NUMBER_OF_VISIBLE_TXS);
  const hasTransactions = visibleTxs.length > 0;
  const mobile = isMobile();
  const { appName } = (0, import_react47.useContext)(AppContext);
  const { i18n: i18n2 } = (0, import_react47.useContext)(I18nContext);
  return import_react47.default.createElement(import_react47.default.Fragment, null, import_react47.default.createElement(
    Box,
    {
      display: "flex",
      flexDirection: "column",
      gap: "10",
      paddingBottom: "2",
      paddingTop: "16",
      paddingX: mobile ? "8" : "18"
    },
    hasTransactions && import_react47.default.createElement(
      Box,
      {
        paddingBottom: mobile ? "4" : "0",
        paddingTop: "8",
        paddingX: mobile ? "12" : "6"
      },
      import_react47.default.createElement(Box, { display: "flex", justifyContent: "space-between" }, import_react47.default.createElement(
        Text,
        {
          color: "modalTextSecondary",
          size: mobile ? "16" : "14",
          weight: "semibold"
        },
        i18n2.t("profile.transactions.recent.title")
      ), import_react47.default.createElement(
        Box,
        {
          style: {
            marginBottom: -6,
            marginLeft: -10,
            marginRight: -10,
            marginTop: -6
          }
        },
        import_react47.default.createElement(
          Box,
          {
            as: "button",
            background: {
              hover: "profileForeground"
            },
            borderRadius: "actionButton",
            className: touchableStyles({ active: "shrink" }),
            onClick: clearRecentTransactions,
            paddingX: mobile ? "8" : "12",
            paddingY: mobile ? "4" : "5",
            transition: "default",
            type: "button"
          },
          import_react47.default.createElement(
            Text,
            {
              color: "modalTextSecondary",
              size: mobile ? "16" : "14",
              weight: "semibold"
            },
            i18n2.t("profile.transactions.clear.label")
          )
        )
      ))
    ),
    import_react47.default.createElement(Box, { display: "flex", flexDirection: "column", gap: "4" }, hasTransactions ? visibleTxs.map((tx) => import_react47.default.createElement(TxItem, { key: tx.hash, tx })) : import_react47.default.createElement(import_react47.default.Fragment, null, import_react47.default.createElement(Box, { padding: mobile ? "12" : "8" }, import_react47.default.createElement(
      Text,
      {
        color: "modalTextDim",
        size: mobile ? "16" : "14",
        weight: mobile ? "medium" : "bold"
      },
      appName ? i18n2.t("profile.transactions.description", {
        appName
      }) : i18n2.t("profile.transactions.description_fallback")
    )), mobile && import_react47.default.createElement(
      Box,
      {
        background: "generalBorderDim",
        height: "1",
        marginX: "12",
        marginY: "8"
      }
    )))
  ), explorerLink && import_react47.default.createElement(Box, { paddingBottom: "18", paddingX: mobile ? "8" : "18" }, import_react47.default.createElement(
    Box,
    {
      alignItems: "center",
      as: "a",
      background: { hover: "profileForeground" },
      borderRadius: "menuButton",
      className: touchableStyles({ active: "shrink" }),
      color: "modalTextDim",
      display: "flex",
      flexDirection: "row",
      href: `${explorerLink}/address/${address}`,
      justifyContent: "space-between",
      paddingX: "8",
      paddingY: "12",
      rel: "noreferrer noopener",
      style: { willChange: "transform" },
      target: "_blank",
      transition: "default",
      width: "full",
      ...mobile ? { paddingLeft: "12" } : {}
    },
    import_react47.default.createElement(
      Text,
      {
        color: "modalText",
        font: "body",
        size: mobile ? "16" : "14",
        weight: mobile ? "semibold" : "bold"
      },
      i18n2.t("profile.explorer.label")
    ),
    import_react47.default.createElement(ExternalLinkIcon, null)
  )));
}
function ProfileDetailsAction({
  action,
  icon,
  label,
  testId,
  url
}) {
  const mobile = isMobile();
  return import_react53.default.createElement(
    Box,
    {
      ...url ? { as: "a", href: url, rel: "noreferrer noopener", target: "_blank" } : { as: "button", type: "button" },
      background: {
        base: "profileAction",
        ...!mobile ? { hover: "profileActionHover" } : {}
      },
      borderRadius: "menuButton",
      boxShadow: "profileDetailsAction",
      className: touchableStyles({
        active: "shrinkSm",
        hover: !mobile ? "grow" : void 0
      }),
      display: "flex",
      onClick: action,
      padding: mobile ? "6" : "8",
      style: { willChange: "transform" },
      testId,
      transition: "default",
      width: "full"
    },
    import_react53.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "1",
        justifyContent: "center",
        paddingTop: "2",
        width: "full"
      },
      import_react53.default.createElement(Box, { color: "modalText", height: "max" }, icon),
      import_react53.default.createElement(Box, null, import_react53.default.createElement(Text, { color: "modalText", size: mobile ? "12" : "13", weight: "semibold" }, label))
    )
  );
}
function ProfileDetails({
  address,
  ensAvatar,
  ensName,
  balance,
  onClose,
  onDisconnect
}) {
  const showRecentTransactions = (0, import_react43.useContext)(ShowRecentTransactionsContext);
  const [copiedAddress, setCopiedAddress] = (0, import_react43.useState)(false);
  const copyAddressAction = (0, import_react43.useCallback)(() => {
    if (address) {
      navigator.clipboard.writeText(address);
      setCopiedAddress(true);
    }
  }, [address]);
  (0, import_react43.useEffect)(() => {
    if (copiedAddress) {
      const timer = setTimeout(() => {
        setCopiedAddress(false);
      }, 1500);
      return () => clearTimeout(timer);
    }
  }, [copiedAddress]);
  if (!address) {
    return null;
  }
  const accountName = ensName ? formatENS(ensName) : formatAddress(address);
  const ethBalance = balance == null ? void 0 : balance.formatted;
  const displayBalance = ethBalance ? abbreviateETHBalance(Number.parseFloat(ethBalance)) : void 0;
  const titleId = "rk_profile_title";
  const mobile = isMobile();
  const { i18n: i18n2 } = (0, import_react43.useContext)(I18nContext);
  return import_react43.default.createElement(import_react43.default.Fragment, null, import_react43.default.createElement(Box, { display: "flex", flexDirection: "column" }, import_react43.default.createElement(Box, { background: "profileForeground", padding: "16" }, import_react43.default.createElement(
    Box,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: mobile ? "16" : "12",
      justifyContent: "center",
      margin: "8",
      style: { textAlign: "center" }
    },
    import_react43.default.createElement(
      Box,
      {
        style: {
          position: "absolute",
          right: 16,
          top: 16,
          willChange: "transform"
        }
      },
      import_react43.default.createElement(CloseButton, { onClose })
    ),
    " ",
    import_react43.default.createElement(Box, { marginTop: mobile ? "24" : "0" }, import_react43.default.createElement(
      Avatar,
      {
        address,
        imageUrl: ensAvatar,
        size: mobile ? 82 : 74
      }
    )),
    import_react43.default.createElement(
      Box,
      {
        display: "flex",
        flexDirection: "column",
        gap: mobile ? "4" : "0",
        textAlign: "center"
      },
      import_react43.default.createElement(Box, { textAlign: "center" }, import_react43.default.createElement(
        Text,
        {
          as: "h1",
          color: "modalText",
          id: titleId,
          size: mobile ? "20" : "18",
          weight: "heavy"
        },
        accountName
      )),
      !!balance && import_react43.default.createElement(Box, { textAlign: "center" }, import_react43.default.createElement(
        Text,
        {
          as: "h1",
          color: "modalTextSecondary",
          id: titleId,
          size: mobile ? "16" : "14",
          weight: "semibold"
        },
        displayBalance,
        " ",
        balance.symbol
      ))
    )
  ), import_react43.default.createElement(
    Box,
    {
      display: "flex",
      flexDirection: "row",
      gap: "8",
      margin: "2",
      marginTop: "16"
    },
    import_react43.default.createElement(
      ProfileDetailsAction,
      {
        action: copyAddressAction,
        icon: copiedAddress ? import_react43.default.createElement(CopiedIcon, null) : import_react43.default.createElement(CopyIcon, null),
        label: copiedAddress ? i18n2.t("profile.copy_address.copied") : i18n2.t("profile.copy_address.label")
      }
    ),
    import_react43.default.createElement(
      ProfileDetailsAction,
      {
        action: onDisconnect,
        icon: import_react43.default.createElement(DisconnectIcon, null),
        label: i18n2.t("profile.disconnect.label"),
        testId: "disconnect-button"
      }
    )
  )), showRecentTransactions && import_react43.default.createElement(import_react43.default.Fragment, null, import_react43.default.createElement(Box, { background: "generalBorder", height: "1", marginTop: "-1" }), import_react43.default.createElement(Box, null, import_react43.default.createElement(TxList, { address })))));
}
function AccountModal({ onClose, open }) {
  const { address } = useAccount();
  const { balance, ensAvatar, ensName } = useProfile({
    address,
    includeBalance: open
  });
  const { disconnect } = useDisconnect();
  if (!address) {
    return null;
  }
  const titleId = "rk_account_modal_title";
  return import_react22.default.createElement(import_react22.default.Fragment, null, address && import_react22.default.createElement(Dialog, { onClose, open, titleId }, import_react22.default.createElement(DialogContent, { bottomSheetOnMobile: true, padding: "0" }, import_react22.default.createElement(
    ProfileDetails,
    {
      address,
      ensAvatar,
      ensName,
      balance,
      onClose,
      onDisconnect: disconnect
    }
  ))));
}
var DisconnectSqIcon = ({ size: size5 }) => import_react55.default.createElement(
  "svg",
  {
    fill: "none",
    height: size5,
    viewBox: "0 0 28 28",
    width: size5,
    xmlns: "http://www.w3.org/2000/svg"
  },
  import_react55.default.createElement("title", null, "Disconnect"),
  import_react55.default.createElement(
    "path",
    {
      d: "M6.742 22.195h8.367c1.774 0 2.743-.968 2.743-2.758V16.11h-2.016v3.11c0 .625-.305.96-.969.96H6.984c-.664 0-.968-.335-.968-.96V7.984c0-.632.304-.968.968-.968h7.883c.664 0 .969.336.969.968v3.133h2.016v-3.36c0-1.78-.97-2.757-2.743-2.757H6.742C4.97 5 4 5.977 4 7.758v11.68c0 1.789.969 2.757 2.742 2.757Zm5.438-7.703h7.601l1.149-.07-.602.406-1.008.938a.816.816 0 0 0-.258.593c0 .407.313.782.758.782.227 0 .39-.086.547-.243l2.492-2.593c.235-.235.313-.47.313-.711 0-.242-.078-.477-.313-.719l-2.492-2.586c-.156-.156-.32-.25-.547-.25-.445 0-.758.367-.758.781 0 .227.094.446.258.594l1.008.945.602.407-1.149-.079H12.18a.904.904 0 0 0 0 1.805Z",
      fill: "currentColor"
    }
  )
);
var unsetBackgroundOnHover = "v9horb0";
var MenuButton = import_react56.default.forwardRef(
  ({
    children,
    currentlySelected = false,
    onClick,
    testId,
    ...urlProps
  }, ref) => {
    const mobile = isMobile();
    return import_react56.default.createElement(
      Box,
      {
        as: "button",
        borderRadius: "menuButton",
        disabled: currentlySelected,
        display: "flex",
        onClick,
        ref,
        testId,
        type: "button"
      },
      import_react56.default.createElement(
        Box,
        {
          borderRadius: "menuButton",
          className: [
            mobile ? unsetBackgroundOnHover : void 0,
            !currentlySelected && touchableStyles({ active: "shrink" })
          ],
          padding: mobile ? "8" : "6",
          transition: "default",
          width: "full",
          ...currentlySelected ? {
            background: "accentColor",
            borderColor: "selectedOptionBorder",
            borderStyle: "solid",
            borderWidth: "1",
            boxShadow: "selectedOption",
            color: "accentColorForeground"
          } : {
            background: { hover: "menuItemBackground" },
            color: "modalText",
            transition: "default"
          },
          ...urlProps
        },
        children
      )
    );
  }
);
MenuButton.displayName = "MenuButton";
var Chain = ({
  chainId,
  currentChainId,
  switchChain,
  chainIconSize,
  isLoading,
  src: src7,
  name,
  iconBackground,
  idx
}) => {
  const mobile = isMobile();
  const { i18n: i18n2 } = (0, import_react57.useContext)(I18nContext);
  const rainbowkitChains = useRainbowKitChains();
  const isCurrentChain = currentChainId === chainId;
  return import_react57.default.createElement(import_react57.Fragment, null, import_react57.default.createElement(
    MenuButton,
    {
      currentlySelected: isCurrentChain,
      onClick: isCurrentChain ? void 0 : () => switchChain({ chainId }),
      testId: `chain-option-${chainId}`
    },
    import_react57.default.createElement(Box, { fontFamily: "body", fontSize: "16", fontWeight: "bold" }, import_react57.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between"
      },
      import_react57.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "row",
          gap: "4",
          height: chainIconSize
        },
        src7 && import_react57.default.createElement(Box, { height: "full", marginRight: "8" }, import_react57.default.createElement(
          AsyncImage,
          {
            alt: name,
            background: iconBackground,
            borderRadius: "full",
            height: chainIconSize,
            src: src7,
            width: chainIconSize,
            testId: `chain-option-${chainId}-icon`
          }
        )),
        import_react57.default.createElement("div", null, name ?? name)
      ),
      isCurrentChain && import_react57.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "row",
          marginRight: "6"
        },
        import_react57.default.createElement(Text, { color: "accentColorForeground", size: "14", weight: "medium" }, i18n2.t("chains.connected")),
        import_react57.default.createElement(
          Box,
          {
            background: "connectionIndicator",
            borderColor: "selectedOptionBorder",
            borderRadius: "full",
            borderStyle: "solid",
            borderWidth: "1",
            height: "8",
            marginLeft: "8",
            width: "8"
          }
        )
      ),
      isLoading && import_react57.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "row",
          marginRight: "6"
        },
        import_react57.default.createElement(Text, { color: "modalText", size: "14", weight: "medium" }, i18n2.t("chains.confirm")),
        import_react57.default.createElement(
          Box,
          {
            background: "standby",
            borderRadius: "full",
            height: "8",
            marginLeft: "8",
            width: "8"
          }
        )
      )
    ))
  ), mobile && idx < rainbowkitChains.length - 1 && import_react57.default.createElement(Box, { background: "generalBorderDim", height: "1", marginX: "8" }));
};
var Chain_default = Chain;
var DesktopScrollClassName = "_18dqw9x0";
var MobileScrollClassName = "_18dqw9x1";
function ChainModal({ onClose, open }) {
  const { chainId } = useAccount();
  const { chains } = useConfig();
  const [pendingChainId, setPendingChainId] = (0, import_react54.useState)(null);
  const { switchChain } = useSwitchChain({
    mutation: {
      onMutate: ({ chainId: _chainId }) => {
        setPendingChainId(_chainId);
      },
      onSuccess: () => {
        if (pendingChainId) setPendingChainId(null);
      },
      onError: () => {
        if (pendingChainId) setPendingChainId(null);
      },
      onSettled: () => {
        onClose();
      }
    }
  });
  const { i18n: i18n2 } = (0, import_react54.useContext)(I18nContext);
  const { disconnect } = useDisconnect();
  const titleId = "rk_chain_modal_title";
  const mobile = isMobile();
  const isCurrentChainSupported = chains.some((chain) => chain.id === chainId);
  const chainIconSize = mobile ? "36" : "28";
  const rainbowkitChains = useRainbowKitChains();
  if (!chainId) {
    return null;
  }
  return import_react54.default.createElement(Dialog, { onClose, open, titleId }, import_react54.default.createElement(DialogContent, { bottomSheetOnMobile: true, paddingBottom: "0" }, import_react54.default.createElement(Box, { display: "flex", flexDirection: "column", gap: "14" }, import_react54.default.createElement(
    Box,
    {
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between"
    },
    mobile && import_react54.default.createElement(Box, { width: "30" }),
    import_react54.default.createElement(Box, { paddingBottom: "0", paddingLeft: "8", paddingTop: "4" }, import_react54.default.createElement(
      Text,
      {
        as: "h1",
        color: "modalText",
        id: titleId,
        size: mobile ? "20" : "18",
        weight: "heavy"
      },
      i18n2.t("chains.title")
    )),
    import_react54.default.createElement(CloseButton, { onClose })
  ), !isCurrentChainSupported && import_react54.default.createElement(Box, { marginX: "8", textAlign: mobile ? "center" : "left" }, import_react54.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "medium" }, i18n2.t("chains.wrong_network"))), import_react54.default.createElement(
    Box,
    {
      className: mobile ? MobileScrollClassName : DesktopScrollClassName,
      display: "flex",
      flexDirection: "column",
      gap: "4",
      padding: "2",
      paddingBottom: "16"
    },
    rainbowkitChains.map(
      ({ iconBackground, iconUrl, id, name }, idx) => {
        return import_react54.default.createElement(
          Chain_default,
          {
            key: id,
            chainId: id,
            currentChainId: chainId,
            switchChain,
            chainIconSize,
            isLoading: pendingChainId === id,
            src: iconUrl,
            name,
            iconBackground,
            idx
          }
        );
      }
    ),
    !isCurrentChainSupported && import_react54.default.createElement(import_react54.default.Fragment, null, import_react54.default.createElement(Box, { background: "generalBorderDim", height: "1", marginX: "8" }), import_react54.default.createElement(
      MenuButton,
      {
        onClick: () => disconnect(),
        testId: "chain-option-disconnect"
      },
      import_react54.default.createElement(
        Box,
        {
          color: "error",
          fontFamily: "body",
          fontSize: "16",
          fontWeight: "bold"
        },
        import_react54.default.createElement(
          Box,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            justifyContent: "space-between"
          },
          import_react54.default.createElement(
            Box,
            {
              alignItems: "center",
              display: "flex",
              flexDirection: "row",
              gap: "4",
              height: chainIconSize
            },
            import_react54.default.createElement(
              Box,
              {
                alignItems: "center",
                color: "error",
                height: chainIconSize,
                justifyContent: "center",
                marginRight: "8"
              },
              import_react54.default.createElement(DisconnectSqIcon, { size: Number(chainIconSize) })
            ),
            import_react54.default.createElement("div", null, i18n2.t("chains.disconnect"))
          )
        )
      )
    ))
  ))));
}
function groupBy(items, getKey2) {
  const groupedItems = {};
  for (const item of items) {
    const key = getKey2(item);
    if (!key) {
      continue;
    }
    if (!groupedItems[key]) {
      groupedItems[key] = [];
    }
    groupedItems[key].push(item);
  }
  return groupedItems;
}
var DisclaimerLink = ({
  children,
  href
}) => {
  return import_react62.default.createElement(
    Box,
    {
      as: "a",
      color: "accentColor",
      href,
      rel: "noreferrer",
      target: "_blank"
    },
    children
  );
};
var DisclaimerText = ({ children }) => {
  return import_react63.default.createElement(Text, { color: "modalTextSecondary", size: "12", weight: "medium" }, children);
};
function ConnectModalIntro({
  compactModeEnabled = false,
  getWallet
}) {
  const { disclaimer: Disclaimer, learnMoreUrl } = (0, import_react61.useContext)(AppContext);
  const { i18n: i18n2 } = (0, import_react61.useContext)(I18nContext);
  return import_react61.default.createElement(import_react61.default.Fragment, null, import_react61.default.createElement(
    Box,
    {
      alignItems: "center",
      color: "accentColor",
      display: "flex",
      flexDirection: "column",
      height: "full",
      justifyContent: "space-around"
    },
    import_react61.default.createElement(Box, { marginBottom: "10" }, !compactModeEnabled && import_react61.default.createElement(Text, { color: "modalText", size: "18", weight: "heavy" }, i18n2.t("intro.title"))),
    import_react61.default.createElement(
      Box,
      {
        display: "flex",
        flexDirection: "column",
        gap: "32",
        justifyContent: "center",
        marginY: "20",
        style: { maxWidth: 312 }
      },
      import_react61.default.createElement(Box, { alignItems: "center", display: "flex", flexDirection: "row", gap: "16" }, import_react61.default.createElement(Box, { borderRadius: "6", height: "48", minWidth: "48", width: "48" }, import_react61.default.createElement(AssetsIcon, null)), import_react61.default.createElement(Box, { display: "flex", flexDirection: "column", gap: "4" }, import_react61.default.createElement(Text, { color: "modalText", size: "14", weight: "bold" }, i18n2.t("intro.digital_asset.title")), import_react61.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "medium" }, i18n2.t("intro.digital_asset.description")))),
      import_react61.default.createElement(Box, { alignItems: "center", display: "flex", flexDirection: "row", gap: "16" }, import_react61.default.createElement(Box, { borderRadius: "6", height: "48", minWidth: "48", width: "48" }, import_react61.default.createElement(LoginIcon, null)), import_react61.default.createElement(Box, { display: "flex", flexDirection: "column", gap: "4" }, import_react61.default.createElement(Text, { color: "modalText", size: "14", weight: "bold" }, i18n2.t("intro.login.title")), import_react61.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "medium" }, i18n2.t("intro.login.description"))))
    ),
    import_react61.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        margin: "10"
      },
      import_react61.default.createElement(ActionButton, { label: i18n2.t("intro.get.label"), onClick: getWallet }),
      import_react61.default.createElement(
        Box,
        {
          as: "a",
          className: touchableStyles({ active: "shrink", hover: "grow" }),
          display: "block",
          href: learnMoreUrl,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        import_react61.default.createElement(Text, { color: "accentColor", size: "14", weight: "bold" }, i18n2.t("intro.learn_more.label"))
      )
    ),
    Disclaimer && !compactModeEnabled && import_react61.default.createElement(Box, { marginBottom: "8", marginTop: "12", textAlign: "center" }, import_react61.default.createElement(Disclaimer, { Link: DisclaimerLink, Text: DisclaimerText }))
  ));
}
var BackIcon = () => import_react64.default.createElement(
  "svg",
  {
    fill: "none",
    height: "17",
    viewBox: "0 0 11 17",
    width: "11",
    xmlns: "http://www.w3.org/2000/svg"
  },
  import_react64.default.createElement("title", null, "Back"),
  import_react64.default.createElement(
    "path",
    {
      d: "M0.99707 8.6543C0.99707 9.08496 1.15527 9.44531 1.51562 9.79688L8.16016 16.3096C8.43262 16.5732 8.74902 16.7051 9.13574 16.7051C9.90918 16.7051 10.5508 16.0811 10.5508 15.3076C10.5508 14.9121 10.3838 14.5605 10.0938 14.2705L4.30176 8.64551L10.0938 3.0293C10.3838 2.74805 10.5508 2.3877 10.5508 2.00098C10.5508 1.23633 9.90918 0.603516 9.13574 0.603516C8.74902 0.603516 8.43262 0.735352 8.16016 0.999023L1.51562 7.51172C1.15527 7.85449 1.00586 8.21484 0.99707 8.6543Z",
      fill: "currentColor"
    }
  )
);
var InfoIcon = () => import_react66.default.createElement(
  "svg",
  {
    fill: "none",
    height: "12",
    viewBox: "0 0 8 12",
    width: "8",
    xmlns: "http://www.w3.org/2000/svg"
  },
  import_react66.default.createElement("title", null, "Info"),
  import_react66.default.createElement(
    "path",
    {
      d: "M3.64258 7.99609C4.19336 7.99609 4.5625 7.73828 4.68555 7.24609C4.69141 7.21094 4.70312 7.16406 4.70898 7.13477C4.80859 6.60742 5.05469 6.35547 6.04492 5.76367C7.14648 5.10156 7.67969 4.3457 7.67969 3.24414C7.67969 1.39844 6.17383 0.255859 3.95898 0.255859C2.32422 0.255859 1.05859 0.894531 0.548828 1.86719C0.396484 2.14844 0.320312 2.44727 0.320312 2.74023C0.314453 3.37305 0.742188 3.79492 1.42188 3.79492C1.91406 3.79492 2.33594 3.54883 2.53516 3.11523C2.78711 2.47656 3.23242 2.21289 3.83594 2.21289C4.55664 2.21289 5.10742 2.65234 5.10742 3.29102C5.10742 3.9707 4.7793 4.29883 3.81836 4.87891C3.02148 5.36523 2.50586 5.92773 2.50586 6.76562V6.90039C2.50586 7.55664 2.96289 7.99609 3.64258 7.99609ZM3.67188 11.4473C4.42773 11.4473 5.04297 10.8672 5.04297 10.1406C5.04297 9.41406 4.42773 8.83984 3.67188 8.83984C2.91602 8.83984 2.30664 9.41406 2.30664 10.1406C2.30664 10.8672 2.91602 11.4473 3.67188 11.4473Z",
      fill: "currentColor"
    }
  )
);
var InfoButton = ({
  "aria-label": ariaLabel = "Info",
  onClick
}) => {
  const mobile = isMobile();
  return import_react65.default.createElement(
    Box,
    {
      alignItems: "center",
      "aria-label": ariaLabel,
      as: "button",
      background: "closeButtonBackground",
      borderColor: "actionButtonBorder",
      borderRadius: "full",
      borderStyle: "solid",
      borderWidth: mobile ? "0" : "1",
      className: touchableStyles({ active: "shrinkSm", hover: "growLg" }),
      color: "closeButton",
      display: "flex",
      height: mobile ? "30" : "28",
      justifyContent: "center",
      onClick,
      style: { willChange: "transform" },
      transition: "default",
      type: "button",
      width: mobile ? "30" : "28"
    },
    import_react65.default.createElement(InfoIcon, null)
  );
};
var useCoolMode = (imageUrl) => {
  const ref = (0, import_react68.useRef)(null);
  const coolModeEnabled = (0, import_react68.useContext)(CoolModeContext);
  const resolvedImageUrl = useAsyncImage(imageUrl);
  (0, import_react68.useEffect)(() => {
    if (coolModeEnabled && ref.current && resolvedImageUrl) {
      return makeElementCool(ref.current, resolvedImageUrl);
    }
  }, [coolModeEnabled, resolvedImageUrl]);
  return ref;
};
var getContainer = () => {
  const id = "_rk_coolMode";
  const existingContainer = document.getElementById(id);
  if (existingContainer) {
    return existingContainer;
  }
  const container = document.createElement("div");
  container.setAttribute("id", id);
  container.setAttribute(
    "style",
    [
      "overflow:hidden",
      "position:fixed",
      "height:100%",
      "top:0",
      "left:0",
      "right:0",
      "bottom:0",
      "pointer-events:none",
      "z-index:2147483647"
    ].join(";")
  );
  document.body.appendChild(container);
  return container;
};
var instanceCounter = 0;
function makeElementCool(element2, imageUrl) {
  instanceCounter++;
  const sizes = [15, 20, 25, 35, 45];
  const limit2 = 35;
  let particles = [];
  let autoAddParticle = false;
  let mouseX = 0;
  let mouseY = 0;
  const container = getContainer();
  function createParticle() {
    const size5 = sizes[Math.floor(Math.random() * sizes.length)];
    const speedHorz = Math.random() * 10;
    const speedUp = Math.random() * 25;
    const spinVal = Math.random() * 360;
    const spinSpeed = Math.random() * 35 * (Math.random() <= 0.5 ? -1 : 1);
    const top = mouseY - size5 / 2;
    const left = mouseX - size5 / 2;
    const direction = Math.random() <= 0.5 ? -1 : 1;
    const particle = document.createElement("div");
    particle.innerHTML = `<img src="${imageUrl}" width="${size5}" height="${size5}" style="border-radius: 25%">`;
    particle.setAttribute(
      "style",
      [
        "position:absolute",
        "will-change:transform",
        `top:${top}px`,
        `left:${left}px`,
        `transform:rotate(${spinVal}deg)`
      ].join(";")
    );
    container.appendChild(particle);
    particles.push({
      direction,
      element: particle,
      left,
      size: size5,
      speedHorz,
      speedUp,
      spinSpeed,
      spinVal,
      top
    });
  }
  function updateParticles() {
    for (const p of particles) {
      p.left = p.left - p.speedHorz * p.direction;
      p.top = p.top - p.speedUp;
      p.speedUp = Math.min(p.size, p.speedUp - 1);
      p.spinVal = p.spinVal + p.spinSpeed;
      if (p.top >= Math.max(window.innerHeight, document.body.clientHeight) + p.size) {
        particles = particles.filter((o) => o !== p);
        p.element.remove();
      }
      p.element.setAttribute(
        "style",
        [
          "position:absolute",
          "will-change:transform",
          `top:${p.top}px`,
          `left:${p.left}px`,
          `transform:rotate(${p.spinVal}deg)`
        ].join(";")
      );
    }
  }
  let animationFrame;
  function loop() {
    if (autoAddParticle && particles.length < limit2) {
      createParticle();
    }
    updateParticles();
    animationFrame = requestAnimationFrame(loop);
  }
  loop();
  const isTouchInteraction = "ontouchstart" in window || // @ts-expect-error
  navigator.msMaxTouchPoints;
  const tap = isTouchInteraction ? "touchstart" : "mousedown";
  const tapEnd = isTouchInteraction ? "touchend" : "mouseup";
  const move = isTouchInteraction ? "touchmove" : "mousemove";
  const updateMousePosition = (e) => {
    var _a, _b;
    if ("touches" in e) {
      mouseX = (_a = e.touches) == null ? void 0 : _a[0].clientX;
      mouseY = (_b = e.touches) == null ? void 0 : _b[0].clientY;
    } else {
      mouseX = e.clientX;
      mouseY = e.clientY;
    }
  };
  const tapHandler = (e) => {
    updateMousePosition(e);
    autoAddParticle = true;
  };
  const disableAutoAddParticle = () => {
    autoAddParticle = false;
  };
  element2.addEventListener(move, updateMousePosition, { passive: false });
  element2.addEventListener(tap, tapHandler);
  element2.addEventListener(tapEnd, disableAutoAddParticle);
  element2.addEventListener("mouseleave", disableAutoAddParticle);
  return () => {
    element2.removeEventListener(move, updateMousePosition);
    element2.removeEventListener(tap, tapHandler);
    element2.removeEventListener(tapEnd, disableAutoAddParticle);
    element2.removeEventListener("mouseleave", disableAutoAddParticle);
    const interval = setInterval(() => {
      if (animationFrame && particles.length === 0) {
        cancelAnimationFrame(animationFrame);
        clearInterval(interval);
        if (--instanceCounter === 0) {
          container.remove();
        }
      }
    }, 500);
  };
}
var transparentBorder = "g5kl0l0";
var ModalSelection = ({
  as = "button",
  currentlySelected = false,
  iconBackground,
  iconUrl,
  name,
  onClick,
  ready,
  recent,
  testId,
  isRainbowKitConnector: isRainbowKitConnector2,
  ...urlProps
}) => {
  const coolModeRef = useCoolMode(iconUrl);
  const [isMouseOver, setIsMouseOver] = import_react67.default.useState(false);
  const { i18n: i18n2 } = import_react67.default.useContext(I18nContext);
  return import_react67.default.createElement(
    Box,
    {
      display: "flex",
      flexDirection: "column",
      onMouseEnter: () => setIsMouseOver(true),
      onMouseLeave: () => setIsMouseOver(false),
      ref: coolModeRef
    },
    import_react67.default.createElement(
      Box,
      {
        as,
        borderRadius: "menuButton",
        borderStyle: "solid",
        borderWidth: "1",
        className: !currentlySelected ? [
          transparentBorder,
          touchableStyles({
            active: "shrink"
          })
        ] : void 0,
        disabled: currentlySelected,
        onClick,
        padding: "5",
        style: { willChange: "transform" },
        testId,
        transition: "default",
        width: "full",
        ...currentlySelected ? {
          background: "accentColor",
          borderColor: "selectedOptionBorder",
          boxShadow: "selectedWallet"
        } : {
          background: { hover: "menuItemBackground" }
        },
        ...urlProps
      },
      import_react67.default.createElement(
        Box,
        {
          color: currentlySelected ? "accentColorForeground" : "modalText",
          disabled: !ready,
          fontFamily: "body",
          fontSize: "16",
          fontWeight: "bold",
          transition: "default"
        },
        import_react67.default.createElement(Box, { alignItems: "center", display: "flex", flexDirection: "row", gap: "12" }, import_react67.default.createElement(
          AsyncImage,
          {
            background: iconBackground,
            ...!isMouseOver && isRainbowKitConnector2 ? { borderColor: "actionButtonBorder" } : {},
            useAsImage: !isRainbowKitConnector2,
            borderRadius: "6",
            height: "28",
            src: iconUrl,
            width: "28"
          }
        ), import_react67.default.createElement(Box, null, import_react67.default.createElement(
          Box,
          {
            style: { marginTop: recent ? -2 : void 0 },
            maxWidth: "200"
          },
          name
        ), recent && import_react67.default.createElement(
          Text,
          {
            color: currentlySelected ? "accentColorForeground" : "accentColor",
            size: "12",
            style: { lineHeight: 1, marginTop: -1 },
            weight: "medium"
          },
          i18n2.t("connect.recent")
        )))
      )
    )
  );
};
ModalSelection.displayName = "ModalSelection";
var storageKey5 = "rk-latest-id";
function getLatestWalletId() {
  return typeof localStorage !== "undefined" ? localStorage.getItem(storageKey5) || "" : "";
}
function addLatestWalletId(walletId) {
  localStorage.setItem(storageKey5, walletId);
}
function clearLatestWalletId() {
  localStorage.removeItem(storageKey5);
}
var convertHexToRGBA = (hexCode, opacity = 1) => {
  let hex = hexCode.replace("#", "");
  if (hex.length === 3) {
    hex = `${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}`;
  }
  const r2 = Number.parseInt(hex.substring(0, 2), 16);
  const g = Number.parseInt(hex.substring(2, 4), 16);
  const b = Number.parseInt(hex.substring(4, 6), 16);
  if (opacity > 1 && opacity <= 100) {
    opacity = opacity / 100;
  }
  return `rgba(${r2},${g},${b},${opacity})`;
};
var getGradientRGBAs = (hexColor) => {
  if (!hexColor) return null;
  return [
    convertHexToRGBA(hexColor, 0.2),
    convertHexToRGBA(hexColor, 0.14),
    convertHexToRGBA(hexColor, 0.1)
  ];
};
var isHexString = (color) => {
  return /^#([0-9a-f]{3}){1,2}$/i.test(color);
};
var src3 = async () => (await import("./connect-UA7M4XW6-G2G4X4QZ.js")).default;
var preloadConnectIcon = () => loadImages(src3);
var ConnectIcon = () => import_react70.default.createElement(
  AsyncImage,
  {
    background: "#515a70",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: src3,
    width: "48"
  }
);
var src4 = async () => (await import("./create-FASO7PVG-VH2IFLV7.js")).default;
var preloadCreateIcon = () => loadImages(src4);
var CreateIcon = () => import_react71.default.createElement(
  AsyncImage,
  {
    background: "#e3a5e8",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: src4,
    width: "48"
  }
);
var src5 = async () => (await import("./refresh-S4T5V5GX-RYCSN5CE.js")).default;
var preloadRefreshIcon = () => loadImages(src5);
var RefreshIcon = () => import_react72.default.createElement(
  AsyncImage,
  {
    background: "#515a70",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: src5,
    width: "48"
  }
);
var src6 = async () => (await import("./scan-4UYSQ56Q-KRYV2XQ3.js")).default;
var preloadScanIcon = () => loadImages(src6);
var ScanIcon = () => import_react73.default.createElement(
  AsyncImage,
  {
    background: "#515a70",
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: src6,
    width: "48"
  }
);
var QRCodeBackgroundClassName = "_1vwt0cg0";
var ScrollClassName = "_1vwt0cg2 ju367v7a ju367v7v";
var sidebar = "_1vwt0cg3";
var sidebarCompactMode = "_1vwt0cg4";
function QRCode({
  ecc = "medium",
  logoBackground,
  // biome-ignore lint/correctness/noUnusedVariables: API compatibility
  logoSize = 50,
  logoUrl,
  size: sizeProp = 200,
  uri
}) {
  const padding = "20";
  const size5 = sizeProp - Number.parseInt(padding, 10) * 2;
  const resolvedLogoUrl = useAsyncImage(logoUrl);
  return import_react74.default.createElement(
    Box,
    {
      borderColor: "generalBorder",
      borderRadius: "menuButton",
      borderStyle: "solid",
      borderWidth: "1",
      className: QRCodeBackgroundClassName,
      padding,
      width: "max"
    },
    import_react74.default.createElement(
      Box,
      {
        style: {
          height: size5,
          userSelect: "none",
          width: size5
        },
        userSelect: "none"
      },
      import_react74.default.createElement(Cuer.Root, { errorCorrection: ecc, size: size5, value: uri }, import_react74.default.createElement(Cuer.Cells, { radius: 1 }), import_react74.default.createElement(Cuer.Finder, { radius: 0.25 }), resolvedLogoUrl && import_react74.default.createElement(Cuer.Arena, null, import_react74.default.createElement(
        "img",
        {
          alt: "Wallet Logo",
          src: resolvedLogoUrl,
          style: {
            objectFit: "cover",
            height: "88%",
            width: "88%",
            borderRadius: "22.5%",
            backgroundColor: logoBackground
          }
        }
      )))
    )
  );
}
var getBrowserSrc = async () => {
  const browser = getBrowser();
  switch (browser) {
    case "Arc":
      return (await import("./Arc-VDBY7LNS-4JVECC6U.js")).default;
    case "Brave":
      return (await import("./Brave-BRAKJXDS-ZALFRVDG.js")).default;
    case "Chrome":
      return (await import("./Chrome-65Q5P54Y-MFA2OSJX.js")).default;
    case "Edge":
      return (await import("./Edge-XSPUTORV-T5F3X4AI.js")).default;
    case "Firefox":
      return (await import("./Firefox-AAHGJQIP-QB7OEB4J.js")).default;
    case "Opera":
      return (await import("./Opera-KQZLSACL-OKQGVUGZ.js")).default;
    case "Safari":
      return (await import("./Safari-ZPL37GXR-GBRX4QC3.js")).default;
    default:
      return (await import("./Browser-76IHF3Y2-CGSXEWZO.js")).default;
  }
};
var preloadBrowserIcon = () => loadImages(getBrowserSrc);
var getPlatformSrc = async () => {
  const platform = getPlatform();
  switch (platform) {
    case "Windows":
      return (await import("./Windows-PPTHQER6-PBBRWWQJ.js")).default;
    case "macOS":
      return (await import("./Macos-MW4AE7LN-FBVHCKDO.js")).default;
    case "Linux":
      return (await import("./Linux-OO4TNCLJ-VPUIL5OR.js")).default;
    default:
      return (await import("./Linux-OO4TNCLJ-VPUIL5OR.js")).default;
  }
};
var preloadPlatformIcon = () => loadImages(getPlatformSrc);
function GetDetail({
  getWalletDownload,
  compactModeEnabled
}) {
  const wallets = useWalletConnectors().filter(
    (wallet) => wallet.isRainbowKitConnector
  );
  const shownWallets = wallets.splice(0, 5);
  const { i18n: i18n2 } = (0, import_react69.useContext)(I18nContext);
  return import_react69.default.createElement(
    Box,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      marginTop: "18",
      width: "full"
    },
    import_react69.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        width: "full"
      },
      shownWallets == null ? void 0 : shownWallets.filter(
        (wallet) => {
          var _a;
          return wallet.extensionDownloadUrl || wallet.desktopDownloadUrl || wallet.qrCode && ((_a = wallet.downloadUrls) == null ? void 0 : _a.qrCode);
        }
      ).map((wallet) => {
        const { downloadUrls, iconBackground, iconUrl, id, name, qrCode } = wallet;
        const hasMobileCompanionApp = (downloadUrls == null ? void 0 : downloadUrls.qrCode) && qrCode;
        const hasExtension = !!wallet.extensionDownloadUrl;
        const hasMobileAndExtension = (downloadUrls == null ? void 0 : downloadUrls.qrCode) && hasExtension;
        const hasMobileAndDesktop = (downloadUrls == null ? void 0 : downloadUrls.qrCode) && !!wallet.desktopDownloadUrl;
        return import_react69.default.createElement(
          Box,
          {
            alignItems: "center",
            display: "flex",
            gap: "16",
            justifyContent: "space-between",
            key: wallet.id,
            width: "full"
          },
          import_react69.default.createElement(
            Box,
            {
              alignItems: "center",
              display: "flex",
              flexDirection: "row",
              gap: "16"
            },
            import_react69.default.createElement(
              AsyncImage,
              {
                background: iconBackground,
                borderColor: "actionButtonBorder",
                borderRadius: "10",
                height: "48",
                src: iconUrl,
                width: "48"
              }
            ),
            import_react69.default.createElement(Box, { display: "flex", flexDirection: "column", gap: "2" }, import_react69.default.createElement(Text, { color: "modalText", size: "14", weight: "bold" }, name), import_react69.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "medium" }, hasMobileAndExtension ? i18n2.t("get.mobile_and_extension.description") : hasMobileAndDesktop ? i18n2.t("get.mobile_and_desktop.description") : hasMobileCompanionApp ? i18n2.t("get.mobile.description") : hasExtension ? i18n2.t("get.extension.description") : null))
          ),
          import_react69.default.createElement(Box, { display: "flex", flexDirection: "column", gap: "4" }, import_react69.default.createElement(
            ActionButton,
            {
              label: i18n2.t("get.action.label"),
              onClick: () => getWalletDownload(id),
              type: "secondary"
            }
          ))
        );
      })
    ),
    import_react69.default.createElement(
      Box,
      {
        alignItems: "center",
        borderRadius: "10",
        display: "flex",
        flexDirection: "column",
        gap: "8",
        justifyContent: "space-between",
        marginBottom: "4",
        paddingY: "8",
        style: { maxWidth: 275, textAlign: "center" }
      },
      import_react69.default.createElement(Text, { color: "modalText", size: "14", weight: "bold" }, i18n2.t("get.looking_for.title")),
      import_react69.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "medium" }, compactModeEnabled ? i18n2.t("get.looking_for.desktop.compact_description") : i18n2.t("get.looking_for.desktop.wide_description"))
    )
  );
}
var LOGO_SIZE = "44";
function ConnectDetail({
  changeWalletStep,
  compactModeEnabled,
  connectionError,
  onClose,
  qrCodeUri,
  reconnect,
  wallet
}) {
  const {
    downloadUrls,
    iconBackground,
    iconUrl,
    name,
    qrCode,
    ready,
    showWalletConnectModal,
    getDesktopUri
  } = wallet;
  const isDesktopDeepLinkAvailable = !!getDesktopUri;
  const safari = isSafari();
  const { i18n: i18n2 } = (0, import_react69.useContext)(I18nContext);
  const hasExtension = !!wallet.extensionDownloadUrl;
  const hasQrCodeAndExtension = (downloadUrls == null ? void 0 : downloadUrls.qrCode) && hasExtension;
  const hasQrCodeAndDesktop = (downloadUrls == null ? void 0 : downloadUrls.qrCode) && !!wallet.desktopDownloadUrl;
  const hasQrCode = qrCode && qrCodeUri;
  const onDesktopUri = async () => {
    const uri = await (getDesktopUri == null ? void 0 : getDesktopUri());
    window.open(uri, safari ? "_blank" : "_self");
  };
  const secondaryAction = showWalletConnectModal ? {
    description: !compactModeEnabled ? i18n2.t("connect.walletconnect.description.full") : i18n2.t("connect.walletconnect.description.compact"),
    label: i18n2.t("connect.walletconnect.open.label"),
    onClick: () => {
      onClose();
      showWalletConnectModal();
    }
  } : hasQrCode ? {
    description: i18n2.t("connect.secondary_action.get.description", {
      wallet: name
    }),
    label: i18n2.t("connect.secondary_action.get.label"),
    onClick: () => changeWalletStep(
      hasQrCodeAndExtension || hasQrCodeAndDesktop ? "DOWNLOAD_OPTIONS" : "DOWNLOAD"
      /* Download */
    )
  } : null;
  const { width: windowWidth } = useWindowSize();
  const smallWindow = windowWidth && windowWidth < 768;
  (0, import_react69.useEffect)(() => {
    preloadBrowserIcon();
    preloadPlatformIcon();
  }, []);
  return import_react69.default.createElement(Box, { display: "flex", flexDirection: "column", height: "full", width: "full" }, hasQrCode ? import_react69.default.createElement(
    Box,
    {
      alignItems: "center",
      display: "flex",
      height: "full",
      justifyContent: "center"
    },
    import_react69.default.createElement(
      QRCode,
      {
        logoBackground: iconBackground,
        logoSize: compactModeEnabled ? 60 : 72,
        logoUrl: iconUrl,
        size: compactModeEnabled ? 318 : smallWindow ? Math.max(280, Math.min(windowWidth - 308, 382)) : 382,
        uri: qrCodeUri
      }
    )
  ) : import_react69.default.createElement(
    Box,
    {
      alignItems: "center",
      display: "flex",
      justifyContent: "center",
      style: { flexGrow: 1 }
    },
    import_react69.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "8"
      },
      import_react69.default.createElement(Box, { borderRadius: "10", height: LOGO_SIZE, overflow: "hidden" }, import_react69.default.createElement(
        AsyncImage,
        {
          useAsImage: !wallet.isRainbowKitConnector,
          height: LOGO_SIZE,
          src: iconUrl,
          width: LOGO_SIZE
        }
      )),
      import_react69.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: "4",
          paddingX: "32",
          style: { textAlign: "center" }
        },
        import_react69.default.createElement(Text, { color: "modalText", size: "18", weight: "bold" }, ready ? i18n2.t("connect.status.opening", {
          wallet: name
        }) : hasExtension ? i18n2.t("connect.status.not_installed", {
          wallet: name
        }) : i18n2.t("connect.status.not_available", {
          wallet: name
        })),
        !ready && hasExtension ? import_react69.default.createElement(Box, { paddingTop: "20" }, import_react69.default.createElement(
          ActionButton,
          {
            href: wallet.extensionDownloadUrl,
            label: i18n2.t("connect.secondary_action.install.label"),
            type: "secondary"
          }
        )) : null,
        ready && !hasQrCode && import_react69.default.createElement(import_react69.default.Fragment, null, import_react69.default.createElement(
          Box,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center"
          },
          import_react69.default.createElement(
            Text,
            {
              color: "modalTextSecondary",
              size: "14",
              textAlign: "center",
              weight: "medium"
            },
            i18n2.t("connect.status.confirm")
          )
        ), import_react69.default.createElement(
          Box,
          {
            alignItems: "center",
            color: "modalText",
            display: "flex",
            flexDirection: "row",
            height: "32",
            marginTop: "8"
          },
          connectionError ? import_react69.default.createElement(
            ActionButton,
            {
              label: i18n2.t("connect.secondary_action.retry.label"),
              onClick: async () => {
                if (isDesktopDeepLinkAvailable) onDesktopUri();
                reconnect(wallet);
              }
            }
          ) : import_react69.default.createElement(Box, { color: "modalTextSecondary" }, import_react69.default.createElement(SpinnerIcon, null))
        ))
      )
    )
  ), import_react69.default.createElement(
    Box,
    {
      alignItems: "center",
      borderRadius: "10",
      display: "flex",
      flexDirection: "row",
      gap: "8",
      height: "28",
      justifyContent: "space-between",
      marginTop: "12"
    },
    ready && secondaryAction && import_react69.default.createElement(import_react69.default.Fragment, null, import_react69.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "medium" }, secondaryAction.description), import_react69.default.createElement(
      ActionButton,
      {
        label: secondaryAction.label,
        onClick: secondaryAction.onClick,
        type: "secondary"
      }
    ))
  ));
}
var DownloadOptionsBox = ({
  actionLabel,
  description,
  iconAccent,
  iconBackground,
  iconUrl,
  isCompact,
  onAction,
  title,
  url,
  variant
}) => {
  const isBrowserCard = variant === "browser";
  const gradientRgbas = !isBrowserCard && iconAccent && getGradientRGBAs(iconAccent);
  return import_react69.default.createElement(
    Box,
    {
      alignItems: "center",
      borderRadius: "13",
      display: "flex",
      justifyContent: "center",
      overflow: "hidden",
      paddingX: isCompact ? "18" : "44",
      position: "relative",
      style: { flex: 1, isolation: "isolate" },
      width: "full"
    },
    import_react69.default.createElement(
      Box,
      {
        borderColor: "actionButtonBorder",
        borderRadius: "13",
        borderStyle: "solid",
        borderWidth: "1",
        style: {
          bottom: "0",
          left: "0",
          position: "absolute",
          right: "0",
          top: "0",
          zIndex: 1
        }
      }
    ),
    isBrowserCard && import_react69.default.createElement(
      Box,
      {
        background: "downloadTopCardBackground",
        height: "full",
        position: "absolute",
        style: {
          zIndex: 0
        },
        width: "full"
      },
      import_react69.default.createElement(
        Box,
        {
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-between",
          style: {
            bottom: "0",
            filter: "blur(20px)",
            left: "0",
            position: "absolute",
            right: "0",
            top: "0",
            transform: "translate3d(0, 0, 0)"
          }
        },
        import_react69.default.createElement(
          Box,
          {
            style: {
              filter: "blur(100px)",
              marginLeft: -27,
              marginTop: -20,
              opacity: 0.6,
              transform: "translate3d(0, 0, 0)"
            }
          },
          import_react69.default.createElement(
            AsyncImage,
            {
              borderRadius: "full",
              height: "200",
              src: iconUrl,
              width: "200"
            }
          )
        ),
        import_react69.default.createElement(
          Box,
          {
            style: {
              filter: "blur(100px)",
              marginRight: 0,
              marginTop: 105,
              opacity: 0.6,
              overflow: "auto",
              transform: "translate3d(0, 0, 0)"
            }
          },
          import_react69.default.createElement(
            AsyncImage,
            {
              borderRadius: "full",
              height: "200",
              src: iconUrl,
              width: "200"
            }
          )
        )
      )
    ),
    !isBrowserCard && gradientRgbas && import_react69.default.createElement(
      Box,
      {
        background: "downloadBottomCardBackground",
        style: {
          bottom: "0",
          left: "0",
          position: "absolute",
          right: "0",
          top: "0"
        }
      },
      import_react69.default.createElement(
        Box,
        {
          position: "absolute",
          style: {
            background: `radial-gradient(50% 50% at 50% 50%, ${gradientRgbas[0]} 0%, ${gradientRgbas[1]} 25%, rgba(0,0,0,0) 100%)`,
            height: 564,
            left: -215,
            top: -197,
            transform: "translate3d(0, 0, 0)",
            width: 564
          }
        }
      ),
      import_react69.default.createElement(
        Box,
        {
          position: "absolute",
          style: {
            background: `radial-gradient(50% 50% at 50% 50%, ${gradientRgbas[2]} 0%, rgba(0, 0, 0, 0) 100%)`,
            height: 564,
            left: -1,
            top: -76,
            transform: "translate3d(0, 0, 0)",
            width: 564
          }
        }
      )
    ),
    import_react69.default.createElement(
      Box,
      {
        alignItems: "flex-start",
        display: "flex",
        flexDirection: "row",
        gap: "24",
        height: "max",
        justifyContent: "center",
        style: { zIndex: 1 }
      },
      import_react69.default.createElement(Box, null, import_react69.default.createElement(
        AsyncImage,
        {
          height: "60",
          src: iconUrl,
          width: "60",
          ...iconBackground ? {
            background: iconBackground,
            borderColor: "generalBorder",
            borderRadius: "10"
          } : null
        }
      )),
      import_react69.default.createElement(
        Box,
        {
          display: "flex",
          flexDirection: "column",
          gap: "4",
          style: { flex: 1 },
          width: "full"
        },
        import_react69.default.createElement(Text, { color: "modalText", size: "14", weight: "bold" }, title),
        import_react69.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "medium" }, description),
        import_react69.default.createElement(Box, { marginTop: "14", width: "max" }, import_react69.default.createElement(
          ActionButton,
          {
            href: url,
            label: actionLabel,
            onClick: onAction,
            size: "medium"
          }
        ))
      )
    )
  );
};
function DownloadOptionsDetail({
  changeWalletStep,
  wallet
}) {
  const browser = getBrowser();
  const platform = getPlatform();
  const modalSize = (0, import_react69.useContext)(ModalSizeContext);
  const isCompact = modalSize === "compact";
  const {
    desktop,
    desktopDownloadUrl,
    extension,
    extensionDownloadUrl,
    mobileDownloadUrl
  } = wallet;
  const { i18n: i18n2 } = (0, import_react69.useContext)(I18nContext);
  (0, import_react69.useEffect)(() => {
    preloadCreateIcon();
    preloadScanIcon();
    preloadRefreshIcon();
    preloadConnectIcon();
  }, []);
  return import_react69.default.createElement(
    Box,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: "24",
      height: "full",
      marginBottom: "8",
      marginTop: "4",
      width: "full"
    },
    import_react69.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "8",
        height: "full",
        justifyContent: "center",
        width: "full"
      },
      extensionDownloadUrl && import_react69.default.createElement(
        DownloadOptionsBox,
        {
          actionLabel: i18n2.t("get_options.extension.download.label", {
            browser
          }),
          description: i18n2.t("get_options.extension.description"),
          iconUrl: getBrowserSrc,
          isCompact,
          onAction: () => changeWalletStep(
            (extension == null ? void 0 : extension.instructions) ? "INSTRUCTIONS_EXTENSION" : "CONNECT"
            /* Connect */
          ),
          title: i18n2.t("get_options.extension.title", {
            wallet: wallet.name,
            browser
          }),
          url: extensionDownloadUrl,
          variant: "browser"
        }
      ),
      desktopDownloadUrl && import_react69.default.createElement(
        DownloadOptionsBox,
        {
          actionLabel: i18n2.t("get_options.desktop.download.label", {
            platform
          }),
          description: i18n2.t("get_options.desktop.description"),
          iconUrl: getPlatformSrc,
          isCompact,
          onAction: () => changeWalletStep(
            (desktop == null ? void 0 : desktop.instructions) ? "INSTRUCTIONS_DESKTOP" : "CONNECT"
            /* Connect */
          ),
          title: i18n2.t("get_options.desktop.title", {
            wallet: wallet.name,
            platform
          }),
          url: desktopDownloadUrl,
          variant: "desktop"
        }
      ),
      mobileDownloadUrl && import_react69.default.createElement(
        DownloadOptionsBox,
        {
          actionLabel: i18n2.t("get_options.mobile.download.label", {
            wallet: wallet.name
          }),
          description: i18n2.t("get_options.mobile.description"),
          iconAccent: wallet.iconAccent,
          iconBackground: wallet.iconBackground,
          iconUrl: wallet.iconUrl,
          isCompact,
          onAction: () => {
            changeWalletStep(
              "DOWNLOAD"
              /* Download */
            );
          },
          title: i18n2.t("get_options.mobile.title", { wallet: wallet.name }),
          variant: "app"
        }
      )
    )
  );
}
function DownloadDetail({
  changeWalletStep,
  wallet
}) {
  const { downloadUrls, qrCode } = wallet;
  const { i18n: i18n2 } = (0, import_react69.useContext)(I18nContext);
  (0, import_react69.useEffect)(() => {
    preloadCreateIcon();
    preloadScanIcon();
  }, []);
  return import_react69.default.createElement(
    Box,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      gap: "24",
      height: "full",
      width: "full"
    },
    import_react69.default.createElement(Box, { style: { maxWidth: 220, textAlign: "center" } }, import_react69.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "semibold" }, i18n2.t("get_mobile.description"))),
    import_react69.default.createElement(Box, { height: "full" }, (downloadUrls == null ? void 0 : downloadUrls.qrCode) ? import_react69.default.createElement(QRCode, { logoSize: 0, size: 268, uri: downloadUrls.qrCode }) : null),
    import_react69.default.createElement(
      Box,
      {
        alignItems: "center",
        borderRadius: "10",
        display: "flex",
        flexDirection: "row",
        gap: "8",
        height: "34",
        justifyContent: "space-between",
        marginBottom: "12",
        paddingY: "8"
      },
      import_react69.default.createElement(
        ActionButton,
        {
          label: i18n2.t("get_mobile.continue.label"),
          onClick: () => changeWalletStep(
            (qrCode == null ? void 0 : qrCode.instructions) ? "INSTRUCTIONS_MOBILE" : "CONNECT"
            /* Connect */
          )
        }
      )
    )
  );
}
var stepIcons = {
  connect: () => import_react69.default.createElement(ConnectIcon, null),
  create: () => import_react69.default.createElement(CreateIcon, null),
  install: (wallet) => import_react69.default.createElement(
    AsyncImage,
    {
      background: wallet.iconBackground,
      borderColor: "generalBorder",
      borderRadius: "10",
      height: "48",
      src: wallet.iconUrl,
      width: "48"
    }
  ),
  refresh: () => import_react69.default.createElement(RefreshIcon, null),
  scan: () => import_react69.default.createElement(ScanIcon, null)
};
function InstructionMobileDetail({
  connectWallet,
  wallet
}) {
  var _a, _b, _c, _d;
  const { i18n: i18n2 } = (0, import_react69.useContext)(I18nContext);
  return import_react69.default.createElement(
    Box,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      width: "full"
    },
    import_react69.default.createElement(
      Box,
      {
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        justifyContent: "center",
        paddingY: "32",
        style: { maxWidth: 320 }
      },
      (_b = (_a = wallet == null ? void 0 : wallet.qrCode) == null ? void 0 : _a.instructions) == null ? void 0 : _b.steps.map((d, idx) => {
        var _a2;
        return import_react69.default.createElement(
          Box,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "16",
            key: idx
          },
          import_react69.default.createElement(
            Box,
            {
              borderRadius: "10",
              height: "48",
              minWidth: "48",
              overflow: "hidden",
              position: "relative",
              width: "48"
            },
            (_a2 = stepIcons[d.step]) == null ? void 0 : _a2.call(stepIcons, wallet)
          ),
          import_react69.default.createElement(Box, { display: "flex", flexDirection: "column", gap: "4" }, import_react69.default.createElement(Text, { color: "modalText", size: "14", weight: "bold" }, i18n2.t(d.title, void 0, {
            rawKeyIfTranslationMissing: true
          })), import_react69.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "medium" }, i18n2.t(d.description, void 0, {
            rawKeyIfTranslationMissing: true
          })))
        );
      })
    ),
    import_react69.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        marginBottom: "16"
      },
      import_react69.default.createElement(
        ActionButton,
        {
          label: i18n2.t("get_instructions.mobile.connect.label"),
          onClick: () => connectWallet(wallet)
        }
      ),
      import_react69.default.createElement(
        Box,
        {
          as: "a",
          className: touchableStyles({ active: "shrink", hover: "grow" }),
          display: "block",
          href: (_d = (_c = wallet == null ? void 0 : wallet.qrCode) == null ? void 0 : _c.instructions) == null ? void 0 : _d.learnMoreUrl,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        import_react69.default.createElement(Text, { color: "accentColor", size: "14", weight: "bold" }, i18n2.t("get_instructions.mobile.learn_more.label"))
      )
    )
  );
}
function InstructionExtensionDetail({
  wallet
}) {
  var _a, _b, _c, _d;
  const { i18n: i18n2 } = (0, import_react69.useContext)(I18nContext);
  return import_react69.default.createElement(
    Box,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      width: "full"
    },
    import_react69.default.createElement(
      Box,
      {
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        justifyContent: "center",
        paddingY: "32",
        style: { maxWidth: 320 }
      },
      (_b = (_a = wallet == null ? void 0 : wallet.extension) == null ? void 0 : _a.instructions) == null ? void 0 : _b.steps.map((d, idx) => {
        var _a2;
        return import_react69.default.createElement(
          Box,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "16",
            key: idx
          },
          import_react69.default.createElement(
            Box,
            {
              borderRadius: "10",
              height: "48",
              minWidth: "48",
              overflow: "hidden",
              position: "relative",
              width: "48"
            },
            (_a2 = stepIcons[d.step]) == null ? void 0 : _a2.call(stepIcons, wallet)
          ),
          import_react69.default.createElement(Box, { display: "flex", flexDirection: "column", gap: "4" }, import_react69.default.createElement(Text, { color: "modalText", size: "14", weight: "bold" }, i18n2.t(d.title, void 0, {
            rawKeyIfTranslationMissing: true
          })), import_react69.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "medium" }, i18n2.t(d.description, void 0, {
            rawKeyIfTranslationMissing: true
          })))
        );
      })
    ),
    import_react69.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        marginBottom: "16"
      },
      import_react69.default.createElement(
        ActionButton,
        {
          label: i18n2.t("get_instructions.extension.refresh.label"),
          onClick: window.location.reload.bind(window.location)
        }
      ),
      import_react69.default.createElement(
        Box,
        {
          as: "a",
          className: touchableStyles({ active: "shrink", hover: "grow" }),
          display: "block",
          href: (_d = (_c = wallet == null ? void 0 : wallet.extension) == null ? void 0 : _c.instructions) == null ? void 0 : _d.learnMoreUrl,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        import_react69.default.createElement(Text, { color: "accentColor", size: "14", weight: "bold" }, i18n2.t("get_instructions.extension.learn_more.label"))
      )
    )
  );
}
function InstructionDesktopDetail({
  connectWallet,
  wallet
}) {
  var _a, _b, _c, _d;
  const { i18n: i18n2 } = (0, import_react69.useContext)(I18nContext);
  return import_react69.default.createElement(
    Box,
    {
      alignItems: "center",
      display: "flex",
      flexDirection: "column",
      height: "full",
      width: "full"
    },
    import_react69.default.createElement(
      Box,
      {
        display: "flex",
        flexDirection: "column",
        gap: "28",
        height: "full",
        justifyContent: "center",
        paddingY: "32",
        style: { maxWidth: 320 }
      },
      (_b = (_a = wallet == null ? void 0 : wallet.desktop) == null ? void 0 : _a.instructions) == null ? void 0 : _b.steps.map((d, idx) => {
        var _a2;
        return import_react69.default.createElement(
          Box,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "16",
            key: idx
          },
          import_react69.default.createElement(
            Box,
            {
              borderRadius: "10",
              height: "48",
              minWidth: "48",
              overflow: "hidden",
              position: "relative",
              width: "48"
            },
            (_a2 = stepIcons[d.step]) == null ? void 0 : _a2.call(stepIcons, wallet)
          ),
          import_react69.default.createElement(Box, { display: "flex", flexDirection: "column", gap: "4" }, import_react69.default.createElement(Text, { color: "modalText", size: "14", weight: "bold" }, i18n2.t(d.title, void 0, {
            rawKeyIfTranslationMissing: true
          })), import_react69.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "medium" }, i18n2.t(d.description, void 0, {
            rawKeyIfTranslationMissing: true
          })))
        );
      })
    ),
    import_react69.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "12",
        justifyContent: "center",
        marginBottom: "16"
      },
      import_react69.default.createElement(
        ActionButton,
        {
          label: i18n2.t("get_instructions.desktop.connect.label"),
          onClick: () => connectWallet(wallet)
        }
      ),
      import_react69.default.createElement(
        Box,
        {
          as: "a",
          className: touchableStyles({ active: "shrink", hover: "grow" }),
          display: "block",
          href: (_d = (_c = wallet == null ? void 0 : wallet.desktop) == null ? void 0 : _c.instructions) == null ? void 0 : _d.learnMoreUrl,
          paddingX: "12",
          paddingY: "4",
          rel: "noreferrer",
          style: { willChange: "transform" },
          target: "_blank",
          transition: "default"
        },
        import_react69.default.createElement(Text, { color: "accentColor", size: "14", weight: "bold" }, i18n2.t("get_instructions.desktop.learn_more.label"))
      )
    )
  );
}
function DesktopOptions({ onClose }) {
  const titleId = "rk_connect_title";
  const [selectedOptionId, setSelectedOptionId] = (0, import_react60.useState)();
  const [selectedWallet, setSelectedWallet] = (0, import_react60.useState)();
  const [qrCodeUri, setQrCodeUri] = (0, import_react60.useState)();
  const hasQrCode = !!(selectedWallet == null ? void 0 : selectedWallet.qrCode) && qrCodeUri;
  const [connectionError, setConnectionError] = (0, import_react60.useState)(false);
  const modalSize = (0, import_react60.useContext)(ModalSizeContext);
  const compactModeEnabled = modalSize === ModalSizeOptions.COMPACT;
  const { disclaimer: Disclaimer } = (0, import_react60.useContext)(AppContext);
  const { i18n: i18n2 } = (0, import_react60.useContext)(I18nContext);
  const safari = isSafari();
  const initialized = (0, import_react60.useRef)(false);
  const { connector } = (0, import_react60.useContext)(WalletButtonContext);
  const mergeEIP6963WithRkConnectors = !connector;
  const wallets = useWalletConnectors(mergeEIP6963WithRkConnectors).filter((wallet) => wallet.ready || !!wallet.extensionDownloadUrl).sort((a, b) => a.groupIndex - b.groupIndex);
  const unfilteredWallets = useWalletConnectors();
  const groupedWallets = groupBy(wallets, (wallet) => wallet.groupName);
  const supportedI18nGroupNames = [
    "Recommended",
    "Other",
    "Popular",
    "More",
    "Others",
    "Installed"
  ];
  (0, import_react60.useEffect)(() => {
    if (connector && !initialized.current) {
      changeWalletStep(
        "CONNECT"
        /* Connect */
      );
      selectWallet(connector);
      initialized.current = true;
    }
  }, [connector]);
  const connectToWallet = (wallet) => {
    var _a, _b;
    setConnectionError(false);
    if (wallet.ready) {
      (_b = (_a = wallet == null ? void 0 : wallet.connect) == null ? void 0 : _a.call(wallet)) == null ? void 0 : _b.catch(() => {
        setConnectionError(true);
      });
    }
  };
  const onDesktopUri = async (wallet) => {
    const sWallet = wallets.find((w) => wallet.id === w.id);
    if (!(sWallet == null ? void 0 : sWallet.getDesktopUri)) return;
    setTimeout(async () => {
      var _a;
      const uri = await ((_a = sWallet == null ? void 0 : sWallet.getDesktopUri) == null ? void 0 : _a.call(sWallet));
      if (uri) window.open(uri, safari ? "_blank" : "_self");
    }, 0);
  };
  const onQrCode = async (wallet) => {
    var _a;
    const sWallet = wallets.find((w) => wallet.id === w.id);
    const uri = await ((_a = sWallet == null ? void 0 : sWallet.getQrCodeUri) == null ? void 0 : _a.call(sWallet));
    setQrCodeUri(uri);
    setTimeout(
      () => {
        setSelectedWallet(sWallet);
        changeWalletStep(
          "CONNECT"
          /* Connect */
        );
      },
      uri ? 0 : 50
    );
  };
  const selectWallet = async (wallet) => {
    addLatestWalletId(wallet.id);
    if (wallet.ready) {
      onQrCode(wallet);
      onDesktopUri(wallet);
    }
    connectToWallet(wallet);
    setSelectedOptionId(wallet.id);
    if (!wallet.ready) {
      setSelectedWallet(wallet);
      changeWalletStep(
        (wallet == null ? void 0 : wallet.extensionDownloadUrl) ? "DOWNLOAD_OPTIONS" : "CONNECT"
        /* Connect */
      );
    }
  };
  const getWalletDownload = (id) => {
    var _a;
    const sWallet = unfilteredWallets.find((w) => id === w.id);
    const isMobile2 = (_a = sWallet == null ? void 0 : sWallet.downloadUrls) == null ? void 0 : _a.qrCode;
    const isDesktop = !!(sWallet == null ? void 0 : sWallet.desktopDownloadUrl);
    const isExtension = !!(sWallet == null ? void 0 : sWallet.extensionDownloadUrl);
    setSelectedWallet(sWallet);
    if (isMobile2 && (isExtension || isDesktop)) {
      changeWalletStep(
        "DOWNLOAD_OPTIONS"
        /* DownloadOptions */
      );
    } else if (isMobile2) {
      changeWalletStep(
        "DOWNLOAD"
        /* Download */
      );
    } else if (isDesktop) {
      changeWalletStep(
        "INSTRUCTIONS_DESKTOP"
        /* InstructionsDesktop */
      );
    } else {
      changeWalletStep(
        "INSTRUCTIONS_EXTENSION"
        /* InstructionsExtension */
      );
    }
  };
  const clearSelectedWallet = () => {
    setSelectedOptionId(void 0);
    setSelectedWallet(void 0);
    setQrCodeUri(void 0);
  };
  const changeWalletStep = (newWalletStep, isBack = false) => {
    if (isBack && newWalletStep === "GET" && initialWalletStep === "GET") {
      clearSelectedWallet();
    } else if (!isBack && newWalletStep === "GET") {
      setInitialWalletStep(
        "GET"
        /* Get */
      );
    } else if (!isBack && newWalletStep === "CONNECT") {
      setInitialWalletStep(
        "CONNECT"
        /* Connect */
      );
    }
    setWalletStep(newWalletStep);
  };
  const [initialWalletStep, setInitialWalletStep] = (0, import_react60.useState)(
    "NONE"
    /* None */
  );
  const [walletStep, setWalletStep] = (0, import_react60.useState)(
    "NONE"
    /* None */
  );
  let walletContent = null;
  let headerLabel = null;
  let headerBackButtonLink = null;
  let headerBackButtonCallback;
  (0, import_react60.useEffect)(() => {
    setConnectionError(false);
  }, [walletStep, selectedWallet]);
  const hasExtension = !!(selectedWallet == null ? void 0 : selectedWallet.extensionDownloadUrl);
  const hasExtensionAndMobile = !!(hasExtension && (selectedWallet == null ? void 0 : selectedWallet.mobileDownloadUrl));
  switch (walletStep) {
    case "NONE":
      walletContent = import_react60.default.createElement(ConnectModalIntro, { getWallet: () => changeWalletStep(
        "GET"
        /* Get */
      ) });
      break;
    case "LEARN_COMPACT":
      walletContent = import_react60.default.createElement(
        ConnectModalIntro,
        {
          compactModeEnabled,
          getWallet: () => changeWalletStep(
            "GET"
            /* Get */
          )
        }
      );
      headerLabel = i18n2.t("intro.title");
      headerBackButtonLink = "NONE";
      break;
    case "GET":
      walletContent = import_react60.default.createElement(
        GetDetail,
        {
          getWalletDownload,
          compactModeEnabled
        }
      );
      headerLabel = i18n2.t("get.title");
      headerBackButtonLink = compactModeEnabled ? "LEARN_COMPACT" : "NONE";
      break;
    case "CONNECT":
      walletContent = selectedWallet && import_react60.default.createElement(
        ConnectDetail,
        {
          changeWalletStep,
          compactModeEnabled,
          connectionError,
          onClose,
          qrCodeUri,
          reconnect: connectToWallet,
          wallet: selectedWallet
        }
      );
      headerLabel = hasQrCode && (selectedWallet.name === "WalletConnect" ? i18n2.t("connect_scan.fallback_title") : i18n2.t("connect_scan.title", {
        wallet: selectedWallet.name
      }));
      headerBackButtonLink = compactModeEnabled ? connector ? null : "NONE" : null;
      headerBackButtonCallback = compactModeEnabled ? !connector ? clearSelectedWallet : () => {
      } : () => {
      };
      break;
    case "DOWNLOAD_OPTIONS":
      walletContent = selectedWallet && import_react60.default.createElement(
        DownloadOptionsDetail,
        {
          changeWalletStep,
          wallet: selectedWallet
        }
      );
      headerLabel = selectedWallet && i18n2.t("get_options.short_title", { wallet: selectedWallet.name });
      headerBackButtonLink = connector ? "CONNECT" : compactModeEnabled ? "NONE" : initialWalletStep;
      break;
    case "DOWNLOAD":
      walletContent = selectedWallet && import_react60.default.createElement(
        DownloadDetail,
        {
          changeWalletStep,
          wallet: selectedWallet
        }
      );
      headerLabel = selectedWallet && i18n2.t("get_mobile.title", { wallet: selectedWallet.name });
      headerBackButtonLink = hasExtensionAndMobile ? "DOWNLOAD_OPTIONS" : initialWalletStep;
      break;
    case "INSTRUCTIONS_MOBILE":
      walletContent = selectedWallet && import_react60.default.createElement(
        InstructionMobileDetail,
        {
          connectWallet: selectWallet,
          wallet: selectedWallet
        }
      );
      headerLabel = selectedWallet && i18n2.t("get_options.title", {
        wallet: compactModeEnabled ? selectedWallet.shortName || selectedWallet.name : selectedWallet.name
      });
      headerBackButtonLink = "DOWNLOAD";
      break;
    case "INSTRUCTIONS_EXTENSION":
      walletContent = selectedWallet && import_react60.default.createElement(InstructionExtensionDetail, { wallet: selectedWallet });
      headerLabel = selectedWallet && i18n2.t("get_options.title", {
        wallet: compactModeEnabled ? selectedWallet.shortName || selectedWallet.name : selectedWallet.name
      });
      headerBackButtonLink = "DOWNLOAD_OPTIONS";
      break;
    case "INSTRUCTIONS_DESKTOP":
      walletContent = selectedWallet && import_react60.default.createElement(
        InstructionDesktopDetail,
        {
          connectWallet: selectWallet,
          wallet: selectedWallet
        }
      );
      headerLabel = selectedWallet && i18n2.t("get_options.title", {
        wallet: compactModeEnabled ? selectedWallet.shortName || selectedWallet.name : selectedWallet.name
      });
      headerBackButtonLink = "DOWNLOAD_OPTIONS";
      break;
    default:
      break;
  }
  return import_react60.default.createElement(
    Box,
    {
      display: "flex",
      flexDirection: "row",
      style: { maxHeight: compactModeEnabled ? 468 : 504 }
    },
    (compactModeEnabled ? walletStep === "NONE" : true) && import_react60.default.createElement(
      Box,
      {
        className: compactModeEnabled ? sidebarCompactMode : sidebar,
        display: "flex",
        flexDirection: "column",
        marginTop: "16"
      },
      import_react60.default.createElement(Box, { display: "flex", justifyContent: "space-between" }, compactModeEnabled && Disclaimer && import_react60.default.createElement(Box, { marginLeft: "16", width: "28" }, import_react60.default.createElement(
        InfoButton,
        {
          onClick: () => changeWalletStep(
            "LEARN_COMPACT"
            /* LearnCompact */
          )
        }
      )), compactModeEnabled && !Disclaimer && import_react60.default.createElement(Box, { marginLeft: "16", width: "28" }), import_react60.default.createElement(
        Box,
        {
          marginLeft: compactModeEnabled ? "0" : "6",
          paddingBottom: "8",
          paddingTop: "2",
          paddingX: "18"
        },
        import_react60.default.createElement(
          Text,
          {
            as: "h1",
            color: "modalText",
            id: titleId,
            size: "18",
            weight: "heavy",
            testId: "connect-header-label"
          },
          i18n2.t("connect.title")
        )
      ), compactModeEnabled && import_react60.default.createElement(Box, { marginRight: "16" }, import_react60.default.createElement(CloseButton, { onClose }))),
      import_react60.default.createElement(Box, { className: ScrollClassName, paddingBottom: "18" }, Object.entries(groupedWallets).map(
        ([groupName, wallets2], index2) => wallets2.length > 0 && import_react60.default.createElement(import_react60.Fragment, { key: index2 }, groupName ? import_react60.default.createElement(Box, { marginBottom: "8", marginTop: "16", marginX: "6" }, import_react60.default.createElement(
          Text,
          {
            color: groupName === "Installed" ? "accentColor" : "modalTextSecondary",
            size: "14",
            weight: "bold"
          },
          supportedI18nGroupNames.includes(groupName) ? i18n2.t(
            `connector_group.${groupName.toLowerCase()}`
          ) : groupName
        )) : null, import_react60.default.createElement(Box, { display: "flex", flexDirection: "column", gap: "4" }, wallets2.map((wallet) => {
          return import_react60.default.createElement(
            ModalSelection,
            {
              currentlySelected: wallet.id === selectedOptionId,
              iconBackground: wallet.iconBackground,
              iconUrl: wallet.iconUrl,
              key: wallet.id,
              name: wallet.name,
              onClick: () => selectWallet(wallet),
              ready: wallet.ready,
              recent: wallet.recent,
              testId: `wallet-option-${wallet.id}`,
              isRainbowKitConnector: wallet.isRainbowKitConnector
            }
          );
        })))
      )),
      compactModeEnabled && import_react60.default.createElement(import_react60.default.Fragment, null, import_react60.default.createElement(Box, { background: "generalBorder", height: "1", marginTop: "-1" }), Disclaimer ? import_react60.default.createElement(Box, { paddingX: "24", paddingY: "16", textAlign: "center" }, import_react60.default.createElement(Disclaimer, { Link: DisclaimerLink, Text: DisclaimerText })) : import_react60.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          justifyContent: "space-between",
          paddingX: "24",
          paddingY: "16"
        },
        import_react60.default.createElement(Box, { paddingY: "4" }, import_react60.default.createElement(Text, { color: "modalTextSecondary", size: "14", weight: "medium" }, i18n2.t("connect.new_to_ethereum.description"))),
        import_react60.default.createElement(
          Box,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "row",
            gap: "4",
            justifyContent: "center"
          },
          import_react60.default.createElement(
            Box,
            {
              className: touchableStyles({
                active: "shrink",
                hover: "grow"
              }),
              cursor: "pointer",
              onClick: () => changeWalletStep(
                "LEARN_COMPACT"
                /* LearnCompact */
              ),
              paddingY: "4",
              style: { willChange: "transform" },
              transition: "default"
            },
            import_react60.default.createElement(Text, { color: "accentColor", size: "14", weight: "bold" }, i18n2.t("connect.new_to_ethereum.learn_more.label"))
          )
        )
      ))
    ),
    (compactModeEnabled ? walletStep !== "NONE" : true) && import_react60.default.createElement(import_react60.default.Fragment, null, !compactModeEnabled && import_react60.default.createElement(Box, { background: "generalBorder", minWidth: "1", width: "1" }), import_react60.default.createElement(
      Box,
      {
        display: "flex",
        flexDirection: "column",
        margin: "16",
        style: { flexGrow: 1 }
      },
      import_react60.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          justifyContent: "space-between",
          marginBottom: "12"
        },
        import_react60.default.createElement(Box, { width: "28" }, headerBackButtonLink && import_react60.default.createElement(
          Box,
          {
            as: "button",
            className: touchableStyles({
              active: "shrinkSm",
              hover: "growLg"
            }),
            color: "accentColor",
            onClick: () => {
              headerBackButtonLink && changeWalletStep(headerBackButtonLink, true);
              headerBackButtonCallback == null ? void 0 : headerBackButtonCallback();
            },
            paddingX: "8",
            paddingY: "4",
            style: {
              boxSizing: "content-box",
              height: 17,
              willChange: "transform"
            },
            transition: "default",
            type: "button"
          },
          import_react60.default.createElement(BackIcon, null)
        )),
        import_react60.default.createElement(
          Box,
          {
            display: "flex",
            justifyContent: "center",
            style: { flexGrow: 1 }
          },
          headerLabel && import_react60.default.createElement(
            Text,
            {
              color: "modalText",
              size: "18",
              textAlign: "center",
              weight: "heavy"
            },
            headerLabel
          )
        ),
        import_react60.default.createElement(CloseButton, { onClose })
      ),
      import_react60.default.createElement(
        Box,
        {
          display: "flex",
          flexDirection: "column",
          style: { minHeight: compactModeEnabled ? 396 : 432 }
        },
        import_react60.default.createElement(
          Box,
          {
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
            gap: "6",
            height: "full",
            justifyContent: "center",
            marginX: "8"
          },
          walletContent
        )
      )
    ))
  );
}
var rotatingBorder = "_1am14412";
var scroll = "_1am14410";
var spinner = "_1am14413";
var LoadingSpinner = ({ wallet }) => {
  const width = 80;
  const height = 80;
  const radiusFactor = 20;
  const perimeter = 2 * (width + height - 4 * radiusFactor);
  return import_react75.default.createElement("svg", { className: spinner, viewBox: "0 0 86 86", width: "86", height: "86" }, import_react75.default.createElement("title", null, "Loading"), import_react75.default.createElement(
    "rect",
    {
      x: "3",
      y: "3",
      width,
      height,
      rx: radiusFactor,
      ry: radiusFactor,
      strokeDasharray: `${perimeter / 3} ${2 * perimeter / 3}`,
      strokeDashoffset: perimeter,
      className: rotatingBorder,
      style: {
        // Prop style passing works only in `@vanilla-extract/recipes`.
        // Instead downloading packages we can do this
        // manually without passing props
        stroke: (wallet == null ? void 0 : wallet.iconAccent) || "#0D3887"
      }
    }
  ));
};
function WalletButton({
  onClose,
  wallet,
  connecting
}) {
  const {
    connect,
    iconBackground,
    iconUrl,
    id,
    name,
    getMobileUri,
    ready,
    shortName,
    showWalletConnectModal
  } = wallet;
  const coolModeRef = useCoolMode(iconUrl);
  const initialized = (0, import_react75.useRef)(false);
  const { i18n: i18n2 } = (0, import_react75.useContext)(I18nContext);
  const onConnect = (0, import_react75.useCallback)(async () => {
    const onMobileUri = async () => {
      const mobileUri = await (getMobileUri == null ? void 0 : getMobileUri());
      if (!mobileUri) return;
      if (mobileUri) {
        setWalletConnectDeepLink({ mobileUri, name });
      }
      if (mobileUri.startsWith("http")) {
        const link = document.createElement("a");
        link.href = mobileUri;
        link.target = "_blank";
        link.rel = "noreferrer noopener";
        link.click();
      } else {
        window.location.href = mobileUri;
      }
    };
    if (id !== "walletConnect") onMobileUri();
    if (showWalletConnectModal) {
      showWalletConnectModal();
      onClose == null ? void 0 : onClose();
      return;
    }
    try {
      await (connect == null ? void 0 : connect());
    } catch {
    }
  }, [connect, getMobileUri, showWalletConnectModal, onClose, name, id]);
  (0, import_react75.useEffect)(() => {
    if (connecting && !initialized.current) {
      onConnect();
      initialized.current = true;
    }
  }, [connecting, onConnect]);
  return import_react75.default.createElement(
    Box,
    {
      as: "button",
      color: ready ? "modalText" : "modalTextSecondary",
      disabled: !ready,
      fontFamily: "body",
      key: id,
      onClick: onConnect,
      ref: coolModeRef,
      style: { overflow: "visible", textAlign: "center" },
      testId: `wallet-option-${id}`,
      type: "button",
      width: "full"
    },
    import_react75.default.createElement(
      Box,
      {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center"
      },
      import_react75.default.createElement(
        Box,
        {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          paddingBottom: "8",
          paddingTop: "10",
          position: "relative"
        },
        connecting ? import_react75.default.createElement(LoadingSpinner, { wallet }) : null,
        import_react75.default.createElement(
          AsyncImage,
          {
            background: iconBackground,
            borderRadius: "13",
            boxShadow: "walletLogo",
            height: "60",
            src: iconUrl,
            width: "60"
          }
        )
      ),
      !connecting ? import_react75.default.createElement(Box, { display: "flex", flexDirection: "column", textAlign: "center" }, import_react75.default.createElement(
        Text,
        {
          as: "h2",
          color: wallet.ready ? "modalText" : "modalTextSecondary",
          size: "13",
          weight: "medium"
        },
        import_react75.default.createElement(Box, { as: "span", position: "relative" }, shortName ?? name, !wallet.ready && " (unsupported)")
      ), wallet.recent && import_react75.default.createElement(Text, { color: "accentColor", size: "12", weight: "medium" }, i18n2.t("connect.recent"))) : null
    )
  );
}
function MobileOptions({ onClose }) {
  var _a;
  const titleId = "rk_connect_title";
  const wallets = useWalletConnectors().filter(
    (wallet) => wallet.isRainbowKitConnector
  );
  const { disclaimer: Disclaimer, learnMoreUrl } = (0, import_react75.useContext)(AppContext);
  let headerLabel = null;
  let walletContent = null;
  let headerBackgroundContrast = false;
  let headerBackButtonLink = null;
  const [walletStep, setWalletStep] = (0, import_react75.useState)(
    "CONNECT"
    /* Connect */
  );
  const { i18n: i18n2 } = (0, import_react75.useContext)(I18nContext);
  const ios = isIOS();
  switch (walletStep) {
    case "CONNECT": {
      headerLabel = i18n2.t("connect.title");
      headerBackgroundContrast = true;
      walletContent = import_react75.default.createElement(Box, null, import_react75.default.createElement(
        Box,
        {
          background: "profileForeground",
          className: scroll,
          display: "flex",
          paddingBottom: "20",
          paddingTop: "6"
        },
        import_react75.default.createElement(Box, { display: "flex", style: { margin: "0 auto" } }, wallets.filter((wallet) => wallet.ready).map((wallet) => {
          return import_react75.default.createElement(Box, { key: wallet.id, paddingX: "20" }, import_react75.default.createElement(Box, { width: "60" }, import_react75.default.createElement(WalletButton, { onClose, wallet })));
        }))
      ), import_react75.default.createElement(
        Box,
        {
          background: "generalBorder",
          height: "1",
          marginBottom: "32",
          marginTop: "-1"
        }
      ), import_react75.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: "32",
          paddingX: "32",
          style: { textAlign: "center" }
        },
        import_react75.default.createElement(
          Box,
          {
            display: "flex",
            flexDirection: "column",
            gap: "8",
            textAlign: "center"
          },
          import_react75.default.createElement(Text, { color: "modalText", size: "16", weight: "bold" }, i18n2.t("intro.title")),
          import_react75.default.createElement(Text, { color: "modalTextSecondary", size: "16" }, i18n2.t("intro.description"))
        )
      ), import_react75.default.createElement(Box, { paddingTop: "32", paddingX: "20" }, import_react75.default.createElement(Box, { display: "flex", gap: "14", justifyContent: "center" }, import_react75.default.createElement(
        ActionButton,
        {
          label: i18n2.t("intro.get.label"),
          onClick: () => setWalletStep(
            "GET"
            /* Get */
          ),
          size: "large",
          type: "secondary"
        }
      ), import_react75.default.createElement(
        ActionButton,
        {
          href: learnMoreUrl,
          label: i18n2.t("intro.learn_more.label"),
          size: "large",
          type: "secondary"
        }
      ))), Disclaimer && import_react75.default.createElement(Box, { marginTop: "28", marginX: "32", textAlign: "center" }, import_react75.default.createElement(Disclaimer, { Link: DisclaimerLink, Text: DisclaimerText })));
      break;
    }
    case "GET": {
      headerLabel = i18n2.t("get.title");
      headerBackButtonLink = "CONNECT";
      const mobileWallets = (_a = wallets == null ? void 0 : wallets.filter(
        (wallet) => {
          var _a2, _b, _c;
          return ((_a2 = wallet.downloadUrls) == null ? void 0 : _a2.ios) || ((_b = wallet.downloadUrls) == null ? void 0 : _b.android) || ((_c = wallet.downloadUrls) == null ? void 0 : _c.mobile);
        }
      )) == null ? void 0 : _a.splice(0, 3);
      walletContent = import_react75.default.createElement(Box, null, import_react75.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          height: "full",
          marginBottom: "36",
          marginTop: "5",
          paddingTop: "12",
          width: "full"
        },
        mobileWallets.map((wallet, index2) => {
          const { downloadUrls, iconBackground, iconUrl, name } = wallet;
          if (!(downloadUrls == null ? void 0 : downloadUrls.ios) && !(downloadUrls == null ? void 0 : downloadUrls.android) && !(downloadUrls == null ? void 0 : downloadUrls.mobile)) {
            return null;
          }
          return import_react75.default.createElement(
            Box,
            {
              display: "flex",
              gap: "16",
              key: wallet.id,
              paddingX: "20",
              width: "full"
            },
            import_react75.default.createElement(Box, { style: { minHeight: 48, minWidth: 48 } }, import_react75.default.createElement(
              AsyncImage,
              {
                background: iconBackground,
                borderColor: "generalBorder",
                borderRadius: "10",
                height: "48",
                src: iconUrl,
                width: "48"
              }
            )),
            import_react75.default.createElement(Box, { display: "flex", flexDirection: "column", width: "full" }, import_react75.default.createElement(Box, { alignItems: "center", display: "flex", height: "48" }, import_react75.default.createElement(Box, { width: "full" }, import_react75.default.createElement(Text, { color: "modalText", size: "18", weight: "bold" }, name)), import_react75.default.createElement(
              ActionButton,
              {
                href: (ios ? downloadUrls == null ? void 0 : downloadUrls.ios : downloadUrls == null ? void 0 : downloadUrls.android) || (downloadUrls == null ? void 0 : downloadUrls.mobile),
                label: i18n2.t("get.action.label"),
                size: "small",
                type: "secondary"
              }
            )), index2 < mobileWallets.length - 1 && import_react75.default.createElement(
              Box,
              {
                background: "generalBorderDim",
                height: "1",
                marginY: "10",
                width: "full"
              }
            ))
          );
        })
      ), import_react75.default.createElement(Box, { style: { marginBottom: "42px" } }), import_react75.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          flexDirection: "column",
          gap: "36",
          paddingX: "36",
          style: { textAlign: "center" }
        },
        import_react75.default.createElement(
          Box,
          {
            display: "flex",
            flexDirection: "column",
            gap: "12",
            textAlign: "center"
          },
          import_react75.default.createElement(Text, { color: "modalText", size: "16", weight: "bold" }, i18n2.t("get.looking_for.title")),
          import_react75.default.createElement(Text, { color: "modalTextSecondary", size: "16" }, i18n2.t("get.looking_for.mobile.description"))
        )
      ));
      break;
    }
  }
  return import_react75.default.createElement(Box, { display: "flex", flexDirection: "column", paddingBottom: "36" }, import_react75.default.createElement(
    Box,
    {
      background: headerBackgroundContrast ? "profileForeground" : "modalBackground",
      display: "flex",
      flexDirection: "column",
      paddingBottom: "4",
      paddingTop: "14"
    },
    import_react75.default.createElement(
      Box,
      {
        display: "flex",
        justifyContent: "center",
        paddingBottom: "6",
        paddingX: "20",
        position: "relative"
      },
      headerBackButtonLink && import_react75.default.createElement(
        Box,
        {
          display: "flex",
          position: "absolute",
          style: {
            left: 0,
            marginBottom: -20,
            marginTop: -20
          }
        },
        import_react75.default.createElement(
          Box,
          {
            alignItems: "center",
            as: "button",
            className: touchableStyles({
              active: "shrinkSm",
              hover: "growLg"
            }),
            color: "accentColor",
            display: "flex",
            marginLeft: "4",
            marginTop: "20",
            onClick: () => setWalletStep(headerBackButtonLink),
            padding: "16",
            style: { height: 17, willChange: "transform" },
            transition: "default",
            type: "button"
          },
          import_react75.default.createElement(BackIcon, null)
        )
      ),
      import_react75.default.createElement(Box, { marginTop: "4", textAlign: "center", width: "full" }, import_react75.default.createElement(
        Text,
        {
          as: "h1",
          color: "modalText",
          id: titleId,
          size: "20",
          weight: "bold"
        },
        headerLabel
      )),
      import_react75.default.createElement(
        Box,
        {
          alignItems: "center",
          display: "flex",
          height: "32",
          paddingRight: "14",
          position: "absolute",
          right: "0"
        },
        import_react75.default.createElement(
          Box,
          {
            style: { marginBottom: -20, marginTop: -20 }
          },
          import_react75.default.createElement(CloseButton, { onClose })
        )
      )
    )
  ), import_react75.default.createElement(Box, { display: "flex", flexDirection: "column" }, walletContent));
}
var MobileStatus = ({ onClose }) => {
  const { connector } = (0, import_react76.useContext)(WalletButtonContext);
  const { i18n: i18n2 } = (0, import_react76.useContext)(I18nContext);
  const connectorName = (connector == null ? void 0 : connector.name) || "";
  return import_react76.default.createElement(Box, null, import_react76.default.createElement(
    Box,
    {
      display: "flex",
      paddingBottom: "32",
      justifyContent: "center",
      alignItems: "center",
      background: "profileForeground",
      flexDirection: "column"
    },
    import_react76.default.createElement(
      Box,
      {
        width: "full",
        display: "flex",
        justifyContent: "flex-end",
        marginTop: "18",
        marginRight: "24"
      },
      import_react76.default.createElement(CloseButton, { onClose })
    ),
    import_react76.default.createElement(Box, { width: "60" }, import_react76.default.createElement(WalletButton, { onClose, wallet: connector, connecting: true })),
    import_react76.default.createElement(Box, { marginTop: "20" }, import_react76.default.createElement(
      Text,
      {
        textAlign: "center",
        color: "modalText",
        size: "18",
        weight: "semibold"
      },
      i18n2.t("connect.status.connect_mobile", {
        wallet: connectorName
      })
    )),
    import_react76.default.createElement(Box, { maxWidth: "full", marginTop: "8" }, import_react76.default.createElement(Text, { textAlign: "center", color: "modalText", size: "16", weight: "medium" }, i18n2.t("connect.status.confirm_mobile", {
      wallet: connectorName
    })))
  ));
};
function ConnectOptions({ onClose }) {
  const { connector } = (0, import_react59.useContext)(WalletButtonContext);
  return isMobile() ? connector ? import_react59.default.createElement(MobileStatus, { onClose }) : import_react59.default.createElement(MobileOptions, { onClose }) : import_react59.default.createElement(DesktopOptions, { onClose });
}
function ConnectModal({ onClose, open }) {
  const titleId = "rk_connect_title";
  const connectionStatus = useConnectionStatus();
  const { disconnect } = useDisconnect();
  const { isConnecting } = useAccount();
  const onAuthCancel = import_react58.default.useCallback(() => {
    onClose();
    disconnect();
  }, [onClose, disconnect]);
  const onConnectModalCancel = import_react58.default.useCallback(() => {
    if (isConnecting) disconnect();
    onClose();
  }, [onClose, disconnect, isConnecting]);
  if (connectionStatus === "disconnected") {
    return import_react58.default.createElement(Dialog, { onClose: onConnectModalCancel, open, titleId }, import_react58.default.createElement(DialogContent, { bottomSheetOnMobile: true, padding: "0", wide: true }, import_react58.default.createElement(ConnectOptions, { onClose: onConnectModalCancel })));
  }
  if (connectionStatus === "unauthenticated") {
    return import_react58.default.createElement(Dialog, { onClose: onAuthCancel, open, titleId }, import_react58.default.createElement(DialogContent, { bottomSheetOnMobile: true, padding: "0" }, import_react58.default.createElement(SignIn, { onClose: onAuthCancel, onCloseModal: onClose })));
  }
  return null;
}
function useModalStateValue() {
  const [isModalOpen, setModalOpen] = (0, import_react21.useState)(false);
  return {
    closeModal: (0, import_react21.useCallback)(() => setModalOpen(false), []),
    isModalOpen,
    openModal: (0, import_react21.useCallback)(() => setModalOpen(true), [])
  };
}
var ModalContext = (0, import_react21.createContext)({
  accountModalOpen: false,
  chainModalOpen: false,
  connectModalOpen: false,
  isWalletConnectModalOpen: false,
  setIsWalletConnectModalOpen: () => {
  }
});
function ModalProvider({ children }) {
  const {
    closeModal: closeConnectModal,
    isModalOpen: connectModalOpen,
    openModal: openConnectModal
  } = useModalStateValue();
  const {
    closeModal: closeAccountModal,
    isModalOpen: accountModalOpen,
    openModal: openAccountModal
  } = useModalStateValue();
  const {
    closeModal: closeChainModal,
    isModalOpen: chainModalOpen,
    openModal: openChainModal
  } = useModalStateValue();
  const [isWalletConnectModalOpen, setIsWalletConnectModalOpen] = (0, import_react21.useState)(false);
  const connectionStatus = useConnectionStatus();
  const { chainId } = useAccount();
  const { chains } = useConfig();
  const isCurrentChainSupported = chains.some((chain) => chain.id === chainId);
  const closeModals = (0, import_react21.useCallback)(
    ({ keepConnectModalOpen = false } = {}) => {
      if (!keepConnectModalOpen) {
        closeConnectModal();
      }
      closeAccountModal();
      closeChainModal();
    },
    [closeConnectModal, closeAccountModal, closeChainModal]
  );
  const isUnauthenticated = useAuthenticationStatus() === "unauthenticated";
  useAccountEffect({
    onConnect: () => closeModals({ keepConnectModalOpen: isUnauthenticated }),
    onDisconnect: () => closeModals()
  });
  (0, import_react21.useEffect)(() => {
    if (isUnauthenticated) closeModals();
  }, [isUnauthenticated, closeModals]);
  return import_react21.default.createElement(
    ModalContext.Provider,
    {
      value: (0, import_react21.useMemo)(
        () => ({
          accountModalOpen,
          chainModalOpen,
          connectModalOpen,
          isWalletConnectModalOpen,
          openAccountModal: isCurrentChainSupported && connectionStatus === "connected" ? openAccountModal : void 0,
          openChainModal: connectionStatus === "connected" ? openChainModal : void 0,
          openConnectModal: connectionStatus === "disconnected" || connectionStatus === "unauthenticated" ? openConnectModal : void 0,
          setIsWalletConnectModalOpen
        }),
        [
          connectionStatus,
          accountModalOpen,
          chainModalOpen,
          connectModalOpen,
          openAccountModal,
          openChainModal,
          openConnectModal,
          isCurrentChainSupported,
          isWalletConnectModalOpen
        ]
      )
    },
    children,
    import_react21.default.createElement(ConnectModal, { onClose: closeConnectModal, open: connectModalOpen }),
    import_react21.default.createElement(AccountModal, { onClose: closeAccountModal, open: accountModalOpen }),
    import_react21.default.createElement(ChainModal, { onClose: closeChainModal, open: chainModalOpen })
  );
}
function useModalState() {
  const { accountModalOpen, chainModalOpen, connectModalOpen } = (0, import_react21.useContext)(ModalContext);
  return {
    accountModalOpen,
    chainModalOpen,
    connectModalOpen
  };
}
function useAccountModal() {
  const { accountModalOpen, openAccountModal } = (0, import_react21.useContext)(ModalContext);
  return { accountModalOpen, openAccountModal };
}
function useChainModal() {
  const { chainModalOpen, openChainModal } = (0, import_react21.useContext)(ModalContext);
  return { chainModalOpen, openChainModal };
}
function useWalletConnectOpenState() {
  const { isWalletConnectModalOpen, setIsWalletConnectModalOpen } = (0, import_react21.useContext)(ModalContext);
  return { isWalletConnectModalOpen, setIsWalletConnectModalOpen };
}
function useConnectModal() {
  const { connectModalOpen, openConnectModal } = (0, import_react21.useContext)(ModalContext);
  const { isWalletConnectModalOpen } = useWalletConnectOpenState();
  return {
    connectModalOpen: connectModalOpen || isWalletConnectModalOpen,
    openConnectModal
  };
}
var noop = () => {
};
function ConnectButtonRenderer({
  children
}) {
  const isMounted = useIsMounted();
  const { address } = useAccount();
  const { chainId } = useAccount();
  const { chains: wagmiChains } = useConfig();
  const isCurrentChainSupported = wagmiChains.some(
    (chain) => chain.id === chainId
  );
  const rainbowkitChainsById = useRainbowKitChainsById();
  const authenticationStatus = useAuthenticationStatus() ?? void 0;
  const rainbowKitChain = chainId ? rainbowkitChainsById[chainId] : void 0;
  const chainName = (rainbowKitChain == null ? void 0 : rainbowKitChain.name) ?? void 0;
  const chainIconUrl = (rainbowKitChain == null ? void 0 : rainbowKitChain.iconUrl) ?? void 0;
  const chainIconBackground = (rainbowKitChain == null ? void 0 : rainbowKitChain.iconBackground) ?? void 0;
  const resolvedChainIconUrl = useAsyncImage(chainIconUrl);
  const showRecentTransactions = (0, import_react17.useContext)(ShowRecentTransactionsContext);
  const hasPendingTransactions = useRecentTransactions().some(({ status }) => status === "pending") && showRecentTransactions;
  const { showBalance } = useShowBalance();
  const computeShouldShowBalance = () => {
    if (typeof showBalance === "boolean") {
      return showBalance;
    }
    if (showBalance) {
      return normalizeResponsiveValue(showBalance)[isMobile() ? "smallScreen" : "largeScreen"];
    }
    return true;
  };
  const shouldShowBalance = computeShouldShowBalance();
  const { balance, ensAvatar, ensName } = useProfile({
    address,
    includeBalance: shouldShowBalance
  });
  const displayBalance = balance ? `${abbreviateETHBalance(Number.parseFloat(balance.formatted))} ${balance.symbol}` : void 0;
  const { openConnectModal } = useConnectModal();
  const { openChainModal } = useChainModal();
  const { openAccountModal } = useAccountModal();
  const { accountModalOpen, chainModalOpen, connectModalOpen } = useModalState();
  return import_react17.default.createElement(import_react17.default.Fragment, null, children({
    account: address ? {
      address,
      balanceDecimals: balance == null ? void 0 : balance.decimals,
      balanceFormatted: balance == null ? void 0 : balance.formatted,
      balanceSymbol: balance == null ? void 0 : balance.symbol,
      displayBalance,
      displayName: ensName ? formatENS(ensName) : formatAddress(address),
      ensAvatar: ensAvatar ?? void 0,
      ensName: ensName ?? void 0,
      hasPendingTransactions
    } : void 0,
    accountModalOpen,
    authenticationStatus,
    chain: chainId ? {
      hasIcon: Boolean(chainIconUrl),
      iconBackground: chainIconBackground,
      iconUrl: resolvedChainIconUrl,
      id: chainId,
      name: chainName,
      unsupported: !isCurrentChainSupported
    } : void 0,
    chainModalOpen,
    connectModalOpen,
    mounted: isMounted(),
    openAccountModal: openAccountModal ?? noop,
    openChainModal: openChainModal ?? noop,
    openConnectModal: openConnectModal ?? noop
  }));
}
ConnectButtonRenderer.displayName = "ConnectButton.Custom";
var defaultProps = {
  accountStatus: "full",
  chainStatus: { largeScreen: "full", smallScreen: "icon" },
  label: "Connect Wallet",
  showBalance: { largeScreen: true, smallScreen: false }
};
function ConnectButton({
  accountStatus = defaultProps.accountStatus,
  chainStatus = defaultProps.chainStatus,
  label = defaultProps.label,
  showBalance = defaultProps.showBalance
}) {
  const chains = useRainbowKitChains();
  const connectionStatus = useConnectionStatus();
  const { setShowBalance } = useShowBalance();
  const [ready, setReady] = (0, import_react4.useState)(false);
  const { i18n: i18n2 } = (0, import_react4.useContext)(I18nContext);
  (0, import_react4.useEffect)(() => {
    setShowBalance(showBalance);
    if (!ready) setReady(true);
  }, [showBalance, setShowBalance]);
  return ready ? import_react4.default.createElement(ConnectButtonRenderer, null, ({
    account,
    chain,
    mounted,
    openAccountModal,
    openChainModal,
    openConnectModal
  }) => {
    const ready2 = mounted && connectionStatus !== "loading";
    const unsupportedChain = (chain == null ? void 0 : chain.unsupported) ?? false;
    return import_react4.default.createElement(
      Box,
      {
        display: "flex",
        gap: "12",
        ...!ready2 && {
          "aria-hidden": true,
          style: {
            opacity: 0,
            pointerEvents: "none",
            userSelect: "none"
          }
        }
      },
      ready2 && account && connectionStatus === "connected" ? import_react4.default.createElement(import_react4.default.Fragment, null, chain && (chains.length > 1 || unsupportedChain) && import_react4.default.createElement(
        Box,
        {
          alignItems: "center",
          "aria-label": "Chain Selector",
          as: "button",
          background: unsupportedChain ? "connectButtonBackgroundError" : "connectButtonBackground",
          borderRadius: "connectButton",
          boxShadow: "connectButton",
          className: touchableStyles({
            active: "shrink",
            hover: "grow"
          }),
          color: unsupportedChain ? "connectButtonTextError" : "connectButtonText",
          display: mapResponsiveValue(
            chainStatus,
            (value) => value === "none" ? "none" : "flex"
          ),
          fontFamily: "body",
          fontWeight: "bold",
          gap: "6",
          key: (
            // Force re-mount to prevent CSS transition
            unsupportedChain ? "unsupported" : "supported"
          ),
          onClick: openChainModal,
          paddingX: "10",
          paddingY: "8",
          testId: unsupportedChain ? "wrong-network-button" : "chain-button",
          transition: "default",
          type: "button"
        },
        unsupportedChain ? import_react4.default.createElement(
          Box,
          {
            alignItems: "center",
            display: "flex",
            height: "24",
            paddingX: "4"
          },
          i18n2.t("connect_wallet.wrong_network.label")
        ) : import_react4.default.createElement(Box, { alignItems: "center", display: "flex", gap: "6" }, chain.hasIcon ? import_react4.default.createElement(
          Box,
          {
            display: mapResponsiveValue(
              chainStatus,
              (value) => value === "full" || value === "icon" ? "block" : "none"
            ),
            height: "24",
            width: "24"
          },
          import_react4.default.createElement(
            AsyncImage,
            {
              alt: chain.name ?? "Chain icon",
              background: chain.iconBackground,
              borderRadius: "full",
              height: "24",
              src: chain.iconUrl,
              width: "24"
            }
          )
        ) : null, import_react4.default.createElement(
          Box,
          {
            display: mapResponsiveValue(chainStatus, (value) => {
              if (value === "icon" && !chain.iconUrl) {
                return "block";
              }
              return value === "full" || value === "name" ? "block" : "none";
            })
          },
          chain.name ?? chain.id
        )),
        import_react4.default.createElement(DropdownIcon, null)
      ), !unsupportedChain && import_react4.default.createElement(
        Box,
        {
          alignItems: "center",
          as: "button",
          background: "connectButtonBackground",
          borderRadius: "connectButton",
          boxShadow: "connectButton",
          className: touchableStyles({
            active: "shrink",
            hover: "grow"
          }),
          color: "connectButtonText",
          display: "flex",
          fontFamily: "body",
          fontWeight: "bold",
          onClick: openAccountModal,
          testId: "account-button",
          transition: "default",
          type: "button"
        },
        account.displayBalance && import_react4.default.createElement(
          Box,
          {
            display: mapResponsiveValue(
              showBalance,
              (value) => value ? "block" : "none"
            ),
            padding: "8",
            paddingLeft: "12"
          },
          account.displayBalance
        ),
        import_react4.default.createElement(
          Box,
          {
            background: normalizeResponsiveValue(showBalance)[isMobile() ? "smallScreen" : "largeScreen"] ? "connectButtonInnerBackground" : "connectButtonBackground",
            borderColor: "connectButtonBackground",
            borderRadius: "connectButton",
            borderStyle: "solid",
            borderWidth: "2",
            color: "connectButtonText",
            fontFamily: "body",
            fontWeight: "bold",
            paddingX: "8",
            paddingY: "6",
            transition: "default"
          },
          import_react4.default.createElement(
            Box,
            {
              alignItems: "center",
              display: "flex",
              gap: "6",
              height: "24"
            },
            import_react4.default.createElement(
              Box,
              {
                display: mapResponsiveValue(
                  accountStatus,
                  (value) => value === "full" || value === "avatar" ? "block" : "none"
                )
              },
              import_react4.default.createElement(
                Avatar,
                {
                  address: account.address,
                  imageUrl: account.ensAvatar,
                  loading: account.hasPendingTransactions,
                  size: 24
                }
              )
            ),
            import_react4.default.createElement(Box, { alignItems: "center", display: "flex", gap: "6" }, import_react4.default.createElement(
              Box,
              {
                display: mapResponsiveValue(
                  accountStatus,
                  (value) => value === "full" || value === "address" ? "block" : "none"
                )
              },
              account.displayName
            ), import_react4.default.createElement(DropdownIcon, null))
          )
        )
      )) : import_react4.default.createElement(
        Box,
        {
          as: "button",
          background: "accentColor",
          borderRadius: "connectButton",
          boxShadow: "connectButton",
          className: touchableStyles({
            active: "shrink",
            hover: "grow"
          }),
          color: "accentColorForeground",
          fontFamily: "body",
          fontWeight: "bold",
          height: "40",
          key: "connect",
          onClick: openConnectModal,
          paddingX: "14",
          testId: "connect-button",
          transition: "default",
          type: "button"
        },
        mounted && label === "Connect Wallet" ? i18n2.t("connect_wallet.label") : label
      )
    );
  }) : import_react4.default.createElement(import_react4.default.Fragment, null);
}
ConnectButton.__defaultProps = defaultProps;
ConnectButton.Custom = ConnectButtonRenderer;
var border = "_1y2lnfi0";
var maxWidth = "_1y2lnfi1";
function WalletButtonRenderer({
  // Wallet is the same as `connector.id` which is injected into
  // wagmi connectors
  wallet = "rainbow",
  children
}) {
  const isMounted = useIsMounted();
  const { openConnectModal } = useConnectModal();
  const { connectModalOpen } = useModalState();
  const { connector, setConnector } = (0, import_react78.useContext)(WalletButtonContext);
  const [firstConnector] = useWalletConnectors().filter((wallet2) => wallet2.isRainbowKitConnector).filter((_wallet) => _wallet.id.toLowerCase() === wallet.toLowerCase()).sort((a, b) => a.groupIndex - b.groupIndex);
  if (!firstConnector) {
    throw new Error("Connector not found");
  }
  const connectionStatus = useConnectionStatus();
  const [loading, setLoading] = (0, import_react78.useState)(false);
  const [isError, setIsError] = (0, import_react78.useState)(false);
  const mobile = isMobile();
  (0, import_react78.useEffect)(() => {
    if (!connectModalOpen && connector) setConnector(null);
  }, [connectModalOpen, connector, setConnector]);
  const { isConnected, isConnecting } = useAccount();
  useAccountEffect({
    onConnect: () => {
      if (isError) setIsError(false);
    },
    onDisconnect: clearLatestWalletId
  });
  const isLastWalletIdConnected = (0, import_react78.useMemo)(() => {
    const lastWalletId = getLatestWalletId();
    if (!lastWalletId || !(firstConnector == null ? void 0 : firstConnector.id)) {
      return false;
    }
    if (!isConnected) return false;
    return lastWalletId === (firstConnector == null ? void 0 : firstConnector.id);
  }, [isConnected, firstConnector]);
  const connectWallet = async () => {
    var _a;
    try {
      setLoading(true);
      if (isError) setIsError(false);
      await ((_a = firstConnector == null ? void 0 : firstConnector.connect) == null ? void 0 : _a.call(firstConnector));
    } catch {
      setIsError(true);
    } finally {
      setLoading(false);
    }
  };
  const isStatusLoading = connectionStatus === "loading";
  const ready = !isConnecting && !!openConnectModal && firstConnector && !isStatusLoading;
  const isNotSupported = !(firstConnector == null ? void 0 : firstConnector.installed) || !(firstConnector == null ? void 0 : firstConnector.ready);
  return import_react78.default.createElement(import_react78.default.Fragment, null, children({
    error: isError,
    loading,
    connected: isLastWalletIdConnected,
    ready,
    mounted: isMounted(),
    connector: firstConnector,
    connect: async () => {
      addLatestWalletId((firstConnector == null ? void 0 : firstConnector.id) || "");
      if (mobile || isNotSupported) {
        openConnectModal == null ? void 0 : openConnectModal();
        setConnector(firstConnector);
        return;
      }
      await connectWallet();
    }
  }));
}
var WalletButton2 = ({ wallet }) => {
  return import_react77.default.createElement(WalletButtonRenderer, { wallet }, ({ ready, connect, connected, mounted, connector, loading }) => {
    const isDisabled = !ready || loading;
    const { i18n: i18n2 } = (0, import_react77.useContext)(I18nContext);
    const connectorName = (connector == null ? void 0 : connector.name) || "";
    if (!mounted) return;
    return import_react77.default.createElement(
      Box,
      {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        disabled: isDisabled,
        pointerEvents: isDisabled ? "none" : "all"
      },
      import_react77.default.createElement(
        Box,
        {
          as: "button",
          borderRadius: "menuButton",
          borderStyle: "solid",
          borderWidth: "1",
          className: [
            maxWidth,
            border,
            touchableStyles({
              active: "shrink",
              hover: "grow"
            })
          ],
          minHeight: "44",
          onClick: connect,
          disabled: !ready || loading,
          padding: "6",
          style: { willChange: "transform" },
          testId: `wallet-button-${(connector == null ? void 0 : connector.id) || ""}`,
          transition: "default",
          width: "full",
          background: "connectButtonBackground"
        },
        import_react77.default.createElement(
          Box,
          {
            color: "modalText",
            fontFamily: "body",
            fontSize: "16",
            fontWeight: "bold",
            transition: "default",
            display: "flex",
            alignItems: "center"
          },
          import_react77.default.createElement(
            Box,
            {
              alignItems: "center",
              display: "flex",
              flexDirection: "row",
              gap: "12",
              paddingRight: "6"
            },
            import_react77.default.createElement(Box, null, loading ? import_react77.default.createElement(SpinnerIcon, null) : import_react77.default.createElement(
              AsyncImage,
              {
                background: connector == null ? void 0 : connector.iconBackground,
                borderRadius: "6",
                height: "28",
                src: connector == null ? void 0 : connector.iconUrl,
                width: "28"
              }
            )),
            import_react77.default.createElement(
              Box,
              {
                alignItems: "center",
                display: "flex",
                flexDirection: "column",
                color: "modalText"
              },
              import_react77.default.createElement(Box, { testId: `wallet-button-label-${(connector == null ? void 0 : connector.id) || ""}` }, loading ? i18n2.t("connect.status.connecting", {
                wallet: connectorName
              }) : connectorName)
            ),
            connected ? import_react77.default.createElement(
              Box,
              {
                background: "connectionIndicator",
                borderColor: "selectedOptionBorder",
                borderRadius: "full",
                borderStyle: "solid",
                borderWidth: "1",
                height: "8",
                width: "8"
              }
            ) : null
          )
        )
      )
    );
  });
};
WalletButton2.Custom = WalletButtonRenderer;
var computeWalletConnectMetaData = ({
  appName,
  appDescription,
  appUrl,
  appIcon
}) => {
  return {
    name: appName,
    description: appDescription ?? appName,
    url: appUrl ?? (typeof window !== "undefined" ? window.location.origin : ""),
    icons: [...appIcon ? [appIcon] : []]
  };
};
function omitUndefinedValues(obj) {
  return Object.fromEntries(
    //@ts-ignore
    Object.entries(obj).filter(([_key, value]) => value !== void 0)
  );
}
function uniqueBy(items, key) {
  const filtered = [];
  for (const item of items) {
    if (!filtered.some((x) => x[key] === item[key])) {
      filtered.push(item);
    }
  }
  return filtered;
}
var connectorsForWallets = (walletList, {
  projectId,
  walletConnectParameters,
  appName,
  appDescription,
  appUrl,
  appIcon
}) => {
  if (!walletList.length) {
    throw new Error("No wallet list was provided");
  }
  for (const { wallets, groupName } of walletList) {
    if (!wallets.length) {
      throw new Error(`No wallets provided for group: ${groupName}`);
    }
  }
  let index2 = -1;
  const connectors = [];
  const visibleWallets = [];
  const potentiallyHiddenWallets = [];
  const walletConnectMetaData = computeWalletConnectMetaData({
    appName,
    appDescription,
    appUrl,
    appIcon
  });
  for (const [groupIndex, { groupName, wallets }] of walletList.entries()) {
    for (const createWallet of wallets) {
      index2++;
      const wallet = createWallet({
        projectId,
        appName,
        appIcon,
        // `option` is being used only for `walletConnectWallet` wallet
        options: {
          metadata: walletConnectMetaData,
          ...walletConnectParameters
        },
        // Every other wallet that supports walletConnect flow and is not
        // `walletConnectWallet` wallet will have `walletConnectParameters` property
        walletConnectParameters: {
          metadata: walletConnectMetaData,
          ...walletConnectParameters
        }
      });
      if ((wallet == null ? void 0 : wallet.iconAccent) && !isHexString(wallet == null ? void 0 : wallet.iconAccent)) {
        throw new Error(
          `Property \`iconAccent\` is not a hex value for wallet: ${wallet.name}`
        );
      }
      const walletListItem = {
        ...wallet,
        groupIndex: groupIndex + 1,
        groupName,
        index: index2
      };
      if (typeof wallet.hidden === "function") {
        potentiallyHiddenWallets.push(walletListItem);
      } else {
        visibleWallets.push(walletListItem);
      }
    }
  }
  const walletListItems = uniqueBy(
    [...visibleWallets, ...potentiallyHiddenWallets],
    "id"
  );
  for (const {
    createConnector: createConnector6,
    groupIndex,
    groupName,
    hidden,
    ...walletMeta
  } of walletListItems) {
    if (typeof hidden === "function") {
      const isHidden = hidden();
      if (isHidden) {
        continue;
      }
    }
    const walletMetaData = (additionalRkParams) => {
      return {
        rkDetails: omitUndefinedValues({
          ...walletMeta,
          groupIndex,
          groupName,
          isRainbowKitConnector: true,
          // These additional params will be used in rainbowkit react tree to
          // merge `walletConnectWallet` and `walletConnect` connector from wagmi with
          // showQrModal: true. This way we can let the user choose if they want to
          // connect via QR code or open the official walletConnect modal instead
          ...additionalRkParams ? additionalRkParams : {}
        })
      };
    };
    const isWalletConnectConnector = walletMeta.id === "walletConnect";
    if (isWalletConnectConnector) {
      connectors.push(
        createConnector6(
          walletMetaData({
            isWalletConnectModalConnector: true,
            showQrModal: true
          })
        )
      );
    }
    const connector = createConnector6(walletMetaData());
    connectors.push(connector);
  }
  return connectors;
};
var walletConnectInstances = /* @__PURE__ */ new Map();
var getOrCreateWalletConnectInstance = ({
  projectId,
  walletConnectParameters,
  rkDetailsShowQrModal,
  rkDetailsIsWalletConnectModalConnector
}) => {
  let config = {
    ...walletConnectParameters ? walletConnectParameters : {},
    projectId,
    showQrModal: false
    // Required. Otherwise WalletConnect modal (Web3Modal) will popup during time of connection for a wallet
  };
  if (rkDetailsShowQrModal) {
    config = { ...config, showQrModal: true };
  }
  if (!("customStoragePrefix" in config)) {
    config = {
      ...config,
      customStoragePrefix: rkDetailsIsWalletConnectModalConnector ? "clientOne" : "clientTwo"
    };
  }
  const serializedConfig = JSON.stringify(config);
  const sharedWalletConnector = walletConnectInstances.get(serializedConfig);
  if (sharedWalletConnector) {
    return sharedWalletConnector;
  }
  const newWalletConnectInstance = walletConnect(config);
  walletConnectInstances.set(serializedConfig, newWalletConnectInstance);
  return newWalletConnectInstance;
};
function createWalletConnectConnector({
  projectId,
  walletDetails,
  walletConnectParameters
}) {
  return createConnector((config) => ({
    ...getOrCreateWalletConnectInstance({
      projectId,
      walletConnectParameters,
      // Used in `connectorsForWallets` to add another
      // walletConnect wallet into rainbowkit with modal popup option
      rkDetailsShowQrModal: walletDetails.rkDetails.showQrModal,
      rkDetailsIsWalletConnectModalConnector: walletDetails.rkDetails.isWalletConnectModalConnector
    })(config),
    ...walletDetails
  }));
}
function getWalletConnectConnector({
  projectId,
  walletConnectParameters
}) {
  const exampleProjectId = "21fef48091f12692cad574a6f7753643";
  if (!projectId || projectId === "") {
    throw new Error(
      "No projectId found. Every dApp must now provide a WalletConnect Cloud projectId to enable WalletConnect v2 https://www.rainbowkit.com/docs/installation#configure"
    );
  }
  if (projectId === "YOUR_PROJECT_ID") {
    projectId = exampleProjectId;
  }
  return (walletDetails) => createWalletConnectConnector({
    projectId,
    walletDetails,
    walletConnectParameters
  });
}
function getExplicitInjectedProvider(flag) {
  const _window = typeof window !== "undefined" ? window : void 0;
  if (typeof _window === "undefined" || typeof _window.ethereum === "undefined")
    return;
  const providers = _window.ethereum.providers;
  return providers ? providers.find((provider) => provider[flag]) : _window.ethereum[flag] ? _window.ethereum : void 0;
}
function getWindowProviderNamespace(namespace) {
  const providerSearch = (provider, namespace2) => {
    const [property, ...path2] = namespace2.split(".");
    const _provider = provider[property];
    if (_provider) {
      if (path2.length === 0) return _provider;
      return providerSearch(_provider, path2.join("."));
    }
  };
  if (typeof window !== "undefined") return providerSearch(window, namespace);
}
function hasInjectedProvider({
  flag,
  namespace
}) {
  if (namespace && typeof getWindowProviderNamespace(namespace) !== "undefined")
    return true;
  if (flag && typeof getExplicitInjectedProvider(flag) !== "undefined")
    return true;
  return false;
}
function getInjectedProvider({
  flag,
  namespace
}) {
  var _a;
  const _window = typeof window !== "undefined" ? window : void 0;
  if (typeof _window === "undefined") return;
  if (namespace) {
    const windowProvider = getWindowProviderNamespace(namespace);
    if (windowProvider) return windowProvider;
  }
  const providers = (_a = _window.ethereum) == null ? void 0 : _a.providers;
  if (flag) {
    const provider = getExplicitInjectedProvider(flag);
    if (provider) return provider;
  }
  if (typeof providers !== "undefined" && providers.length > 0)
    return providers[0];
  return _window.ethereum;
}
function createInjectedConnector(provider) {
  return (walletDetails) => {
    const injectedConfig = provider ? {
      target: () => ({
        id: walletDetails.rkDetails.id,
        name: walletDetails.rkDetails.name,
        provider
      })
    } : {};
    return createConnector((config) => ({
      // Spread the injectedConfig object, which may be empty or contain the target function
      ...injected(injectedConfig)(config),
      ...walletDetails
    }));
  };
}
function getInjectedConnector({
  flag,
  namespace,
  target
}) {
  const provider = target ? target : getInjectedProvider({ flag, namespace });
  return createInjectedConnector(provider);
}
var baseAccount2 = ({ appName, appIcon }) => {
  return {
    id: "baseAccount",
    name: "Base Account",
    shortName: "Base Account",
    rdns: "app.base.account",
    iconUrl: async () => (await import("./baseAccount-44UITRK7-455ELCBI.js")).default,
    iconAccent: "#0000FF",
    iconBackground: "#0000FF",
    // a popup will appear prompting the user to connect or create a wallet via passkey.
    installed: true,
    createConnector: (walletDetails) => {
      const { ...optionalConfig } = baseAccount2;
      const connector = baseAccount({
        appName,
        appLogoUrl: appIcon,
        ...optionalConfig
      });
      return createConnector((config) => ({
        ...connector(config),
        ...walletDetails
      }));
    }
  };
};
function isMetaMask(ethereum) {
  if (!(ethereum == null ? void 0 : ethereum.isMetaMask)) return false;
  if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state)
    return false;
  if (ethereum.isApexWallet) return false;
  if (ethereum.isAvalanche) return false;
  if (ethereum.isBackpack) return false;
  if (ethereum.isBifrost) return false;
  if (ethereum.isBitKeep) return false;
  if (ethereum.isBitski) return false;
  if (ethereum.isBlockWallet) return false;
  if (ethereum.isCoinbaseWallet) return false;
  if (ethereum.isDawn) return false;
  if (ethereum.isEnkrypt) return false;
  if (ethereum.isExodus) return false;
  if (ethereum.isFrame) return false;
  if (ethereum.isFrontier) return false;
  if (ethereum.isGamestop) return false;
  if (ethereum.isHyperPay) return false;
  if (ethereum.isImToken) return false;
  if (ethereum.isKuCoinWallet) return false;
  if (ethereum.isMathWallet) return false;
  if (ethereum.isNestWallet) return false;
  if (ethereum.isOkxWallet || ethereum.isOKExWallet) return false;
  if (ethereum.isOneInchIOSWallet || ethereum.isOneInchAndroidWallet)
    return false;
  if (ethereum.isOpera) return false;
  if (ethereum.isPhantom) return false;
  if (ethereum.isPortal) return false;
  if (ethereum.isRabby) return false;
  if (ethereum.isRainbow) return false;
  if (ethereum.isStatus) return false;
  if (ethereum.isTalisman) return false;
  if (ethereum.isTally) return false;
  if (ethereum.isTokenPocket) return false;
  if (ethereum.isTokenary) return false;
  if (ethereum.isTrust || ethereum.isTrustWallet) return false;
  if (ethereum.isXDEFI) return false;
  if (ethereum.isZeal) return false;
  if (ethereum.isZerion) return false;
  if (ethereum.__seif) return false;
  return true;
}
var metaMaskWallet = ({
  projectId,
  walletConnectParameters
}) => {
  const isMetaMaskInjected = typeof window !== "undefined" ? isMetaMask(window.ethereum) : false;
  const shouldUseWalletConnect = !isMetaMaskInjected && !isMobile();
  const shouldUseMetaMaskConnector = isMetaMaskInjected || isMobile();
  return {
    id: "metaMask",
    name: "MetaMask",
    rdns: "io.metamask",
    iconUrl: async () => (await import("./metaMaskWallet-SITXT2FV-LF6QXUGG.js")).default,
    iconAccent: "#f6851a",
    iconBackground: "#fff",
    installed: isMetaMaskInjected ? isMetaMaskInjected : void 0,
    downloadUrls: {
      android: "https://play.google.com/store/apps/details?id=io.metamask",
      ios: "https://apps.apple.com/us/app/metamask/id1438144202",
      mobile: "https://metamask.io/download",
      qrCode: "https://metamask.io/download",
      chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      edge: "https://microsoftedge.microsoft.com/addons/detail/metamask/ejbalbakoplchlghecdalmeeeajnimhm",
      firefox: "https://addons.mozilla.org/firefox/addon/ether-metamask",
      opera: "https://addons.opera.com/extensions/details/metamask-10",
      browserExtension: "https://metamask.io/download"
    },
    mobile: {
      // MetaMask mobile deep linking handled by wagmi, return URI unchanged.
      getUri: shouldUseMetaMaskConnector ? (uri) => uri : void 0
    },
    qrCode: shouldUseWalletConnect ? {
      getUri: (uri) => `https://metamask.app.link/wc?uri=${encodeURIComponent(uri)}`,
      instructions: {
        learnMoreUrl: "https://metamask.io/faqs/",
        steps: [
          {
            description: "wallet_connectors.metamask.qr_code.step1.description",
            step: "install",
            title: "wallet_connectors.metamask.qr_code.step1.title"
          },
          {
            description: "wallet_connectors.metamask.qr_code.step2.description",
            step: "create",
            title: "wallet_connectors.metamask.qr_code.step2.title"
          },
          {
            description: "wallet_connectors.metamask.qr_code.step3.description",
            step: "refresh",
            title: "wallet_connectors.metamask.qr_code.step3.title"
          }
        ]
      }
    } : void 0,
    extension: {
      instructions: {
        learnMoreUrl: "https://metamask.io/faqs/",
        steps: [
          {
            description: "wallet_connectors.metamask.extension.step1.description",
            step: "install",
            title: "wallet_connectors.metamask.extension.step1.title"
          },
          {
            description: "wallet_connectors.metamask.extension.step2.description",
            step: "create",
            title: "wallet_connectors.metamask.extension.step2.title"
          },
          {
            description: "wallet_connectors.metamask.extension.step3.description",
            step: "refresh",
            title: "wallet_connectors.metamask.extension.step3.title"
          }
        ]
      }
    },
    createConnector: shouldUseWalletConnect ? getWalletConnectConnector({
      projectId,
      walletConnectParameters
    }) : (
      // MetaMask connector
      (walletDetails) => {
        return createConnector((config) => {
          var _a, _b, _c;
          const metamaskConnector = metaMask({
            dappMetadata: {
              connector: "rainbowkit",
              name: (_a = walletConnectParameters == null ? void 0 : walletConnectParameters.metadata) == null ? void 0 : _a.name,
              iconUrl: (_b = walletConnectParameters == null ? void 0 : walletConnectParameters.metadata) == null ? void 0 : _b.icons[0],
              url: (_c = walletConnectParameters == null ? void 0 : walletConnectParameters.metadata) == null ? void 0 : _c.url
            },
            headless: true,
            checkInstallationImmediately: false,
            enableAnalytics: false
          })(config);
          return {
            ...metamaskConnector,
            ...walletDetails,
            getChainId: async () => {
              var _a2;
              try {
                return await metamaskConnector.getChainId();
              } catch {
                return ((_a2 = config.chains[0]) == null ? void 0 : _a2.id) ?? 1;
              }
            }
          };
        });
      }
    )
  };
};
var rainbowWallet = ({
  projectId,
  walletConnectParameters
}) => {
  const isRainbowInjected = hasInjectedProvider({ flag: "isRainbow" });
  const shouldUseWalletConnect = !isRainbowInjected;
  const getUri = (uri) => {
    return isAndroid() ? uri : isIOS() ? `rainbow://wc?uri=${encodeURIComponent(uri)}&connector=rainbowkit` : `https://rnbwapp.com/wc?uri=${encodeURIComponent(
      uri
    )}&connector=rainbowkit`;
  };
  return {
    id: "rainbow",
    name: "Rainbow",
    rdns: "me.rainbow",
    iconUrl: async () => (await import("./rainbowWallet-O26YNBMX-MBAJ43QR.js")).default,
    iconBackground: "#0c2f78",
    installed: !shouldUseWalletConnect ? isRainbowInjected : void 0,
    downloadUrls: {
      android: "https://play.google.com/store/apps/details?id=me.rainbow&referrer=utm_source%3Drainbowkit&utm_source=rainbowkit",
      ios: "https://apps.apple.com/app/apple-store/id1457119021?pt=119997837&ct=rainbowkit&mt=8",
      mobile: "https://rainbow.download?utm_source=rainbowkit",
      qrCode: "https://rainbow.download?utm_source=rainbowkit&utm_medium=qrcode",
      browserExtension: "https://rainbow.me/extension?utm_source=rainbowkit"
    },
    mobile: { getUri: shouldUseWalletConnect ? getUri : void 0 },
    qrCode: shouldUseWalletConnect ? {
      getUri,
      instructions: {
        learnMoreUrl: "https://learn.rainbow.me/connect-to-a-website-or-app?utm_source=rainbowkit&utm_medium=connector&utm_campaign=learnmore",
        steps: [
          {
            description: "wallet_connectors.rainbow.qr_code.step1.description",
            step: "install",
            title: "wallet_connectors.rainbow.qr_code.step1.title"
          },
          {
            description: "wallet_connectors.rainbow.qr_code.step2.description",
            step: "create",
            title: "wallet_connectors.rainbow.qr_code.step2.title"
          },
          {
            description: "wallet_connectors.rainbow.qr_code.step3.description",
            step: "scan",
            title: "wallet_connectors.rainbow.qr_code.step3.title"
          }
        ]
      }
    } : void 0,
    createConnector: shouldUseWalletConnect ? getWalletConnectConnector({
      projectId,
      walletConnectParameters
    }) : getInjectedConnector({ flag: "isRainbow" })
  };
};
var safeWallet = () => ({
  id: "safe",
  name: "Safe",
  iconAccent: "#12ff80",
  iconBackground: "#fff",
  iconUrl: async () => (await import("./safeWallet-5MNKTR5Z-A256ZB2D.js")).default,
  installed: (
    // Only allowed in iframe context
    // borrowed from wagmi safe connector
    !(typeof window === "undefined") && (window == null ? void 0 : window.parent) !== window
  ),
  downloadUrls: {
    // We're opting not to provide a download prompt if the application is not
    // already running as a Safe App within the context of the Safe browser,
    // since it's unlikely to be a desired behavior for users.
  },
  createConnector: (walletDetails) => {
    return createConnector((config) => ({
      ...safe()(config),
      ...walletDetails
    }));
  }
});
var walletConnectWallet = ({
  projectId,
  options
}) => {
  const getUri = (uri) => uri;
  return {
    id: "walletConnect",
    name: "WalletConnect",
    installed: void 0,
    iconUrl: async () => (await import("./walletConnectWallet-YHWKVTDY-SZBTAA2F.js")).default,
    iconBackground: "#3b99fc",
    qrCode: { getUri },
    createConnector: getWalletConnectConnector({
      projectId,
      walletConnectParameters: options
    })
  };
};
var createDefaultTransports = (chains) => {
  const transportsObject = chains.reduce((acc, chain) => {
    const key = chain.id;
    acc[key] = http();
    return acc;
  }, {});
  return transportsObject;
};
var getDefaultConfig = ({
  appName,
  appDescription,
  appUrl,
  appIcon,
  wallets,
  projectId,
  ...wagmiParameters
}) => {
  const { transports, chains, ...restWagmiParameters } = wagmiParameters;
  const metadata = computeWalletConnectMetaData({
    appName,
    appDescription,
    appUrl,
    appIcon
  });
  const connectors = connectorsForWallets(
    wallets || [
      {
        groupName: "Popular",
        wallets: [
          safeWallet,
          rainbowWallet,
          baseAccount2,
          metaMaskWallet,
          walletConnectWallet
        ]
      }
    ],
    {
      projectId,
      appName,
      appDescription,
      appUrl,
      appIcon,
      walletConnectParameters: { metadata }
    }
  );
  return createConfig({
    connectors,
    chains,
    transports: transports || createDefaultTransports(chains),
    ...restWagmiParameters
  });
};
function getDefaultWallets(parameters) {
  const wallets = [
    {
      groupName: "Popular",
      wallets: [
        safeWallet,
        rainbowWallet,
        baseAccount2,
        metaMaskWallet,
        walletConnectWallet
      ]
    }
  ];
  if (parameters) {
    return {
      connectors: connectorsForWallets(wallets, parameters),
      wallets
    };
  }
  return {
    wallets
  };
}
function useAddRecentTransaction() {
  const store = useTransactionStore();
  const { address } = useAccount();
  const chainId = useChainId();
  return (0, import_react79.useCallback)(
    (transaction) => {
      if (!address || !chainId) {
        throw new Error("No address or chain ID found");
      }
      store.addTransaction(address, chainId, transaction);
    },
    [store, address, chainId]
  );
}
var __private__ = {
  DesktopOptions,
  dialogContent,
  dialogContentMobile,
  MobileOptions
};
export {
  ConnectButton,
  RainbowKitAuthenticationProvider,
  RainbowKitProvider,
  WalletButton2 as WalletButton,
  __private__,
  connectorsForWallets,
  createAuthenticationAdapter,
  cssObjectFromTheme,
  cssStringFromTheme,
  darkTheme,
  getDefaultConfig,
  getDefaultWallets,
  getWalletConnectConnector,
  lightTheme,
  midnightTheme,
  useAccountModal,
  useAddRecentTransaction,
  useChainModal,
  useConnectModal
};
/*! Bundled license information:

@noble/curves/esm/abstract/bls.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/tower.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/bls12-381.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

qr/index.js:
  (*!
  Copyright (c) 2023 Paul Miller (paulmillr.com)
  The library paulmillr-qr is dual-licensed under the Apache 2.0 OR MIT license.
  You can select a license of your choice.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  
      http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  *)

@gemini-wallet/core/dist/index.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@rainbow-me_rainbowkit.js.map
